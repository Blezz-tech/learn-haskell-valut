# Введение

## Об этом учебном пособии

Добро пожаловать в **Выучи Haskell для Великого Блага**! Если вы читаете это, то возможно вы хотите выучить Haskell. Что ж, вы обратились по адресу, но давайте немного поговорим об этом уроке.

Я решил написать это, потому что хотел укрепить свои собственные знания о Haskell и потому что думал, что смогу помочь людям, новичкам в Haskell, изучить его с моей точки зрения. В Интернете есть довольно много учебных пособий по Haskell. Когда я начинал изучать Haskell, я учился на нескольких ресурсах. Я научился, прочитав несколько разных учебников и статей, потому что каждый объяснял что-то по другому, чем другой. Просмотрев несколько ресурсов, я смог собрать воедино кусочки, и все просто встало на свои места. Итак, это попытка добавить еще один полезный ресурс для изучения Haskell, чтобы у вас было больше шансов найти тот, который вам понравится.

![[LYHfGG_1_bird.png]]

Это руководство предназначено для людей, которые имеют опыт работы с императивными языками программирования (C, C ++, Java, Python ...), но никогда раньше не программировали на функциональном языке (Haskell, ML, OCaml вЂ/). Хотя я готов поспорить, что даже если у вас нет сколько-нибудь значительного опыта в программировании, такой умный человек, как вы, сможет последовать примеру и изучить Haskell.

Канал #haskell в сети freenode - отличное место, чтобы задать вопросы, если вы чувствуете себя застрявшим. Люди там чрезвычайно милы, терпеливы и с пониманием относятся к новичкам.

Мне не удалось выучить Haskell примерно 2 раза, прежде чем я, наконец, понял его, потому что все это казалось мне слишком странным, и я этого не понял. Но затем, как только это просто "щелкнуло" и после преодоления этого первоначального препятствия, все прошло довольно гладко. Наверное, я пытаюсь сказать следующее: Haskell великолепен, и если вы интересуетесь программированием, вам действительно следует его изучить, даже если поначалу это кажется странным. Изучение Haskell во многом похоже на обучение программированию в первый раз — это весело! Это заставляет вас думать по-другому, что подводит нас к следующему разделу ...

## Итак, что такое Haskell?

![[LYHfGG_2_fx.png]]

Haskell - это **чисто функциональный язык программирования**. В императивных языках вы добиваетесь цели, задавая компьютеру последовательность задач, а затем он их выполняет. Во время их выполнения он может изменять состояние. Например, вы устанавливаете переменной `a` значение 5, а затем делаете что-то еще, а затем устанавливаете ее значение на что-то другое. У вас есть структуры потока управления для выполнения какого-либо действия несколько раз. В чисто функциональном программировании вы не указываете компьютеру, что делать как таковое, а скорее сообщаете ему, чем этот материал _является_. Факториал числа - это произведение всех чисел от 1 до этого числа, сумма списка чисел - это первое число плюс сумма всех остальных чисел и так далее. Вы выражаете это в форме функций. Вы также не можете присвоить переменной значение чего-то, а затем присвоить ей значение чего-то другого позже. Если вы скажете, что `a` равно 5, вы не сможете позже сказать, что это что-то другое, потому что вы только что сказали, что это 5. Ты что, какой-то лжец? Таким образом, в чисто функциональных языках функция не имеет побочных эффектов. Единственное, что может сделать функция, - это вычислить что-то и вернуть это в результате. На первый взгляд это кажется своего рода ограничением, но на самом деле это имеет некоторые очень приятные последствия: если функция вызывается дважды с одними и теми же параметрами, она гарантированно возвращает один и тот же результат. Это называется прозрачностью ссылок, и она не только позволяет компилятору рассуждать о поведении программы, но и позволяет вам легко вывести (и даже доказать), что функция верна, а затем создавать более сложные функции путем склеивания простых функций вместе.

![[LYHfGG_3_lazy.png]]

Haskell **ленив**. Это означает, что, если специально не указано иное, Haskell не будет выполнять функции и вычислять что-либо, пока его действительно не заставят показать вам результат. Это хорошо сочетается со ссылочной прозрачностью и позволяет вам думать о программах как о серии **преобразований данных**. Это также позволяет создавать интересные вещи, такие как бесконечные структуры данных. Допустим, у вас есть неизменяемый список чисел `xs = [1,2,3,4,5,6,7,8]` и функция `doubleMe`, которая умножает каждый элемент на 2, а затем возвращает новый список. Если бы мы хотели умножить наш список на 8 на императивном языке и сделали `doubleMe( doubleMe( doubleMe(xs) ) )`, он, вероятно, прошел бы по списку один раз и сделал копию, а затем вернул бы ее. Затем он пройдет по списку еще два раза и вернет результат. На ленивом языке вызов `doubleMe` в списке, не заставляя его показывать вам результат, приводит к тому, что программа как бы говорит вам: "Да, да, я сделаю это позже!". Но как только вы захотите увидеть результат, первая "двойная строка" сообщит второй, что она хочет получить результат, сейчас же! Вторая скажет это третьей, и третья неохотно возвращает удвоенную 1, которая равна 2. Вторая получает это и возвращает 4 первой. Первая видит это и сообщает вам, что первый элемент равен 8. Таким образом, он выполняет только один проход по списку и только тогда, когда вам это действительно нужно. Таким образом, когда вам нужно что-то из ленивого языка, вы можете просто взять некоторые исходные данные и эффективно преобразовать и исправить их, чтобы они напоминали то, что вы хотите в конце.

![[LYHfGG_4_boat.png]]

Haskell является **статически типизированным**. Когда вы компилируете свою программу, компилятор знает, какой фрагмент кода является числом, который - строкой и так далее. Это означает, что во время компиляции обнаруживается множество возможных ошибок. Если вы попытаетесь сложить вместе число и строку, компилятор будет ныть на вас. Haskell использует очень хорошую систему типов, которая имеет **вывод типа**. Это означает, что вам не нужно явно помечать каждый фрагмент кода типом, потому что система типов может разумно многое выяснить об этом. Если вы говорите `a = 5 + 4`, вам не нужно говорить Haskell, что `a` - это число, он может вычислить это сам. Вывод типа также позволяет вашему коду быть более общим. Если созданная вами функция принимает два параметра и складывает их вместе, и вы явно не указываете их тип, функция будет работать с любыми двумя параметрами, которые действуют как числа.

Haskell **элегантен и лаконичен**. Поскольку в нем используется много высокоуровневых концепций, программы на Haskell обычно короче своих императивных эквивалентов. А более короткие программы легче поддерживать, чем более длинные, и в них меньше ошибок.

Haskell был создан несколькими **действительно умными парнями** (с докторскими степенями). Работа над Haskell началась в 1987 году, когда комитет исследователей собрался вместе для разработки потрясающего языка. В 2003 году был опубликован отчет Haskell, в котором определяется стабильная версия языка.

## Во что вам нужно погрузиться

Текстовый редактор и компилятор Haskell. Вероятно, у вас уже установлен ваш любимый текстовый редактор, так что мы не будем тратить на это время. Для целей этого руководства мы будем использовать GHC, наиболее широко используемый компилятор Haskell. Лучший способ начать - это загрузить [Haskell Platform](http://hackage.haskell.org/platform/), который в основном представляет собой Haskell с включенными батарейками.

GHC может взять скрипт на Haskell (обычно они имеют расширение .hs) и скомпилировать его, но он также имеет интерактивный режим, который позволяет вам интерактивно взаимодействовать со скриптами. Интерактивно. Вы можете вызывать функции из скриптов, которые вы загружаете, и результаты отображаются немедленно. Для обучения это намного проще и быстрее, чем компилировать каждый раз, когда вы вносите изменения, а затем запускать программу из командной строки. Интерактивный режим вызывается путем ввода `ghci` в вашей командной строке. Если вы определили какие-то функции в файле с именем, скажем, `myfunctions.hs`, вы загружаете эти функции, введя `:l myfunctions`, а затем можете поиграть с ними, при условии, что `myfunctions.hs` находится в той же папке, из которой был вызван `ghci`. Если вы измените скрипт .hs, просто снова запустите `:l myfunctions` или выполните `:r`, что эквивалентно, поскольку оно перезагружает текущий скрипт. Обычный рабочий процесс для меня, когда я копаюсь в материалах, - это определение некоторых функций в файле .hs, его загрузка и возня с ними, а затем изменение файла .hs, повторная загрузка и так далее. Это тоже то, чем мы будем заниматься здесь.

