# Введение

## Об этом учебном пособии

Добро пожаловать в **Выучи Haskell для Великого Блага**! Если вы читаете это, то возможно вы хотите выучить Haskell. Что ж, вы обратились по адресу, но давайте немного поговорим об этом уроке.

Я решил написать это, потому что хотел укрепить свои собственные знания о Haskell и потому что думал, что смогу помочь людям, новичкам в Haskell, изучить его с моей точки зрения. В Интернете есть довольно много учебных пособий по Haskell. Когда я начинал изучать Haskell, я учился на нескольких ресурсах. Я научился, прочитав несколько разных учебников и статей, потому что каждый объяснял что-то по другому, чем другой. Просмотрев несколько ресурсов, я смог собрать воедино кусочки, и все просто встало на свои места. Итак, это попытка добавить еще один полезный ресурс для изучения Haskell, чтобы у вас было больше шансов найти тот, который вам понравится.

![[LYHfGG_1_bird.png]]

Это руководство предназначено для людей, которые имеют опыт работы с императивными языками программирования (C, C ++, Java, Python ...), но никогда раньше не программировали на функциональном языке (Haskell, ML, OCaml вЂ/). Хотя я готов поспорить, что даже если у вас нет сколько-нибудь значительного опыта в программировании, такой умный человек, как вы, сможет последовать примеру и изучить Haskell.

Канал #haskell в сети freenode - отличное место, чтобы задать вопросы, если вы чувствуете себя застрявшим. Люди там чрезвычайно милы, терпеливы и с пониманием относятся к новичкам.

Мне не удалось выучить Haskell примерно 2 раза, прежде чем я, наконец, понял его, потому что все это казалось мне слишком странным, и я этого не понял. Но затем, как только это просто "щелкнуло" и после преодоления этого первоначального препятствия, все прошло довольно гладко. Наверное, я пытаюсь сказать следующее: Haskell великолепен, и если вы интересуетесь программированием, вам действительно следует его изучить, даже если поначалу это кажется странным. Изучение Haskell во многом похоже на обучение программированию в первый раз — это весело! Это заставляет вас думать по-другому, что подводит нас к следующему разделу ...

## Итак, что такое Haskell?

![[LYHfGG_2_fx.png]]

Haskell - это **чисто функциональный язык программирования**. В императивных языках вы добиваетесь цели, задавая компьютеру последовательность задач, а затем он их выполняет. Во время их выполнения он может изменять состояние. Например, вы устанавливаете переменной `a` значение 5, а затем делаете что-то еще, а затем устанавливаете ее значение на что-то другое. У вас есть структуры потока управления для выполнения какого-либо действия несколько раз. В чисто функциональном программировании вы не указываете компьютеру, что делать как таковое, а скорее сообщаете ему, чем этот материал _является_. Факториал числа - это произведение всех чисел от 1 до этого числа, сумма списка чисел - это первое число плюс сумма всех остальных чисел и так далее. Вы выражаете это в форме функций. Вы также не можете присвоить переменной значение чего-то, а затем присвоить ей значение чего-то другого позже. Если вы скажете, что `a` равно 5, вы не сможете позже сказать, что это что-то другое, потому что вы только что сказали, что это 5. Ты что, какой-то лжец? Таким образом, в чисто функциональных языках функция не имеет побочных эффектов. Единственное, что может сделать функция, - это вычислить что-то и вернуть это в результате. На первый взгляд это кажется своего рода ограничением, но на самом деле это имеет некоторые очень приятные последствия: если функция вызывается дважды с одними и теми же параметрами, она гарантированно возвращает один и тот же результат. Это называется прозрачностью ссылок, и она не только позволяет компилятору рассуждать о поведении программы, но и позволяет вам легко вывести (и даже доказать), что функция верна, а затем создавать более сложные функции путем склеивания простых функций вместе.

![[LYHfGG_3_lazy.png]]

Haskell **ленив**. Это означает, что, если специально не указано иное, Haskell не будет выполнять функции и вычислять что-либо, пока его действительно не заставят показать вам результат. Это хорошо сочетается со ссылочной прозрачностью и позволяет вам думать о программах как о серии **преобразований данных**. Это также позволяет создавать интересные вещи, такие как бесконечные структуры данных. Допустим, у вас есть неизменяемый список чисел `xs = [1,2,3,4,5,6,7,8]` и функция `doubleMe`, которая умножает каждый элемент на 2, а затем возвращает новый список. Если бы мы хотели умножить наш список на 8 на императивном языке и сделали `doubleMe( doubleMe( doubleMe(xs) ) )`, он, вероятно, прошел бы по списку один раз и сделал копию, а затем вернул бы ее. Затем он пройдет по списку еще два раза и вернет результат. На ленивом языке вызов `doubleMe` в списке, не заставляя его показывать вам результат, приводит к тому, что программа как бы говорит вам: "Да, да, я сделаю это позже!". Но как только вы захотите увидеть результат, первая "двойная строка" сообщит второй, что она хочет получить результат, сейчас же! Вторая скажет это третьей, и третья неохотно возвращает удвоенную 1, которая равна 2. Вторая получает это и возвращает 4 первой. Первая видит это и сообщает вам, что первый элемент равен 8. Таким образом, он выполняет только один проход по списку и только тогда, когда вам это действительно нужно. Таким образом, когда вам нужно что-то из ленивого языка, вы можете просто взять некоторые исходные данные и эффективно преобразовать и исправить их, чтобы они напоминали то, что вы хотите в конце.

![[LYHfGG_4_boat.png]]

Haskell является **статически типизированным**. Когда вы компилируете свою программу, компилятор знает, какой фрагмент кода является числом, который - строкой и так далее. Это означает, что во время компиляции обнаруживается множество возможных ошибок. Если вы попытаетесь сложить вместе число и строку, компилятор будет ныть на вас. Haskell использует очень хорошую систему типов, которая имеет **вывод типа**. Это означает, что вам не нужно явно помечать каждый фрагмент кода типом, потому что система типов может разумно многое выяснить об этом. Если вы говорите `a = 5 + 4`, вам не нужно говорить Haskell, что `a` - это число, он может вычислить это сам. Вывод типа также позволяет вашему коду быть более общим. Если созданная вами функция принимает два параметра и складывает их вместе, и вы явно не указываете их тип, функция будет работать с любыми двумя параметрами, которые действуют как числа.

Haskell **элегантен и лаконичен**. Поскольку в нем используется много высокоуровневых концепций, программы на Haskell обычно короче своих императивных эквивалентов. А более короткие программы легче поддерживать, чем более длинные, и в них меньше ошибок.

Haskell был создан несколькими **действительно умными парнями** (с докторскими степенями). Работа над Haskell началась в 1987 году, когда комитет исследователей собрался вместе для разработки потрясающего языка. В 2003 году был опубликован отчет Haskell, в котором определяется стабильная версия языка.

## Во что вам нужно погрузиться

Текстовый редактор и компилятор Haskell. Вероятно, у вас уже установлен ваш любимый текстовый редактор, так что мы не будем тратить на это время. Для целей этого руководства мы будем использовать GHC, наиболее широко используемый компилятор Haskell. Лучший способ начать - это загрузить [Haskell Platform](http://hackage.haskell.org/platform/), который в основном представляет собой Haskell с включенными батарейками.

GHC может взять скрипт на Haskell (обычно они имеют расширение .hs) и скомпилировать его, но он также имеет интерактивный режим, который позволяет вам интерактивно взаимодействовать со скриптами. Интерактивно. Вы можете вызывать функции из скриптов, которые вы загружаете, и результаты отображаются немедленно. Для обучения это намного проще и быстрее, чем компилировать каждый раз, когда вы вносите изменения, а затем запускать программу из командной строки. Интерактивный режим вызывается путем ввода `ghci` в вашей командной строке. Если вы определили какие-то функции в файле с именем, скажем, `myfunctions.hs`, вы загружаете эти функции, введя `:l myfunctions`, а затем можете поиграть с ними, при условии, что `myfunctions.hs` находится в той же папке, из которой был вызван `ghci`. Если вы измените скрипт .hs, просто снова запустите `:l myfunctions` или выполните `:r`, что эквивалентно, поскольку оно перезагружает текущий скрипт. Обычный рабочий процесс для меня, когда я копаюсь в материалах, - это определение некоторых функций в файле .hs, его загрузка и возня с ними, а затем изменение файла .hs, повторная загрузка и так далее. Это тоже то, чем мы будем заниматься здесь.

# Начиная

## На старт, внимание, марш!

![[LYHfGG_5_startingout.png]]

Хорошо, давайте начнем! Если вы из тех ужасных людей, которые не читают введения к книгам, и вы пропустили его, возможно, вы все равно захотите прочитать последний раздел введения, потому что в нем объясняется, что вам нужно для выполнения этого руководства и как мы собираемся загружать функции. Первое, что мы собираемся сделать, это запустить интерактивный режим ghc и вызвать какую-нибудь функцию, чтобы получить самое базовое представление о Haskell. Откройте свой терминал и введите `ghci`. Вас встретят чем-то вроде этого.

```haskell
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Prelude>
```

Поздравляю, вы находитесь в GHCI! Подсказка здесь `Prelude>`, но поскольку она может стать длиннее, когда вы загружаете материал в сеанс, мы собираемся использовать `ghci>`. Если вы хотите получить такое же приглашение, просто введите `:set prompt "ghci> "`.

Вот несколько простых арифметических действий.

```haskell
ghci> 2 + 15
17
ghci> 49 * 100
4900
ghci> 1892 - 1472
420
ghci> 5 / 2
2.5
ghci>
```

Это говорит само за себя. Мы также можем использовать несколько операторов в одной строке, и при этом соблюдаются все обычные правила приоритета. Мы можем использовать круглые скобки, чтобы сделать приоритет явным или изменить его.

```haskell
ghci> (50 * 100) - 4999
1
ghci> 50 * 100 - 4999
1
ghci> 50 * (100 - 4999)
-244950
```

Довольно круто, да? Да, я знаю, что это не так, но потерпи меня. Небольшая ошибка, на которую следует обратить внимание здесь, - это отрицание чисел. Если мы хотим получить отрицательное число, всегда лучше заключить его в круглые скобки. Выполнение `5 * -3` заставит GHCI кричать на вас, но выполнение `5 * (-3)` будет работать просто отлично.

Булева алгебра также довольно проста. Как вы, вероятно, знаете, `&&` означает логическое _И_, `||` означает логическое _ИЛИ_ . `not` отрицает `True` или `False`.

```haskell
ghci> True && False
False
ghci> True && True
True
ghci> False || True
True 
ghci> not False
True
ghci> not (True && True)
False
```

Проверка на равенство выполняется следующим образом.

```haskell
ghci> 5 == 5
True
ghci> 1 == 0
False
ghci> 5 /= 5
False
ghci> 5 /= 4
True
ghci> "hello" == "hello"
True 
```

Как насчет того, чтобы сделать `5 + "llama"` или `5 == True`? Что ж, если мы попробуем первый фрагмент, то получим большое пугающее сообщение об ошибке!

```haskell
No instance for (Num [Char])
arising from a use of `+' at <interactive>:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama" 
```

Черт возьми! GHCI говорит нам здесь, что "llama" - это не число, и поэтому он не знает, как добавить его к 5. Даже если бы это была не `"llama", а "four" или "4", Haskell все равно не счел бы это числом. `+` ожидает, что его левая и правая стороны будут числами. Если бы мы попытались выполнить `True == 5`, GHCI сказал бы нам, что типы не совпадают. В то время как `+` работает только с теми вещами, которые считаются числами, `==` работает с любыми двумя вещами, которые можно сравнить. Но загвоздка в том, что они оба должны быть одного типа. Вы не можете сравнивать яблоки и апельсины. Мы подробнее рассмотрим типы чуть позже. 

> Примечание: вы можете использовать `5 + 4.0`, потому что `5` является скрытым и может действовать как целое число или число с плавающей запятой. `4.0` не может действовать как целое число, поэтому `5` - это то, что должно адаптироваться.

Возможно, вы этого не знали, но мы все это время использовали функции. Например, `*` - это функция, которая принимает два числа и умножает их. Как вы видели, мы вызываем это, помещая его между ними. Это то, что мы называем _инфиксной_ функцией. Большинство функций, которые не используются с числами, являются _префиксными_ функциями. Давайте взглянем на них.

![[LYHfGG_6_ringring.png]]

Функции обычно являются префиксными, поэтому с этого момента мы не будем явно указывать, что функция имеет префиксную форму, мы просто предположим это. В большинстве императивных языков функции вызываются путем ввода имени функции, а затем ее параметров в круглых скобках, обычно через запятую. В Haskell функции вызываются путем ввода имени функции, пробела, а затем параметров, разделенных пробелами. Для начала мы попробуем вызвать одну из самых скучных функций в Haskell.

```haskell
ghci> succ 8
9 
```

Функция `succ` принимает все, что имеет определенного преемника, и возвращает этого преемника.^[Преемник (successor) - это число, следующее после некоторого натурального числа. <br>
Форма: Число + 1 = Преемник <br>
Функция приемника (successor function) - это функция, которая отправляет натуральное число следующему. <br>
Формула: f(x) = x + 1] Как вы можете видеть, мы просто отделяем имя функции от параметра пробелом. Вызов функции с несколькими параметрами также прост. Функции `min` и `max` используют две вещи, которые можно упорядочить (например, числа!). `min` возвращает значение, которое меньше, а `max` возвращает значение, которое больше. Смотрите сами:

```haskell
ghci> min 9 10
9
ghci> min 3.4 3.2
3.2
ghci> max 100 101
101 
```

Функциональное приложение (вызывающее функцию, ставя после нее пробел, а затем вводя параметры) имеет самый высокий приоритет из всех. Для нас это означает, что эти два утверждения эквивалентны.

```haskell
ghci> succ 9 + max 5 4 + 1
16
ghci> (succ 9) + (max 5 4) + 1
16
```

Однако, если бы мы хотели получить преемника произведения чисел 9 и 10, мы не могли бы написать `succ 9 * 10`, потому что это дало бы преемника 9, который затем был бы умножен на 10. Итак, 100. Нам пришлось бы написать `succ (9 * 10)`, чтобы получить 91.

Если функция принимает два параметра, мы также можем вызвать ее как инфиксную функцию, окружив ее обратными кавычками (` `` `). Например, функция `div` принимает два целых числа и выполняет целочисленное деление между ними. Выполнение `div 92 10` приводит к получению 9. Но когда мы называем это таким образом, может возникнуть некоторая путаница относительно того, какое число выполняет деление, а какое делится. Таким образом, мы можем вызвать это как инфиксную функцию, выполнив команду ``92 `div` 10``, и внезапно все становится намного понятнее.

Многие люди, пришедшие из императивных языков, склонны придерживаться представления о том, что круглые скобки должны обозначать применение функции. Например, в `C` вы используете круглые скобки для вызова таких функций, как `foo()`, `bar(1)` или `baz(3, "ха-ха")`. Как мы уже говорили, пробелы используются для применения функций в Haskell. Таким образом, этими функциями в Haskell были бы `foo`, `bar 1` и `baz 3 "ха-ха"`. Поэтому, если вы видите что-то вроде `bar (bar 3)`, это не означает, что `bar` вызывается с `bar` и `3` в качестве параметров. Это означает, что мы сначала вызываем функцию `bar` с `3` в качестве параметра, чтобы получить некоторое число, а затем мы снова вызываем `bar` с этим числом. В `C` это было бы что-то вроде `bar(bar(3))`.

## Первые детские функции

В предыдущем разделе мы получили базовое представление о вызове функций. Теперь давайте попробуем сделать нашу собственную функцию! Откройте свой любимый текстовый редактор и введите эту функцию, которая принимает число и умножает его на два.

```haskell
doubleMe x = x + x
```

Функции определяются аналогично тому, как они вызываются. За именем функции следуют параметры, разделенные пробелами. Но при определении функций есть `=`, и после этого мы определяем, что делает функция. Сохраните это как "baby.hs" или что-то в этом роде. Теперь перейдите туда, где он сохранен, и запустите `ghci` оттуда. Оказавшись внутри GHCI, выполните `:l baby`. Теперь, когда наш скрипт загружен, мы можем поиграть с функцией, которую мы определили.

```haskell
ghci> :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci> doubleMe 9
18
ghci> doubleMe 8.3
16.6 
```

Поскольку `+` работает как с целыми числами, так и с числами с плавающей запятой (все, что на самом деле можно считать числом), наша функция также работает с любым числом. Давайте создадим функцию, которая принимает два числа и умножает каждое на два, а затем складывает их вместе.

```haskell
doubleUs x y = x*2 + y*2 
```

Просто. Мы могли бы также определить это как `doubleUs x y = x + x + y + y`. Тестирование дает довольно предсказуемые результаты (не забудьте добавить эту функцию в файл `baby.hs`, сохранить его, а затем выполнить `:l baby` внутри GHCI).

```haskell
ghci> doubleUs 4 9
26
ghci> doubleUs 2.3 34.2
73.0
ghci> doubleUs 28 88 + doubleMe 123
478
```

Как и ожидалось, вы можете вызывать свои собственные функции из других созданных вами функций. Имея это в виду, мы могли бы переопределить `doubleUs` следующим образом:

```haskell
doubleUs x y = doubleMe x + doubleMe y 
```

Это очень простой пример общего шаблона, который вы увидите во всем Haskell. Создание базовых функций, которые, очевидно, являются правильными, а затем объединение их в более сложные функции. Таким образом, вы также избежите повторения. Что, если бы какие-нибудь математики выяснили, что 2 на самом деле равно 3, и вам пришлось бы изменить свою программу? Вы могли бы просто переопределить `doubleMe` на `x + x + x`, и поскольку `doubleUs` вызывает `doubleMe`, это автоматически сработало бы в этом странном новом мире, где 2 равно 3.

Функции в Haskell не обязательно должны располагаться в каком-либо определенном порядке, поэтому не имеет значения, определяете ли вы сначала `doubleMe`, а затем `doubleUs` или делаете это наоборот.

Теперь мы собираемся создать функцию, которая умножает число на 2, но только если это число меньше или равно 100, потому что числа больше 100 и так достаточно велики!

```haskell
doubleSmallNumber x = if x > 100
                        then x
                        else x*2 
```

![[LYHfGG_7_baby.png]]

Прямо здесь мы представили оператор `if`. Вероятно, вы знакомы с операторами `if` из других языков. Разница между оператором `if` в Haskell и операторами `if` в императивных языках заключается в том, что часть `else` является обязательной в Haskell. В императивных языках вы можете просто пропустить пару шагов, если условие не выполнено, но в Haskell каждое выражение и функция должны что-то возвращать. Мы могли бы также написать это выражение `if` в одной строке, но я нахожу этот способ более читабельным. Еще одна особенность оператора `if` в Haskell заключается в том, что оператор является _выражением_ . Выражение - это, по сути, фрагмент кода, который возвращает значение. `5` - это выражение, потому что оно возвращает 5, `4 + 8` - это выражение, `x + y` - это выражение, потому что оно возвращает сумму `x` и `y`. Поскольку `else` является обязательным, оператор `if` всегда будет возвращать что-то, и именно поэтому это выражение. Если бы мы хотели добавить единицу к каждому числу, полученному в нашей предыдущей функции, мы могли бы написать ее тело следующим образом.

```haskell
doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
```

Если бы мы опустили круглые скобки, это добавило бы единицу только в том случае, если `x` было не больше 100. Обратите внимание на `'` в конце имени функции. Этот апостроф не имеет никакого особого значения в синтаксисе Haskell. Это допустимый символ для использования в имени функции. Обычно мы используем `'` либо для обозначения строгой версии функции (той, которая не является ленивой), либо для слегка измененной версии функции или переменной. Поскольку `'` является допустимым символом в функциях, мы можем создать функцию, подобную этой.

```haskell
conanO'Brien = "It's a-me, Conan O'Brien!" 
```

Здесь есть две заслуживающие внимания вещи. Во-первых, мы не написали имя функции с заглавной буквы. Это потому, что функции не могут начинаться с заглавных букв. Мы поймем, почему, чуть позже. Во-вторых, эта функция не принимает никаких параметров. Когда функция не принимает никаких параметров, мы обычно говорим, что это _определение_ (или _имя_^[Честно говоря не знаю как правильнее в данном случае перевести слово name]). Поскольку мы не можем изменить значение имен (и функций), как только мы их определили, `conanO'Brien` и строка `"It's a-me, Conan O'Brien!"` могут использоваться взаимозаменяемо.

## Введение в списки

![[LYHfGG_8_list.png]]

Подобно спискам покупок в реальном мире, списки в Haskell очень полезны. Это наиболее используемая структура данных, и ее можно использовать множеством различных способов для моделирования и решения целого ряда проблем. Списки - это ТАК здорово. В этом разделе мы рассмотрим основы списков, строк (которые являются списками) и понимания списков.

В Haskell списки представляют собой **однородную** (англ. homogenous) структуру данных. В нем хранится несколько элементов одного и того же типа. Это означает, что у нас может быть список целых чисел или список символов, но у нас не может быть списка, состоящего из нескольких целых чисел, а затем нескольких символов. А теперь список!

> **Примечание**: Мы можем использовать ключевое слово `let` для определения имени прямо в GHCI. Выполнение `let a = 1` внутри GHCI эквивалентно записи `a = 1` в скрипте и последующей его загрузке.

```haskell
ghci> let lostNumbers = [4,8,15,16,23,42]
ghci> lostNumbers
[4,8,15,16,23,42]
```

Как вы можете видеть, списки заключены в квадратные скобки, а значения в списках разделены запятыми. Если бы мы попробовали использовать список типа `[1,2,'a',3,'b','c',4]`, Haskell пожаловался бы, что символы (которые, кстати, обозначаются как символ между одинарными кавычками) не являются числами. Говоря о символах, строки - это просто списки символов. `"hello"` - это просто синтаксический сахар для `['h','e','l','l','o']`. Поскольку строки представляют собой списки, мы можем использовать для них функции списка, что действительно удобно.

Обычная задача - собрать два списка воедино. Это делается с помощью оператора `++`.

```haskell
ghci> [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci> "hello" ++ " " ++ "world"
"hello world"
ghci> ['w','o'] ++ ['o','t']
"woot"
```

Будьте осторожны при повторном использовании оператора `++` для длинных строк. Когда вы объединяете два списка (даже если вы добавляете одноэлементный список к списку, например: `[1,2,3] ++ [4]`), внутренне Haskell должен просмотреть весь список в левой части `++`. Это не проблема, когда имеешь дело со списками, которые не слишком велики. Но для того, чтобы поместить что-то в конец списка длиной в пятьдесят миллионов записей, потребуется некоторое время. Однако поместить что-либо в начало списка с помощью оператора `:` (также называемого оператором `cons`) можно мгновенно.

```haskell
ghci> 'A':" SMALL CAT"
"A SMALL CAT"
ghci> 5:[1,2,3,4,5]
[5,1,2,3,4,5]
```

Обратите внимание, как `:` принимает число и список чисел или символ и список символов, тогда как `++` принимает два списка. Даже если вы добавляете элемент в конец списка с помощью `++`, вы должны заключить его в квадратные скобки, чтобы он стал списком.

`[1,2,3]` на самом деле является просто синтаксическим сахаром для `1:2:3:[]`. `[]` - это пустой список. Если мы добавим к нему `3`, оно станет `[3]`. Если мы добавим к этому `2`, оно станет `[2,3]` и так далее.

> **Примечание:** `[]`, `[[]]` и `[[],[],[]]` это все разные вещи. Первый - это пустой список, второй - это список, содержащий один пустой список, третий - это список, содержащий три пустых списка.

Если вы хотите получить элемент из списка по индексу, используйте `!!`. Индексы начинаются с 0.

```haskell
ghci> "Steve Buscemi" !! 6
'B'
ghci> [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
```

Но если вы попытаетесь получить шестой элемент из списка, состоящего всего из четырех элементов, вы получите сообщение об ошибке, так что будьте осторожны!

Списки также могут содержать списки. Они также могут содержать списки, которые содержат списки, которые содержат списки ...

```haskell
ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci> [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b !! 2
[1,2,2,3,4] 
```

Списки внутри списка могут быть разной длины, но они не могут быть разных типов. Точно так же, как у вас не может быть списка, содержащего некоторые символы и некоторые цифры, у вас не может быть списка, содержащего некоторые списки символов и некоторые списки чисел.

Списки можно сравнивать, если можно сравнить содержащийся в них материал. При использовании `<`, `<=`, `>` и `>=` для сравнения списков они сравниваются в лексикографическом порядке. Сначала сравниваются головы. Если они равны, то сравниваются вторые элементы и т.д.

```haskell
ghci> [3,2,1] > [2,1,0]
True
ghci> [3,2,1] > [2,10,100]
True
ghci> [3,4,2] > [3,4]
True
ghci> [3,4,2] > [2,4]
True
ghci> [3,4,2] == [3,4,2]
True
```

Что еще вы можете сделать со списками? Вот некоторые основные функции, которые работают со списками.

`head` принимает список и возвращает его заголовок. Заголовок списка - это, по сути, его первый элемент.

```haskell
ghci> head [5,4,3,2,1]
5 
```

`tail` принимает список и возвращает его хвост. Другими словами, это отрубает голову списку.

```haskell
ghci> tail [5,4,3,2,1]
[4,3,2,1] 
```

`last` принимает список и возвращает его последний элемент.

```haskell
ghci> last [5,4,3,2,1]
1 
```

`init` принимает список и возвращает все, кроме его последнего элемента.

```haskell
ghci> init [5,4,3,2,1]
[5,4,3,2] 
```

Если мы думаем о списке как о монстре, то вот что есть что.

![[LYHfGG_9_listmonster.png]]

Но что произойдет, если мы попытаемся получить начало пустого списка?

```haskell
ghci> head []
*** Exception: Prelude.head: empty list
```

О боже! Все это взрывается нам в лицо! Если монстра нет, то у него нет головы. При использовании `head`, `tail`, `last` и `init` будьте осторожны и не используйте их в пустых списках. Эта ошибка не может быть обнаружена во время компиляции, поэтому всегда рекомендуется принимать меры предосторожности, чтобы случайно не попросить Haskell предоставить вам некоторые элементы из пустого списка.

очевидно, что `length` принимает список и возвращает его длину.

```haskell
ghci> length [5,4,3,2,1]
5
```

`null` проверяет, пуст ли список. Если это так, то он возвращает `True`, в противном случае он возвращает `False`. Используйте эту функцию вместо `xs == []` (если у вас есть список с именем `xs`)

```haskell
ghci> null [1,2,3]
False
ghci> null []
True
```

`reverse` переворачивает список.

```haskell
ghci> reverse [5,4,3,2,1]
[1,2,3,4,5]
```

`take` принимает номер и список. Он извлекает некоторое количество элементов из начала списка. Посмотри.

```haskell
ghci> take 3 [5,4,3,2,1]
[5,4,3]
ghci> take 1 [3,9,3]
[3]
ghci> take 5 [1,2]
[1,2]
ghci> take 0 [6,6,6]
[]
```

Посмотрите, как если мы попытаемся взять больше элементов, чем есть в списке, это просто вернет список. Если мы попытаемся взять 0 элементов, то получим пустой список.

`drop` работает аналогичным образом, только он уменьшает количество элементов из начала списка.

```haskell
ghci> drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci> drop 0 [1,2,3,4]
[1,2,3,4]
ghci> drop 100 [1,2,3,4]
[] 
```

`maximum` принимает список элементов, которые можно расположить в определенном порядке, и возвращает самый большой элемент.

`minimum` возвращает наименьшее значение.

```haskell
ghci> minimum [8,4,2,1,5,6]
1
ghci> maximum [1,9,2,3,4]
9 
```

`sum` принимает список чисел и возвращает их сумму.

`product` принимает список чисел и возвращает их произведение.

```haskell
ghci> sum [5,2,1,6,3,2,5,7]
31
ghci> product [6,2,1,2]
24
ghci> product [1,2,5,6,7,9,2,0]
0 
```

`elem` берет вещь и список вещей и сообщает нам, является ли эта вещь элементом списка. Обычно она вызывается как инфиксная функция, потому что так ее легче читать.

```haskell
ghci> 4 `elem` [3,4,5,6]
True
ghci> 10 `elem` [3,4,5,6]
False
```

Это было несколько основных функций, которые работают со списками. Мы рассмотрим дополнительные функции списка [позже](http://learnyouahaskell.com/modules#data-list)

## Техасские диапазоны

![[LYHfGG_10_cowboy.png]]

Что, если нам нужен список всех чисел от 1 до 20? Конечно, мы могли бы просто напечатать их все, но, очевидно, это не решение для джентльменов, которые требуют совершенства от своих языков программирования. Вместо этого мы будем использовать диапазоны. Диапазоны - это способ создания списков, представляющих собой арифметические последовательности элементов, которые можно перечислять. Числа можно перечислять. Один, два, три, четыре и так далее. Символы также могут быть пронумерованы. Алфавит - это перечисление символов от `A` до `Z`^[Стандарт вышел 10 лет назад и он сохраняет обратную совместимость. Поэтому, чтобы использовать unicode, нужно провести небольшие манипуляции. Об этом можно поискать в интернете. "ghci how add utf 8"]. Имена не могут быть пронумерованы. Что следует за словом "John"? Я не знаю.

Чтобы составить список, содержащий все натуральные числа от 1 до 20, вы просто пишете `[1..20]`. Это эквивалентно написанию `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`, и нет никакой разницы между написанием одного или другого, за исключением того, что записывать длинные последовательности перечисления вручную глупо.

```haskell
ghci> [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci> ['K'..'Z']
"KLMNOPQRSTUVWXYZ" 
```

Диапазоны хороши тем, что вы также можете указать шаг. Что, если нам нужны все четные числа от 1 до 20? Или каждое третье число от 1 до 20?

```haskell
ghci> [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci> [3,6..20]
[3,6,9,12,15,18] 
```

Это просто вопрос разделения первых двух элементов запятой, а затем указания верхнего предела. Несмотря на то, что диапазоны со ступенями довольно умны, они не так умны, как некоторые люди ожидают от них. Вы не можете выполнить `[1,2,4,8,16..100]` и ожидать, что получите все степени 2. Во-первых, потому, что вы можете указать только один шаг. А во-вторых, потому что некоторые последовательности, которые не являются арифметическими, неоднозначны, если заданы только несколькими их первыми членами.

Чтобы составить список со всеми числами от 20 до 1, вы не можете просто выполнить `[20..1]`, вы должны выполнить `[20,19..1]`.

Будьте осторожны при использовании чисел с плавающей запятой в диапазонах! Поскольку они не являются полностью точными (по определению), их использование в диапазонах может привести к довольно странным результатам.

```haskell
ghci> [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
```

Мой совет - не использовать их в диапазонах списков.

Вы также можете использовать диапазоны для создания бесконечных списков, просто не указывая верхний предел. Позже мы более подробно остановимся на бесконечных списках. А пока давайте рассмотрим, как бы вы получили первые 24 числа, кратные 13. Конечно, вы могли бы сделать `[13,26..24*13]`. Но есть способ получше: `возьми 24 [13,26..]`. Поскольку Haskell ленив, он не будет пытаться оценить бесконечный список немедленно, потому что он никогда не завершится. Это подождет, чтобы увидеть, что вы хотите получить из этих бесконечных списков. И вот он видит, что вам нужны только первые 24 элемента, и с радостью соглашается.

Несколько функций, которые создают бесконечные списки:

`cycle` берет список и преобразует его в бесконечный список. Если вы просто попытаетесь отобразить результат, он будет продолжаться вечно, так что вам придется где-то его отрезать.

```haskell
ghci> take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci> take 12 (cycle "LOL ")
"LOL LOL LOL " 
```

`repeat` принимает элемент и создает бесконечный список только этого элемента. Это все равно что перебирать список, содержащий только один элемент.

```haskell
ghci> take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
```

Хотя проще просто использовать функцию `replicate`, если вам нужно некоторое количество одного и того же элемента в списке. `replicate 3 10` возвращает `[10,10,10]`.

## Я - списковое включение (англ. _list comprehension_)

Списковое включение^[Альтернативное название, более понятное программистам "генераторы списков". Но использую по [вики](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5#:~:text=%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%20%D0%B8%D0%BB%D0%B8%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5%20%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5,%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9%20%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2.)) ]

![[LYHfGG_11_kermit.png]]

Если вы когда-либо проходили курс математики, вы, вероятно, сталкивались с _множествами с заданными характеристическими свойствами_^[В оригинале был термин "set comprehensions". Ссылка откуда взял: [What is Russian translation for "set comprehension"](https://russian.stackexchange.com/questions/1530/what-is-russian-translation-for-set-comprehension). И я посчитал, что второй ответ более подходящий]. Обычно они используются для построения более специфичных наборов из общих наборов. Базовое списковое включение для набора, содержащего первые десять четных натуральных чисел, составляет^[Я не знаю какая запись более правильная для русской традиции записи. Поэтому оставил как в оригинале] $$S = \{2\ \cdot\ x\ |\ x \in \mathbb{N},\ x \leqslant 10\}$$. Часть перед вертикальной чертой называется выходной функцией, `x` - это переменная, `N` - это входной набор, а `x <= 10` - это предикат^[Предикат - если просто, то это условие]. Это означает, что множество содержит удвоения всех натуральных чисел, которые удовлетворяют предикату.

Если бы мы хотели написать это на Haskell, мы могли бы сделать что-то вроде `take 10 [2,4..]`. Но что, если бы мы хотели получить не удвоения первых 10 натуральных чисел, а какую-то более сложную функцию, примененную к ним? Для этого мы могли бы использовать списковое включение. Списковое включение очень похоже на понимание набора. Пока мы будем придерживаться получения первых 10 четных чисел. Списковое включение, которое мы могли бы использовать, - это `[x * 2 | x <- [1..10]]`. `x` берется из `[1..10]`, и для каждого элемента в `[1..10]` (который мы привязали к `x`) мы получаем этот элемент, только удвоенный. Вот списковое включение в действии.

```haskell
ghci> [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
```

Как вы можете видеть, мы получаем желаемые результаты. Теперь давайте добавим условие (или предикат) к этому списковому включению. Предикаты идут после связующих частей и отделяются от них запятой. Допустим, нам нужны только те элементы, которые в удвоенном виде больше или равны 12.

```haskell
ghci> [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
```

Круто, это работает. Как насчет того, если бы мы хотели получить все числа от 50 до 100, остаток от которых при делении на число 7 равен 3? Легко.

```haskell
ghci> [ x | x <- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94] 
```

Успех! Обратите внимание, что отсеивание списков по предикатам также называется **фильтрацией** (англ. filtering). Мы взяли список чисел и отфильтровали их по предикату. Теперь перейдем к другому примеру. Допустим, нам нужно списковое включение, которое заменяет каждое нечетное число, большее 10, на `"BANG!"`, а каждое нечетное число, меньшее 10, на `"BOOM!"`. Если число не нечетное, мы исключаем его из нашего списка. Для удобства мы поместим это списковое включение внутрь функции, чтобы мы могли легко использовать его повторно.

```haskell
boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] 
```

Последняя часть спискового включения - это предикат. Функция `odd` возвращает `True` для нечетного числа и `False` для четного. Элемент включается в список только в том случае, если все предикаты оцениваются как `True`.

```haskell
ghci> boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"] 
```

Мы можем включить несколько предикатов. Если бы нам нужны были все числа от 10 до 20, которые не равны 13, 15 или 19, мы бы сделали:

ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]

Мы не только можем иметь несколько предикатов в списковом включении (элемент должен удовлетворять всем предикатам, которые будут включены в результирующий список), мы также можем извлекать данные из нескольких списков. При рисовании из нескольких списковых включений создает все комбинации заданных списков, а затем объединяет их с помощью функции вывода, которую мы предоставляем. Список, созданный с помощью спискового включения, который основывается на двух списках длиной 4, будет иметь длину 16, при условии, что мы их не фильтруем. Если у нас есть два списка, `[2,5,10]` и `[8,10,11]`, и мы хотим получить произведения всех возможных комбинаций чисел в этих списках, вот что мы бы сделали.

```haskell
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110] 
```

Как и ожидалось, длина нового списка равна 9. Что, если бы нам понадобились все возможные произведения, которых более 50?

```haskell
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
[55,80,100,110] 
```

Как насчет спискового включения, которое сочетает в себе список прилагательных и список существительных ... для эпического веселья.

```haskell
ghci> let nouns = ["hobo","frog","pope"]
ghci> let adjectives = ["lazy","grouchy","scheming"]
ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"] 
```

Я знаю! Давайте напишем нашу собственную версию `длины`! Мы будем называть это `length'`.

```haskell
length' xs = sum [1 | _ <- xs] 
```

`_` означает, что нам все равно, что мы будем извлекать из списка, поэтому вместо того, чтобы писать имя переменной, которое мы никогда не будем использовать, мы просто пишем `_`. Эта функция заменяет каждый элемент списка на `1`, а затем суммирует его. Это означает, что результирующая сумма будет равна длине нашего списка.

Просто дружеское напоминание: поскольку строки являются списками, мы можем использовать списковое включение для обработки и создания строк. Вот функция, которая принимает строку и удаляет из нее все, кроме прописных букв.

```haskell
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
```

Проверяю это на практике:

```haskell
ghci> removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci> removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS" 
```

Предикат здесь выполняет всю работу. В нем говорится, что символ будет включен в новый список, только если он является элементом списка `['A'..'Z']`. Вложенное списковое включение также возможно, если вы работаете со списками, которые содержат списки. Список содержит несколько списков чисел. Давайте удалим все нечетные числа, не выравнивая список.

```haskell
ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci> [ [ x | x <- xs, even x ] | xs <- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
```

Вы можете написать списковое включение в нескольких строках. Поэтому, если вы не используете GHCI, лучше разделить более длинные списковые включения на несколько строк, особенно если они вложены.

## Кортежи

![[LYHfGG_13_tuple.png]]

В некотором смысле кортежи подобны спискам — это способ хранения нескольких значений в одном значении. Однако есть несколько фундаментальных отличий. Список чисел - это список чисел. Это его тип, и не имеет значения, содержит ли он только одно число или бесконечное количество чисел. Однако кортежи используются, когда вы точно знаете, сколько значений вы хотите объединить, а их тип зависит от того, сколько в нем компонентов и типов компонентов. Они обозначаются круглыми скобками, а их компоненты разделяются запятыми.

Еще одно ключевое отличие заключается в том, что они не обязательно должны быть однородными. В отличие от списка, кортеж может содержать комбинацию нескольких типов.

Подумайте о том, как бы мы представили двумерный вектор в Haskell. Одним из способов было бы использовать список. Это вроде как сработало бы. Итак, что, если бы мы захотели поместить пару векторов в список для представления точек фигуры на двумерной плоскости? Мы могли бы сделать что-то вроде `[[1,2],[8,11],[4,5]]`. Проблема с этим методом заключается в том, что мы также могли бы делать такие вещи, как `[[1,2],[8,11,5],[4,5]]`, с чем у Haskell нет проблем, поскольку это все еще список списков с числами, но это как бы не имеет смысла. Но кортеж второго размера (также называемый парой) имеет свой собственный тип, что означает, что в списке не может быть пары пар, а затем тройки (кортеж третьего размера), поэтому давайте используем кортеж вместо списка. Вместо того чтобы заключать векторы в квадратные скобки, мы используем круглые скобки: `[(1,2),(8,11),(4,5)]`. Что, если бы мы попытались создать форму, подобную `[(1,2),(8,11,5),(4,5)]`? Ну, мы бы получили эту ошибку:

```haskell
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
```

Это говорит нам о том, что мы пытались использовать пару и тройку в одном списке, чего не должно было произойти. Вы также не смогли бы составить список типа `[(1,2),("Один",2)]`, потому что первый элемент списка - это пара чисел, а второй элемент - это пара, состоящая из строки и числа. Кортежи также могут использоваться для представления самых разнообразных данных. Например, если бы мы хотели представить чье-то имя и возраст в Haskell, мы могли бы использовать тройку: `("Christopher", "Walken", 55)`. Как видно из этого примера, кортежи также могут содержать списки.

Используйте кортежи, когда вы заранее знаете, сколько компонентов должно быть в том или ином фрагменте данных. Кортежи намного более жесткие, потому что каждый кортеж разного размера имеет свой собственный тип, поэтому вы не можете написать общую функцию для добавления элемента к кортежу — вам пришлось бы написать функцию для добавления к паре, одну функцию для добавления к тройке, одну функцию для добавления к 4-му кортежу и т.д.

Хотя существуют одноэлементные списки, такого понятия, как одноэлементный кортеж, не существует. На самом деле это не имеет особого смысла, когда ты думаешь об этом. Одноэлементный кортеж был бы просто значением, которое он содержит, и как таковой не принес бы нам никакой пользы.

Как и списки, кортежи можно сравнивать друг с другом, если можно сравнить их компоненты. Только вы не можете сравнить два кортежа разных размеров, в то время как вы можете сравнить два списка разных размеров. Две полезные функции, которые работают с парами:

`fst` принимает пару и возвращает ее первый компонент.

```haskell
ghci> fst (8,11)
8
ghci> fst ("Wow", False)
"Wow"
```

`snd` принимает пару и возвращает ее второй компонент. Сюрприз!

```haskell
ghci> snd (8,11)
11
ghci> snd ("Wow", False)
False
```

> **Примечание** эти функции работают только с парами. Они не будут работать с тройками, 4-кортежами, 5-кортежами и т.д. Чуть позже мы рассмотрим извлечение данных из кортежей различными способами.

Классная функция, которая выдает список пар: `zip`. Он берет два списка, а затем объединяет их в один список, объединяя совпадающие элементы в пары. Это действительно простая функция, но у нее множество применений. Это особенно полезно, когда вы хотите каким-то образом объединить два списка или одновременно просматривать два списка. Вот демонстрация.

```haskell
ghci> zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
```

Он объединяет элементы в пары и создает новый список. Первый элемент сочетается с первым, второй - со вторым и т.д. Обратите внимание, что, поскольку пары могут содержать разные типы, `zip` может взять два списка, содержащих разные типы, и объединить их. Что произойдет, если длины списков не совпадут?

```haskell
ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
```

Более длинный список просто обрезается, чтобы соответствовать длине более короткого. Поскольку Haskell ленив, мы можем объединять конечные списки с бесконечными списками:

```haskell
ghci> zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
```

![[LYHfGG_14_pythag.png]]

Вот задача, которая сочетает в себе понимание кортежей и списков: какой прямоугольный треугольник, который имеет целые числа для всех сторон и все стороны которого равны или меньше 10, имеет периметр 24? Сначала давайте попробуем сгенерировать все треугольники со сторонами, равными или меньшими 10:

```haskell
ghci> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ] 
```

Мы просто рисуем из трех списков, и наша функция вывода объединяет их в тройку. Если вы оцените это, введя `triangles` в GHCI, вы получите список всех возможных треугольников со сторонами меньше или равными 10. Далее мы добавим условие, что все они должны быть прямоугольными треугольниками. Мы также модифицируем эту функцию, принимая во внимание, что сторона `b` не больше гипотенузы и что сторона `a` не больше стороны `b`.

```haskell
ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2] 
```

Мы почти закончили. Теперь мы просто модифицируем функцию, сказав, что нам нужны те, у которых периметр равен 24.

```haskell
ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci> rightTriangles'
[(6,8,10)]
```

И вот наш ответ! Это распространенный шаблон в функциональном программировании. Вы берете начальный набор решений, а затем применяете преобразования к этим решениям и фильтруете их до тех пор, пока не получите правильные.

# Типы и классы типов

## Верьте типу

![[LYHfGG_15_cow.png]]

Ранее мы упоминали, что в Haskell есть система статических типов. Тип каждого выражения известен во время компиляции, что приводит к созданию более безопасного кода. Если вы напишете программу, в которой попытаетесь разделить логический тип на некоторое число, она даже не будет компилироваться. Это хорошо, потому что лучше отлавливать такие ошибки во время компиляции, а не вызывать сбой вашей программы. Все в Haskell имеет тип, поэтому компилятор может довольно много рассуждать о вашей программе перед ее компиляцией.

В отличие от Java или Pascal, в Haskell есть вывод типа. Если мы пишем число, нам не нужно говорить Haskell, что это число. Он может _сделать вывод_ сам по себе, поэтому нам не нужно явно выписывать типы наших функций и выражений, чтобы что-то сделать. Мы рассмотрели некоторые основы Haskell, лишь очень поверхностно взглянув на типы. Однако понимание системы типов является очень важной частью изучения Haskell.

Тип - это своего рода метка, которая есть у каждого выражения. Это говорит нам, к какой категории вещей подходит это выражение. Выражение `True` - это логическое значение, `"hello"` - это строка и т.д.

Теперь мы будем использовать GHCI для изучения типов некоторых выражений. Мы сделаем это с помощью команды `:t`, за которой следует любое допустимое выражение, сообщающее нам его тип. Давайте раскрутим это дело.

```haskell
ghci> :t 'a'
'a' :: Char
ghci> :t True
True :: Bool
ghci> :t "HELLO!"
"HELLO!" :: [Char]
ghci> :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci> :t 4 == 5
4 == 5 :: Bool
```

![[LYHfGG_16_bomb.png]]

Здесь мы видим, что выполнение `:t` для выражения выводит выражение, за которым следует `::`, и его тип. `::` читается как "имеет тип". Явные типы всегда обозначаются первой буквой с большой буквы. `'a'`, как могло бы показаться, имеет тип `Char`. Нетрудно сделать вывод, что это означает _символ_ (англ. _character_). `True` относится к типу `Bool`. В этом есть смысл. Но что это такое? Анализ типа `"ПРИВЕТ!"` выдает `[Char]`. Квадратные скобки обозначают список. Итак, мы читаем это как _список символов_ (англ. _a list of characters_). В отличие от списков, длина каждого кортежа имеет свой собственный тип. Таким образом, выражение `(True, 'a')` имеет тип `(Bool, Char)`, тогда как такое выражение, как `('a','b','c')`, имело бы тип `(Char, Char, Char)`. `4 == 5` всегда возвращает `False`, поэтому его тип - `Bool`.

Функции также имеют типы. При написании наших собственных функций мы можем предоставить им явное объявление типа. Обычно это считается хорошей практикой, за исключением случаев написания очень коротких функций. С этого момента мы будем предоставлять все функции, для которых мы делаем объявления типов. Помните представление списка, которое мы сделали ранее, которое фильтрует строку так, чтобы оставались только заглавные буквы? Вот как это выглядит с объявлением типа.

```haskell
removeNonUppercase :: [Char] -> [Char]
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']] 
```

`removeNonUppercase` имеет тип `[Char] -> [Char]`, что означает, что он преобразуется из строки в строку. Это потому, что он принимает одну строку в качестве параметра и возвращает другую в результате. Тип `[Char]` является синонимом `String`, поэтому будет понятнее, если мы напишем `removeNonUppercase :: String -> String`. Нам не нужно было давать этой функции объявление типа, потому что компилятор может сам сделать вывод, что это функция из строки в строку, но мы все равно это сделали. Но как нам записать тип функции, которая принимает несколько параметров? Вот простая функция, которая принимает три целых числа и складывает их вместе:

```haskell
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
```

Параметры разделяются символом `->`, и нет особого различия между параметрами и возвращаемым типом. Возвращаемый тип - это последний элемент в объявлении, а параметры - первые три. Позже мы увидим, почему все они просто разделены `->` вместо того, чтобы проводить какое-то более явное различие между возвращаемыми типами и параметрами, такими как `Int, Int, Int -> Int` или что-то в этом роде.

Если вы хотите предоставить своей функции объявление типа, но не уверены в том, каким оно должно быть, вы всегда можете просто написать функцию без него, а затем проверить ее с помощью `:t`. Функции тоже являются выражениями, поэтому `:t` работает с ними без проблем.

Вот обзор некоторых распространенных типов.

`Int` означает целое число. Он используется для целых чисел. `7` может быть `Int`, но `7.2` не может. `Int` ограничен, что означает, что он имеет минимальное и максимальное значения. Обычно на 32-разрядных машинах максимально возможное значение `Int` равно 2147483647, а минимальное -2147483648.

`Integer` означает, э-э... тоже целое число. Главное отличие заключается в том, что он не ограничен, поэтому его можно использовать для представления действительно очень больших чисел. Я имею в виду, по-настоящему большой. `Int`, однако, более эффективен.

```haskell
factorial :: Integer -> Integer
factorial n = product [1..n]
```

```haskell
ghci> factorial 50
30414093201713378043612608166064768844377641568960512000000000000
```

`Float` - это реальная плавающая точка с одинарной точностью.

```haskell
circumference :: Float -> Float
circumference r = 2 * pi * r
```

```haskell
ghci> circumference 4.0
25.132742
```

`Double` - это настоящая плавающая точка с удвоенной точностью!

```haskell
circumference' :: Double -> Double
circumference' r = 2 * pi * r
```

```haskell
ghci> circumference' 4.0
25.132741228718345
```

`Bool` - это логический тип. Он может иметь только два значения: `True` и `False`.

`Char` представляет символ. Он обозначается одинарными кавычками. Список символов представляет собой строку.

Кортежи - это типы, которые зависят от длины кортежей, а также от типов их компонентов, поэтому теоретически существует бесконечное количество типов кортежей, которых слишком много, чтобы рассматривать их в этом руководстве. Обратите внимание, что пустой кортеж `()` также является типом, который может иметь только одно значение: `()`

## Переменные типа

Как вы думаете, что это за тип функции `head`? Поскольку `head` принимает список любого типа и возвращает первый элемент, так что же это может быть? Давайте проверим!

```haskell
ghci> :t head
head :: [a] -> a
```

![[LYHfGG_17_box.png]]

Хммм! Что это за буква `a`? Является ли это типом? Помните, что ранее мы указывали, что типы пишутся с большой буквы, поэтому это не может быть точно типом. Поскольку это не прописная буква, на самом деле это **переменная типа** (англ. **type variable**). Это означает, что `a` может быть любого типа. Это очень похоже на дженерики в других языках, только в Haskell это намного мощнее, потому что позволяет нам легко писать очень общие функции, если они не используют какое-либо специфическое поведение используемых в них типов. Функции, имеющие переменные типа, называются **полиморфными функциями** (англ. **polymorphic functions**). В объявлении типа `head` указано, что он принимает список любого типа и возвращает один элемент этого типа.

Хотя имена переменных типа могут быть длиннее одного символа, мы обычно присваиваем им имена a, b, c, d ...

Помнишь `fst`? Он возвращает первый компонент пары. Давайте рассмотрим его тип.

```haskell
ghci> :t fst
fst :: (a, b) -> a
```

Мы видим, что `fst` принимает кортеж, который содержит два типа, и возвращает элемент того же типа, что и первый компонент пары. Вот почему мы можем использовать `fst` для пары, которая содержит любые два типа. Обратите внимание, что только потому, что `a` и `b` являются переменными разного типа, они не обязательно должны быть разных типов. В нем просто указано, что тип первого компонента и тип возвращаемого значения совпадают.

## Классы типов 101

![[LYHfGG_18_classes.png]]

Класс типов - это своего рода интерфейс, который определяет определенное поведение. Если тип является частью класса типов, это означает, что он поддерживает и реализует поведение, описываемое классом типов. Многие люди, пришедшие из ООП, путаются в классах типов, потому что думают, что они похожи на классы в объектно-ориентированных языках. Ну, это не так. Вы можете думать о них как о интерфейсах Java, только лучше.

Какова сигнатура типа функции `==`?

```haskell
ghci> :t (==)
(==) :: (Eq a) => a -> a -> Bool
```

> **Примечание**: оператор равенства `==` является функцией. Так же как и `+`, `*`, `-`, `/` и почти все операторы. Если функция состоит только из специальных символов, по умолчанию она считается инфиксной функцией. Если мы хотим проверить её тип, передать его другой функции или вызвать его как префиксную функцию, мы должны заключить её в круглые скобки.

Интересно. Здесь мы видим новую вещь - символ `=>`. Все, что находится перед символом `=>`, называется **ограничением класса** (англ. **class constraint**). Мы можем прочитать предыдущее объявление типа следующим образом: функция равенства принимает любые два значения одного и того же типа и возвращает `Bool`. Тип этих двух значений должен быть членом класса `Eq` (это было ограничение класса).

Класс типов `Eq` предоставляет интерфейс для проверки на равенство. Любой тип, в котором имеет смысл проверять равенство между двумя значениями этого типа, должен быть членом класса `Eq`. Все стандартные типы Haskell, за исключением ввода-вывода (тип для работы с вводом и выводом) и функций, являются частью класса типов `Eq`.

Функция `elem` имеет тип `(Eq a) => a -> [a] -> Bool`, потому что она использует `==` над списком, чтобы проверить, есть ли в нем какое-то значение, которое мы ищем.

Некоторые основные классы типов:

`Eq` используется для типов, которые поддерживают проверку на равенство. Функциями, которые реализуют его члены, являются `==` и `/=`. Таким образом, если существует ограничение класса `Eq` для переменной типа в функции, она использует `==` или `/=` где-то внутри своего определения. Все типы, которые мы упоминали ранее, за исключением функций, являются частью `Eq`, поэтому их можно проверить на равенство.

```haskell
ghci> 5 == 5
True
ghci> 5 /= 5
False
ghci> 'a' == 'a'
True
ghci> "Ho Ho" == "Ho Ho"
True
ghci> 3.432 == 3.432
True
```

`Ord` предназначен для типов, которые имеют порядок.

```haskell
ghci> :t (>)
(>) :: (Ord a) => a -> a -> Bool
```

Все типы, которые мы рассмотрели до сих пор, за исключением функций, являются частью `Ord`. `Ord` охватывает все стандартные функции сравнения, такие как `>`, `<`, `>=` и `<=`. Функция `compare` принимает два элемента `Ord` одного и того же типа и возвращает `ordering`. `Ordering` - это тип, который может быть `GT`, `LT` или `EQ`, что означает _больше чем_ , _меньше чем_ и _эквивалентно_ соответственно. (англ. _greater than_, _lesser than_, _equal_ соответственно)

Чтобы стать членом `Ord`, тип должен сначала иметь членство в престижном и эксклюзивном клубе `Eq`.

```haskell
ghci> "Abrakadabra" < "Zebra"
True
ghci> "Abrakadabra" `compare` "Zebra"
LT
ghci> 5 >= 2
True
ghci> 5 `compare` 3
GT
```

Члены `Show` могут быть представлены в виде строк. Все рассмотренные до сих пор типы, за исключением функций, являются частью `Показать`. Наиболее используемой функцией, которая имеет дело с классом типов `Show`, является `show`. Она принимает значение, тип которого является членом `Show`, и представляет его нам в виде строки.

```haskell
ghci> show 3
"3"
ghci> show 5.334
"5.334"
ghci> show True
"True"
```

`Read` - это своего рода класс, противоположный типу `Show`. Функция `read` принимает строку и возвращает тип, который является членом `Read`.

```haskell
ghci> read "True" || False
True
ghci> read "8.2" + 3.8
12.0
ghci> read "5" - 2
3
ghci> read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
```

Пока все идет хорошо. Опять же, все рассмотренные до сих пор типы находятся в этом классе типов. Но что произойдет, если мы попытаемся просто `прочитать "4"`?

```haskell
ghci> read "4"
<interactive>:1:0:
    Ambiguous type variable `a' in the constraint:
      `Read a' arising from a use of `read' at <interactive>:1:0-7
    Probable fix: add a type signature that fixes these type variable(s)
```

Что GHCI говорит нам здесь, так это то, что он не знает, чего мы хотим взамен. Обратите внимание, что при предыдущем использовании `read` мы впоследствии что-то делали с результатом. Таким образом, GHCI мог бы сделать вывод, какого рода результат мы хотели получить от нашего `read`. Если мы использовали его как логическое значение, он знал, что должен вернуть `Bool`. Но теперь он знает, что нам нужен какой-то тип, который является частью класса `Read`, он просто не знает, какой именно. Давайте взглянем на сигнатуру типа `read`.

```haskell
ghci> :t read
read :: (Read a) => String -> a
```

Видишь? Он возвращает тип, который является частью `Read`, но если мы не попытаемся использовать его каким-либо образом позже, у него не будет возможности узнать, какой тип. Вот почему мы можем использовать явные **аннотации типа** (англ. _type annotations_). Аннотации типов - это способ явно указать, каким должен быть тип выражения. Мы делаем это, добавляя `::` в конце выражения, а затем указывая тип. Наблюдай:

```haskell
ghci> read "5" :: Int
5
ghci> read "5" :: Float
5.0
ghci> (read "5" :: Float) * 4
20.0
ghci> read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci> read "(3, 'a')" :: (Int, Char)
(3, 'a')
```

Большинство выражений таковы, что компилятор может сам определить, каков их тип. Но иногда компилятор не знает, возвращать ли значение типа `Int` или `Float` для выражения типа `read "5"`. Чтобы увидеть, что это за тип, Haskell пришлось бы на самом деле оценить `read "5"`. Но поскольку Haskell является статически типизированным языком, он должен знать все типы до того, как код будет скомпилирован (или, в случае GHCI, оценен). Итак, мы должны сказать Хаскелю: "Эй, это выражение должно иметь этот тип, на случай, если вы не знаете!".

Члены `Enum` представляют собой последовательно упорядоченные типы — их можно перечислять. Главное преимущество класса типов `Enum` заключается в том, что мы можем использовать его типы в диапазонах списков. У них также есть определенные преемники (англ. _successors_) и предшественники (англ. _predecesors_), которые вы можете получить с помощью функций `succ` и `pred`. Типы в этом классе: `()`, `Bool`, `Char`, `Ordering`, `Int`, `Integer`, `Float` и `Double`.

```haskell
ghci> ['a'..'e']
"abcde"
ghci> [LT .. GT]
[LT,EQ,GT]
ghci> [3 .. 5]
[3,4,5]
ghci> succ 'B'
'C'
```

Элементы типа `Bounded` имеют верхнюю и нижнюю границы.

```haskell
ghci> minBound :: Int
-2147483648
ghci> maxBound :: Char
'\1114111'
ghci> maxBound :: Bool
True
ghci> minBound :: Bool
False
```

`minBound` и `maxBound` интересны тем, что они имеют тип `(Bounded a) => a`. В некотором смысле они являются полиморфными константами.

Все кортежи также являются частью `Bounded`, если компоненты также находятся в нем.

```haskell
ghci> maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
```

`Num` - это числовой класс типов. Его члены обладают свойством вести себя подобно числам. Давайте рассмотрим тип числа.

```haskell
ghci> :t 20
20 :: (Num t) => t
```

Похоже, что целые числа также являются полиморфными константами. Они могут действовать как любой тип, являющийся членом класса типов `Num`.

```haskell
ghci> 20 :: Int
20
ghci> 20 :: Integer
20
ghci> 20 :: Float
20.0
ghci> 20 :: Double
20.0
```

Это типы, которые находятся в классе типов `Num`. Если мы рассмотрим тип `*`, то увидим, что он принимает все числа.

```haskell
ghci> :t (*)
(*) :: (Num a) => a -> a -> a
```

Он принимает два числа одного и того же типа и возвращает число этого типа. Вот почему `(5 :: Int) * (6 :: Integer)` приведет к ошибке типа, тогда как `5 * (6 :: Integer)` будет работать просто отлично и выдаст `Integer`, потому что `5` может действовать как `Integer` или `Int`.

Чтобы присоединиться к `Num`, тип уже должен быть дружен с `Show` и `Eq`.

`Integral` также является числовым классом типов. `Num` включает в себя все числа, включая действительные числа и целые числа, `Integral` включает в себя только целые числа. В этом классе типов находятся `Int` и `Integer`.

`Floating` включает в себя только числа с плавающей запятой, поэтому `Float` и `Double`.

Очень полезная функция для работы с числами - `fromIntegral`. Он имеет объявление типа `fromIntegral :: (Num b, Integral a) => a -> b`. Из его сигнатуры типа мы видим, что он принимает целое число и превращает его в более общее число. Это полезно, когда вы хотите, чтобы целочисленные типы и типы с плавающей запятой хорошо работали вместе. Например, функция `length` имеет объявление типа `length :: [a] -> Int` вместо того, чтобы иметь более общий тип `(Num b) => length :: [a] -> b`. Я думаю, что это существует по историческим причинам или что-то в этом роде, хотя, на мой взгляд, это довольно глупо. В любом случае, если мы попытаемся получить длину списка, а затем добавить его к `3.2`, мы получим ошибку, потому что мы пытались сложить вместе `Int` и число с плавающей запятой. Итак, чтобы обойти это, мы делаем `fromIntegral :: (Num b, Integral a) => a -> b`., и все получается.

Обратите внимание, что `fromIntegral` имеет несколько ограничений класса в своей сигнатуре типа. Это полностью допустимо, и, как вы можете видеть, ограничения класса разделены запятыми внутри круглых скобок.

# Сноски переводчика

