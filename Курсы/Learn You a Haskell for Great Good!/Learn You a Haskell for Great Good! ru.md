# Введение

## Об этом учебном пособии

Добро пожаловать в **Выучи Haskell для Великого Блага**! Если вы читаете это, то возможно вы хотите выучить Haskell. Что ж, вы обратились по адресу, но давайте немного поговорим об этом уроке.

Я решил написать это, потому что хотел укрепить свои собственные знания о Haskell и потому что думал, что смогу помочь людям, новичкам в Haskell, изучить его с моей точки зрения. В Интернете есть довольно много учебных пособий по Haskell. Когда я начинал изучать Haskell, я учился на нескольких ресурсах. Я научился, прочитав несколько разных учебников и статей, потому что каждый объяснял что-то по другому, чем другой. Просмотрев несколько ресурсов, я смог собрать воедино кусочки, и все просто встало на свои места. Итак, это попытка добавить еще один полезный ресурс для изучения Haskell, чтобы у вас было больше шансов найти тот, который вам понравится.

![[LYHfGG_1_bird.png]]

Это руководство предназначено для людей, которые имеют опыт работы с императивными языками программирования (C, C ++, Java, Python ...), но никогда раньше не программировали на функциональном языке (Haskell, ML, OCaml вЂ/). Хотя я готов поспорить, что даже если у вас нет сколько-нибудь значительного опыта в программировании, такой умный человек, как вы, сможет последовать примеру и изучить Haskell.

Канал #haskell в сети freenode - отличное место, чтобы задать вопросы, если вы чувствуете себя застрявшим. Люди там чрезвычайно милы, терпеливы и с пониманием относятся к новичкам.

Мне не удалось выучить Haskell примерно 2 раза, прежде чем я, наконец, понял его, потому что все это казалось мне слишком странным, и я этого не понял. Но затем, как только это просто "щелкнуло" и после преодоления этого первоначального препятствия, все прошло довольно гладко. Наверное, я пытаюсь сказать следующее: Haskell великолепен, и если вы интересуетесь программированием, вам действительно следует его изучить, даже если поначалу это кажется странным. Изучение Haskell во многом похоже на обучение программированию в первый раз — это весело! Это заставляет вас думать по-другому, что подводит нас к следующему разделу ...

## Итак, что такое Haskell?

![[LYHfGG_2_fx.png]]

Haskell - это **чисто функциональный язык программирования**. В императивных языках вы добиваетесь цели, задавая компьютеру последовательность задач, а затем он их выполняет. Во время их выполнения он может изменять состояние. Например, вы устанавливаете переменной `a` значение 5, а затем делаете что-то еще, а затем устанавливаете ее значение на что-то другое. У вас есть структуры потока управления для выполнения какого-либо действия несколько раз. В чисто функциональном программировании вы не указываете компьютеру, что делать как таковое, а скорее сообщаете ему, чем этот материал _является_. Факториал числа - это произведение всех чисел от 1 до этого числа, сумма списка чисел - это первое число плюс сумма всех остальных чисел и так далее. Вы выражаете это в форме функций. Вы также не можете присвоить переменной значение чего-то, а затем присвоить ей значение чего-то другого позже. Если вы скажете, что `a` равно 5, вы не сможете позже сказать, что это что-то другое, потому что вы только что сказали, что это 5. Ты что, какой-то лжец? Таким образом, в чисто функциональных языках функция не имеет побочных эффектов. Единственное, что может сделать функция, - это вычислить что-то и вернуть это в результате. На первый взгляд это кажется своего рода ограничением, но на самом деле это имеет некоторые очень приятные последствия: если функция вызывается дважды с одними и теми же параметрами, она гарантированно возвращает один и тот же результат. Это называется прозрачностью ссылок, и она не только позволяет компилятору рассуждать о поведении программы, но и позволяет вам легко вывести (и даже доказать), что функция верна, а затем создавать более сложные функции путем склеивания простых функций вместе.

![[LYHfGG_3_lazy.png]]

Haskell **ленив**. Это означает, что, если специально не указано иное, Haskell не будет выполнять функции и вычислять что-либо, пока его действительно не заставят показать вам результат. Это хорошо сочетается со ссылочной прозрачностью и позволяет вам думать о программах как о серии **преобразований данных**. Это также позволяет создавать интересные вещи, такие как бесконечные структуры данных. Допустим, у вас есть неизменяемый список чисел `xs = [1,2,3,4,5,6,7,8]` и функция `doubleMe`, которая умножает каждый элемент на 2, а затем возвращает новый список. Если бы мы хотели умножить наш список на 8 на императивном языке и сделали `doubleMe( doubleMe( doubleMe(xs) ) )`, он, вероятно, прошел бы по списку один раз и сделал копию, а затем вернул бы ее. Затем он пройдет по списку еще два раза и вернет результат. На ленивом языке вызов `doubleMe` в списке, не заставляя его показывать вам результат, приводит к тому, что программа как бы говорит вам: "Да, да, я сделаю это позже!". Но как только вы захотите увидеть результат, первая "двойная строка" сообщит второй, что она хочет получить результат, сейчас же! Вторая скажет это третьей, и третья неохотно возвращает удвоенную 1, которая равна 2. Вторая получает это и возвращает 4 первой. Первая видит это и сообщает вам, что первый элемент равен 8. Таким образом, он выполняет только один проход по списку и только тогда, когда вам это действительно нужно. Таким образом, когда вам нужно что-то из ленивого языка, вы можете просто взять некоторые исходные данные и эффективно преобразовать и исправить их, чтобы они напоминали то, что вы хотите в конце.

![[LYHfGG_4_boat.png]]

Haskell является **статически типизированным**. Когда вы компилируете свою программу, компилятор знает, какой фрагмент кода является числом, который - строкой и так далее. Это означает, что во время компиляции обнаруживается множество возможных ошибок. Если вы попытаетесь сложить вместе число и строку, компилятор будет ныть на вас. Haskell использует очень хорошую систему типов, которая имеет **вывод типа**. Это означает, что вам не нужно явно помечать каждый фрагмент кода типом, потому что система типов может разумно многое выяснить об этом. Если вы говорите `a = 5 + 4`, вам не нужно говорить Haskell, что `a` - это число, он может вычислить это сам. Вывод типа также позволяет вашему коду быть более общим. Если созданная вами функция принимает два параметра и складывает их вместе, и вы явно не указываете их тип, функция будет работать с любыми двумя параметрами, которые действуют как числа.

Haskell **элегантен и лаконичен**. Поскольку в нем используется много высокоуровневых концепций, программы на Haskell обычно короче своих императивных эквивалентов. А более короткие программы легче поддерживать, чем более длинные, и в них меньше ошибок.

Haskell был создан несколькими **действительно умными парнями** (с докторскими степенями). Работа над Haskell началась в 1987 году, когда комитет исследователей собрался вместе для разработки потрясающего языка. В 2003 году был опубликован отчет Haskell, в котором определяется стабильная версия языка.

## Во что вам нужно погрузиться

Текстовый редактор и компилятор Haskell. Вероятно, у вас уже установлен ваш любимый текстовый редактор, так что мы не будем тратить на это время. Для целей этого руководства мы будем использовать GHC, наиболее широко используемый компилятор Haskell. Лучший способ начать - это загрузить [Haskell Platform](http://hackage.haskell.org/platform/), который в основном представляет собой Haskell с включенными батарейками.

GHC может взять скрипт на Haskell (обычно они имеют расширение .hs) и скомпилировать его, но он также имеет интерактивный режим, который позволяет вам интерактивно взаимодействовать со скриптами. Интерактивно. Вы можете вызывать функции из скриптов, которые вы загружаете, и результаты отображаются немедленно. Для обучения это намного проще и быстрее, чем компилировать каждый раз, когда вы вносите изменения, а затем запускать программу из командной строки. Интерактивный режим вызывается путем ввода `ghci` в вашей командной строке. Если вы определили какие-то функции в файле с именем, скажем, `myfunctions.hs`, вы загружаете эти функции, введя `:l myfunctions`, а затем можете поиграть с ними, при условии, что `myfunctions.hs` находится в той же папке, из которой был вызван `ghci`. Если вы измените скрипт .hs, просто снова запустите `:l myfunctions` или выполните `:r`, что эквивалентно, поскольку оно перезагружает текущий скрипт. Обычный рабочий процесс для меня, когда я копаюсь в материалах, - это определение некоторых функций в файле .hs, его загрузка и возня с ними, а затем изменение файла .hs, повторная загрузка и так далее. Это тоже то, чем мы будем заниматься здесь.

# Начиная

## На старт, внимание, марш!

![[LYHfGG_5_startingout.png]]

Хорошо, давайте начнем! Если вы из тех ужасных людей, которые не читают введения к книгам, и вы пропустили его, возможно, вы все равно захотите прочитать последний раздел введения, потому что в нем объясняется, что вам нужно для выполнения этого руководства и как мы собираемся загружать функции. Первое, что мы собираемся сделать, это запустить интерактивный режим ghc и вызвать какую-нибудь функцию, чтобы получить самое базовое представление о Haskell. Откройте свой терминал и введите `ghci`. Вас встретят чем-то вроде этого.

```haskell
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Prelude>
```

Поздравляю, вы находитесь в GHCI! Подсказка здесь `Prelude>`, но поскольку она может стать длиннее, когда вы загружаете материал в сеанс, мы собираемся использовать `ghci>`. Если вы хотите получить такое же приглашение, просто введите `:set prompt "ghci> "`.

Вот несколько простых арифметических действий.

```haskell
ghci> 2 + 15
17
ghci> 49 * 100
4900
ghci> 1892 - 1472
420
ghci> 5 / 2
2.5
ghci>
```

Это говорит само за себя. Мы также можем использовать несколько операторов в одной строке, и при этом соблюдаются все обычные правила приоритета. Мы можем использовать круглые скобки, чтобы сделать приоритет явным или изменить его.

```haskell
ghci> (50 * 100) - 4999
1
ghci> 50 * 100 - 4999
1
ghci> 50 * (100 - 4999)
-244950
```

Довольно круто, да? Да, я знаю, что это не так, но потерпи меня. Небольшая ошибка, на которую следует обратить внимание здесь, - это отрицание чисел. Если мы хотим получить отрицательное число, всегда лучше заключить его в круглые скобки. Выполнение `5 * -3` заставит GHCI кричать на вас, но выполнение `5 * (-3)` будет работать просто отлично.

Булева алгебра также довольно проста. Как вы, вероятно, знаете, `&&` означает логическое _И_, `||` означает логическое _ИЛИ_ . `not` отрицает `True` или `False`.

```haskell
ghci> True && False
False
ghci> True && True
True
ghci> False || True
True 
ghci> not False
True
ghci> not (True && True)
False
```

Проверка на равенство выполняется следующим образом.

```haskell
ghci> 5 == 5
True
ghci> 1 == 0
False
ghci> 5 /= 5
False
ghci> 5 /= 4
True
ghci> "hello" == "hello"
True 
```

Как насчет того, чтобы сделать `5 + "llama"` или `5 == True`? Что ж, если мы попробуем первый фрагмент, то получим большое пугающее сообщение об ошибке!

```haskell
No instance for (Num [Char])
arising from a use of `+' at <interactive>:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama" 
```

Черт возьми! GHCI говорит нам здесь, что "llama" - это не число, и поэтому он не знает, как добавить его к 5. Даже если бы это была не `"llama", а "four" или "4", Haskell все равно не счел бы это числом. `+` ожидает, что его левая и правая стороны будут числами. Если бы мы попытались выполнить `True == 5`, GHCI сказал бы нам, что типы не совпадают. В то время как `+` работает только с теми вещами, которые считаются числами, `==` работает с любыми двумя вещами, которые можно сравнить. Но загвоздка в том, что они оба должны быть одного типа. Вы не можете сравнивать яблоки и апельсины. Мы подробнее рассмотрим типы чуть позже. 

> Примечание: вы можете использовать `5 + 4.0`, потому что `5` является скрытым и может действовать как целое число или число с плавающей запятой. `4.0` не может действовать как целое число, поэтому `5` - это то, что должно адаптироваться.

Возможно, вы этого не знали, но мы все это время использовали функции. Например, `*` - это функция, которая принимает два числа и умножает их. Как вы видели, мы вызываем это, помещая его между ними. Это то, что мы называем _инфиксной_ функцией. Большинство функций, которые не используются с числами, являются _префиксными_ функциями. Давайте взглянем на них.

![[LYHfGG_6_ringring.png]]

Функции обычно являются префиксными, поэтому с этого момента мы не будем явно указывать, что функция имеет префиксную форму, мы просто предположим это. В большинстве императивных языков функции вызываются путем ввода имени функции, а затем ее параметров в круглых скобках, обычно через запятую. В Haskell функции вызываются путем ввода имени функции, пробела, а затем параметров, разделенных пробелами. Для начала мы попробуем вызвать одну из самых скучных функций в Haskell.

```haskell
ghci> succ 8
9 
```

Функция `succ` принимает все, что имеет определенного преемника, и возвращает этого преемника.^[Преемник (successor) - это число, следующее после некоторого натурального числа. <br>
Форма: Число + 1 = Преемник <br>
Функция приемника (successor function) - это функция, которая отправляет натуральное число следующему. <br>
Формула: f(x) = x + 1] Как вы можете видеть, мы просто отделяем имя функции от параметра пробелом. Вызов функции с несколькими параметрами также прост. Функции `min` и `max` используют две вещи, которые можно упорядочить (например, числа!). `min` возвращает значение, которое меньше, а `max` возвращает значение, которое больше. Смотрите сами:

```haskell
ghci> min 9 10
9
ghci> min 3.4 3.2
3.2
ghci> max 100 101
101 
```

Функциональное приложение (вызывающее функцию, ставя после нее пробел, а затем вводя параметры) имеет самый высокий приоритет из всех. Для нас это означает, что эти два утверждения эквивалентны.

```haskell
ghci> succ 9 + max 5 4 + 1
16
ghci> (succ 9) + (max 5 4) + 1
16
```

Однако, если бы мы хотели получить преемника произведения чисел 9 и 10, мы не могли бы написать `succ 9 * 10`, потому что это дало бы преемника 9, который затем был бы умножен на 10. Итак, 100. Нам пришлось бы написать `succ (9 * 10)`, чтобы получить 91.

Если функция принимает два параметра, мы также можем вызвать ее как инфиксную функцию, окружив ее обратными кавычками (` `` `). Например, функция `div` принимает два целых числа и выполняет целочисленное деление между ними. Выполнение `div 92 10` приводит к получению 9. Но когда мы называем это таким образом, может возникнуть некоторая путаница относительно того, какое число выполняет деление, а какое делится. Таким образом, мы можем вызвать это как инфиксную функцию, выполнив команду ``92 `div` 10``, и внезапно все становится намного понятнее.

Многие люди, пришедшие из императивных языков, склонны придерживаться представления о том, что круглые скобки должны обозначать применение функции. Например, в `C` вы используете круглые скобки для вызова таких функций, как `foo()`, `bar(1)` или `baz(3, "ха-ха")`. Как мы уже говорили, пробелы используются для применения функций в Haskell. Таким образом, этими функциями в Haskell были бы `foo`, `bar 1` и `baz 3 "ха-ха"`. Поэтому, если вы видите что-то вроде `bar (bar 3)`, это не означает, что `bar` вызывается с `bar` и `3` в качестве параметров. Это означает, что мы сначала вызываем функцию `bar` с `3` в качестве параметра, чтобы получить некоторое число, а затем мы снова вызываем `bar` с этим числом. В `C` это было бы что-то вроде `bar(bar(3))`.

## Первые детские функции

В предыдущем разделе мы получили базовое представление о вызове функций. Теперь давайте попробуем сделать нашу собственную функцию! Откройте свой любимый текстовый редактор и введите эту функцию, которая принимает число и умножает его на два.

```haskell
doubleMe x = x + x
```

Функции определяются аналогично тому, как они вызываются. За именем функции следуют параметры, разделенные пробелами. Но при определении функций есть `=`, и после этого мы определяем, что делает функция. Сохраните это как "baby.hs" или что-то в этом роде. Теперь перейдите туда, где он сохранен, и запустите `ghci` оттуда. Оказавшись внутри GHCI, выполните `:l baby`. Теперь, когда наш скрипт загружен, мы можем поиграть с функцией, которую мы определили.

```haskell
ghci> :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci> doubleMe 9
18
ghci> doubleMe 8.3
16.6 
```

Поскольку `+` работает как с целыми числами, так и с числами с плавающей запятой (все, что на самом деле можно считать числом), наша функция также работает с любым числом. Давайте создадим функцию, которая принимает два числа и умножает каждое на два, а затем складывает их вместе.

```haskell
doubleUs x y = x*2 + y*2 
```

Просто. Мы могли бы также определить это как `doubleUs x y = x + x + y + y`. Тестирование дает довольно предсказуемые результаты (не забудьте добавить эту функцию в файл `baby.hs`, сохранить его, а затем выполнить `:l baby` внутри GHCI).

```haskell
ghci> doubleUs 4 9
26
ghci> doubleUs 2.3 34.2
73.0
ghci> doubleUs 28 88 + doubleMe 123
478
```

Как и ожидалось, вы можете вызывать свои собственные функции из других созданных вами функций. Имея это в виду, мы могли бы переопределить `doubleUs` следующим образом:

```haskell
doubleUs x y = doubleMe x + doubleMe y 
```

Это очень простой пример общего шаблона, который вы увидите во всем Haskell. Создание базовых функций, которые, очевидно, являются правильными, а затем объединение их в более сложные функции. Таким образом, вы также избежите повторения. Что, если бы какие-нибудь математики выяснили, что 2 на самом деле равно 3, и вам пришлось бы изменить свою программу? Вы могли бы просто переопределить `doubleMe` на `x + x + x`, и поскольку `doubleUs` вызывает `doubleMe`, это автоматически сработало бы в этом странном новом мире, где 2 равно 3.

Функции в Haskell не обязательно должны располагаться в каком-либо определенном порядке, поэтому не имеет значения, определяете ли вы сначала `doubleMe`, а затем `doubleUs` или делаете это наоборот.

Теперь мы собираемся создать функцию, которая умножает число на 2, но только если это число меньше или равно 100, потому что числа больше 100 и так достаточно велики!

```haskell
doubleSmallNumber x = if x > 100
                        then x
                        else x*2 
```

![[LYHfGG_7_baby.png]]

Прямо здесь мы представили оператор `if`. Вероятно, вы знакомы с операторами `if` из других языков. Разница между оператором `if` в Haskell и операторами `if` в императивных языках заключается в том, что часть `else` является обязательной в Haskell. В императивных языках вы можете просто пропустить пару шагов, если условие не выполнено, но в Haskell каждое выражение и функция должны что-то возвращать. Мы могли бы также написать это выражение `if` в одной строке, но я нахожу этот способ более читабельным. Еще одна особенность оператора `if` в Haskell заключается в том, что оператор является _выражением_ . Выражение - это, по сути, фрагмент кода, который возвращает значение. `5` - это выражение, потому что оно возвращает 5, `4 + 8` - это выражение, `x + y` - это выражение, потому что оно возвращает сумму `x` и `y`. Поскольку `else` является обязательным, оператор `if` всегда будет возвращать что-то, и именно поэтому это выражение. Если бы мы хотели добавить единицу к каждому числу, полученному в нашей предыдущей функции, мы могли бы написать ее тело следующим образом.

```haskell
doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
```

Если бы мы опустили круглые скобки, это добавило бы единицу только в том случае, если `x` было не больше 100. Обратите внимание на `'` в конце имени функции. Этот апостроф не имеет никакого особого значения в синтаксисе Haskell. Это допустимый символ для использования в имени функции. Обычно мы используем `'` либо для обозначения строгой версии функции (той, которая не является ленивой), либо для слегка измененной версии функции или переменной. Поскольку `'` является допустимым символом в функциях, мы можем создать функцию, подобную этой.

```haskell
conanO'Brien = "It's a-me, Conan O'Brien!" 
```

Здесь есть две заслуживающие внимания вещи. Во-первых, мы не написали имя функции с заглавной буквы. Это потому, что функции не могут начинаться с заглавных букв. Мы поймем, почему, чуть позже. Во-вторых, эта функция не принимает никаких параметров. Когда функция не принимает никаких параметров, мы обычно говорим, что это _определение_ (или _имя_^[Честно говоря не знаю как правильнее в данном случае перевести слово name]). Поскольку мы не можем изменить значение имен (и функций), как только мы их определили, `conanO'Brien` и строка `"It's a-me, Conan O'Brien!"` могут использоваться взаимозаменяемо.

## Введение в списки

![[LYHfGG_8_list.png]]

Подобно спискам покупок в реальном мире, списки в Haskell очень полезны. Это наиболее используемая структура данных, и ее можно использовать множеством различных способов для моделирования и решения целого ряда проблем. Списки - это ТАК здорово. В этом разделе мы рассмотрим основы списков, строк (которые являются списками) и понимания списков.

В Haskell списки представляют собой **однородную** (англ. homogenous) структуру данных. В нем хранится несколько элементов одного и того же типа. Это означает, что у нас может быть список целых чисел или список символов, но у нас не может быть списка, состоящего из нескольких целых чисел, а затем нескольких символов. А теперь список!

> **Примечание**: Мы можем использовать ключевое слово `let` для определения имени прямо в GHCI. Выполнение `let a = 1` внутри GHCI эквивалентно записи `a = 1` в скрипте и последующей его загрузке.

```haskell
ghci> let lostNumbers = [4,8,15,16,23,42]
ghci> lostNumbers
[4,8,15,16,23,42]
```

Как вы можете видеть, списки заключены в квадратные скобки, а значения в списках разделены запятыми. Если бы мы попробовали использовать список типа `[1,2,'a',3,'b','c',4]`, Haskell пожаловался бы, что символы (которые, кстати, обозначаются как символ между одинарными кавычками) не являются числами. Говоря о символах, строки - это просто списки символов. `"hello"` - это просто синтаксический сахар для `['h','e','l','l','o']`. Поскольку строки представляют собой списки, мы можем использовать для них функции списка, что действительно удобно.

Обычная задача - собрать два списка воедино. Это делается с помощью оператора `++`.

```haskell
ghci> [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci> "hello" ++ " " ++ "world"
"hello world"
ghci> ['w','o'] ++ ['o','t']
"woot"
```

Будьте осторожны при повторном использовании оператора `++` для длинных строк. Когда вы объединяете два списка (даже если вы добавляете одноэлементный список к списку, например: `[1,2,3] ++ [4]`), внутренне Haskell должен просмотреть весь список в левой части `++`. Это не проблема, когда имеешь дело со списками, которые не слишком велики. Но для того, чтобы поместить что-то в конец списка длиной в пятьдесят миллионов записей, потребуется некоторое время. Однако поместить что-либо в начало списка с помощью оператора `:` (также называемого оператором `cons`) можно мгновенно.

```haskell
ghci> 'A':" SMALL CAT"
"A SMALL CAT"
ghci> 5:[1,2,3,4,5]
[5,1,2,3,4,5]
```

Обратите внимание, как `:` принимает число и список чисел или символ и список символов, тогда как `++` принимает два списка. Даже если вы добавляете элемент в конец списка с помощью `++`, вы должны заключить его в квадратные скобки, чтобы он стал списком.

`[1,2,3]` на самом деле является просто синтаксическим сахаром для `1:2:3:[]`. `[]` - это пустой список. Если мы добавим к нему `3`, оно станет `[3]`. Если мы добавим к этому `2`, оно станет `[2,3]` и так далее.

> **Примечание:** `[]`, `[[]]` и `[[],[],[]]` это все разные вещи. Первый - это пустой список, второй - это список, содержащий один пустой список, третий - это список, содержащий три пустых списка.

Если вы хотите получить элемент из списка по индексу, используйте `!!`. Индексы начинаются с 0.

```haskell
ghci> "Steve Buscemi" !! 6
'B'
ghci> [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
```

Но если вы попытаетесь получить шестой элемент из списка, состоящего всего из четырех элементов, вы получите сообщение об ошибке, так что будьте осторожны!

Списки также могут содержать списки. Они также могут содержать списки, которые содержат списки, которые содержат списки ...

```haskell
ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci> [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b !! 2
[1,2,2,3,4] 
```

Списки внутри списка могут быть разной длины, но они не могут быть разных типов. Точно так же, как у вас не может быть списка, содержащего некоторые символы и некоторые цифры, у вас не может быть списка, содержащего некоторые списки символов и некоторые списки чисел.

Списки можно сравнивать, если можно сравнить содержащийся в них материал. При использовании `<`, `<=`, `>` и `>=` для сравнения списков они сравниваются в лексикографическом порядке. Сначала сравниваются головы. Если они равны, то сравниваются вторые элементы и т.д.

```haskell
ghci> [3,2,1] > [2,1,0]
True
ghci> [3,2,1] > [2,10,100]
True
ghci> [3,4,2] > [3,4]
True
ghci> [3,4,2] > [2,4]
True
ghci> [3,4,2] == [3,4,2]
True
```

Что еще вы можете сделать со списками? Вот некоторые основные функции, которые работают со списками.

`head` принимает список и возвращает его заголовок. Заголовок списка - это, по сути, его первый элемент.

```haskell
ghci> head [5,4,3,2,1]
5 
```

`tail` принимает список и возвращает его хвост. Другими словами, это отрубает голову списку.

```haskell
ghci> tail [5,4,3,2,1]
[4,3,2,1] 
```

`last` принимает список и возвращает его последний элемент.

```haskell
ghci> last [5,4,3,2,1]
1 
```

`init` принимает список и возвращает все, кроме его последнего элемента.

```haskell
ghci> init [5,4,3,2,1]
[5,4,3,2] 
```

Если мы думаем о списке как о монстре, то вот что есть что.

![[LYHfGG_9_listmonster.png]]

Но что произойдет, если мы попытаемся получить начало пустого списка?

```haskell
ghci> head []
*** Exception: Prelude.head: empty list
```

О боже! Все это взрывается нам в лицо! Если монстра нет, то у него нет головы. При использовании `head`, `tail`, `last` и `init` будьте осторожны и не используйте их в пустых списках. Эта ошибка не может быть обнаружена во время компиляции, поэтому всегда рекомендуется принимать меры предосторожности, чтобы случайно не попросить Haskell предоставить вам некоторые элементы из пустого списка.

очевидно, что `length` принимает список и возвращает его длину.

```haskell
ghci> length [5,4,3,2,1]
5
```

`null` проверяет, пуст ли список. Если это так, то он возвращает `True`, в противном случае он возвращает `False`. Используйте эту функцию вместо `xs == []` (если у вас есть список с именем `xs`)

```haskell
ghci> null [1,2,3]
False
ghci> null []
True
```

`reverse` переворачивает список.

```haskell
ghci> reverse [5,4,3,2,1]
[1,2,3,4,5]
```

`take` принимает номер и список. Он извлекает некоторое количество элементов из начала списка. Посмотри.

```haskell
ghci> take 3 [5,4,3,2,1]
[5,4,3]
ghci> take 1 [3,9,3]
[3]
ghci> take 5 [1,2]
[1,2]
ghci> take 0 [6,6,6]
[]
```

Посмотрите, как если мы попытаемся взять больше элементов, чем есть в списке, это просто вернет список. Если мы попытаемся взять 0 элементов, то получим пустой список.

`drop` работает аналогичным образом, только он уменьшает количество элементов из начала списка.

```haskell
ghci> drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci> drop 0 [1,2,3,4]
[1,2,3,4]
ghci> drop 100 [1,2,3,4]
[] 
```

`maximum` принимает список элементов, которые можно расположить в определенном порядке, и возвращает самый большой элемент.

`minimum` возвращает наименьшее значение.

```haskell
ghci> minimum [8,4,2,1,5,6]
1
ghci> maximum [1,9,2,3,4]
9 
```

`sum` принимает список чисел и возвращает их сумму.

`product` принимает список чисел и возвращает их произведение.

```haskell
ghci> sum [5,2,1,6,3,2,5,7]
31
ghci> product [6,2,1,2]
24
ghci> product [1,2,5,6,7,9,2,0]
0 
```

`elem` берет вещь и список вещей и сообщает нам, является ли эта вещь элементом списка. Обычно она вызывается как инфиксная функция, потому что так ее легче читать.

```haskell
ghci> 4 `elem` [3,4,5,6]
True
ghci> 10 `elem` [3,4,5,6]
False
```

Это было несколько основных функций, которые работают со списками. Мы рассмотрим дополнительные функции списка [позже](http://learnyouahaskell.com/modules#data-list)

## Техасские диапазоны

![[LYHfGG_10_cowboy.png]]

Что, если нам нужен список всех чисел от 1 до 20? Конечно, мы могли бы просто напечатать их все, но, очевидно, это не решение для джентльменов, которые требуют совершенства от своих языков программирования. Вместо этого мы будем использовать диапазоны. Диапазоны - это способ создания списков, представляющих собой арифметические последовательности элементов, которые можно перечислять. Числа можно перечислять. Один, два, три, четыре и так далее. Символы также могут быть пронумерованы. Алфавит - это перечисление символов от `A` до `Z`^[Стандарт вышел 10 лет назад и он сохраняет обратную совместимость. Поэтому, чтобы использовать unicode, нужно провести небольшие манипуляции. Об этом можно поискать в интернете. "ghci how add utf 8"]. Имена не могут быть пронумерованы. Что следует за словом "John"? Я не знаю.

Чтобы составить список, содержащий все натуральные числа от 1 до 20, вы просто пишете `[1..20]`. Это эквивалентно написанию `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`, и нет никакой разницы между написанием одного или другого, за исключением того, что записывать длинные последовательности перечисления вручную глупо.

```haskell
ghci> [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci> ['K'..'Z']
"KLMNOPQRSTUVWXYZ" 
```

Диапазоны хороши тем, что вы также можете указать шаг. Что, если нам нужны все четные числа от 1 до 20? Или каждое третье число от 1 до 20?

```haskell
ghci> [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci> [3,6..20]
[3,6,9,12,15,18] 
```

Это просто вопрос разделения первых двух элементов запятой, а затем указания верхнего предела. Несмотря на то, что диапазоны со ступенями довольно умны, они не так умны, как некоторые люди ожидают от них. Вы не можете выполнить `[1,2,4,8,16..100]` и ожидать, что получите все степени 2. Во-первых, потому, что вы можете указать только один шаг. А во-вторых, потому что некоторые последовательности, которые не являются арифметическими, неоднозначны, если заданы только несколькими их первыми членами.

Чтобы составить список со всеми числами от 20 до 1, вы не можете просто выполнить `[20..1]`, вы должны выполнить `[20,19..1]`.

Будьте осторожны при использовании чисел с плавающей запятой в диапазонах! Поскольку они не являются полностью точными (по определению), их использование в диапазонах может привести к довольно странным результатам.

```haskell
ghci> [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
```

Мой совет - не использовать их в диапазонах списков.

Вы также можете использовать диапазоны для создания бесконечных списков, просто не указывая верхний предел. Позже мы более подробно остановимся на бесконечных списках. А пока давайте рассмотрим, как бы вы получили первые 24 числа, кратные 13. Конечно, вы могли бы сделать `[13,26..24*13]`. Но есть способ получше: `возьми 24 [13,26..]`. Поскольку Haskell ленив, он не будет пытаться оценить бесконечный список немедленно, потому что он никогда не завершится. Это подождет, чтобы увидеть, что вы хотите получить из этих бесконечных списков. И вот он видит, что вам нужны только первые 24 элемента, и с радостью соглашается.

Несколько функций, которые создают бесконечные списки:

`cycle` берет список и преобразует его в бесконечный список. Если вы просто попытаетесь отобразить результат, он будет продолжаться вечно, так что вам придется где-то его отрезать.

```haskell
ghci> take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci> take 12 (cycle "LOL ")
"LOL LOL LOL " 
```

`repeat` принимает элемент и создает бесконечный список только этого элемента. Это все равно что перебирать список, содержащий только один элемент.

```haskell
ghci> take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
```

Хотя проще просто использовать функцию `replicate`, если вам нужно некоторое количество одного и того же элемента в списке. `replicate 3 10` возвращает `[10,10,10]`.

## Я - списковое включение (англ. _list comprehension_)

Списковое включение^[Альтернативное название, более понятное программистам "генераторы списков". Но использую по [вики](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5#:~:text=%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%20%D0%B8%D0%BB%D0%B8%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5%20%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5,%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9%20%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2.)) ]

![[LYHfGG_11_kermit.png]]

Если вы когда-либо проходили курс математики, вы, вероятно, сталкивались с _множествами с заданными характеристическими свойствами_^[В оригинале был термин "set comprehensions". Ссылка откуда взял: [What is Russian translation for "set comprehension"](https://russian.stackexchange.com/questions/1530/what-is-russian-translation-for-set-comprehension). И я посчитал, что второй ответ более подходящий]. Обычно они используются для построения более специфичных наборов из общих наборов. Базовое списковое включение для набора, содержащего первые десять четных натуральных чисел, составляет^[Я не знаю какая запись более правильная для русской традиции записи. Поэтому оставил как в оригинале] $$S = \{2\ \cdot\ x\ |\ x \in \mathbb{N},\ x \leqslant 10\}$$. Часть перед вертикальной чертой называется выходной функцией, `x` - это переменная, `N` - это входной набор, а `x <= 10` - это предикат^[Предикат - если просто, то это условие]. Это означает, что множество содержит удвоения всех натуральных чисел, которые удовлетворяют предикату.

Если бы мы хотели написать это на Haskell, мы могли бы сделать что-то вроде `take 10 [2,4..]`. Но что, если бы мы хотели получить не удвоения первых 10 натуральных чисел, а какую-то более сложную функцию, примененную к ним? Для этого мы могли бы использовать списковое включение. Списковое включение очень похоже на понимание набора. Пока мы будем придерживаться получения первых 10 четных чисел. Списковое включение, которое мы могли бы использовать, - это `[x * 2 | x <- [1..10]]`. `x` берется из `[1..10]`, и для каждого элемента в `[1..10]` (который мы привязали к `x`) мы получаем этот элемент, только удвоенный. Вот списковое включение в действии.

```haskell
ghci> [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
```

Как вы можете видеть, мы получаем желаемые результаты. Теперь давайте добавим условие (или предикат) к этому списковому включению. Предикаты идут после связующих частей и отделяются от них запятой. Допустим, нам нужны только те элементы, которые в удвоенном виде больше или равны 12.

```haskell
ghci> [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
```

Круто, это работает. Как насчет того, если бы мы хотели получить все числа от 50 до 100, остаток от которых при делении на число 7 равен 3? Легко.

```haskell
ghci> [ x | x <- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94] 
```

Успех! Обратите внимание, что отсеивание списков по предикатам также называется **фильтрацией** (англ. filtering). Мы взяли список чисел и отфильтровали их по предикату. Теперь перейдем к другому примеру. Допустим, нам нужно списковое включение, которое заменяет каждое нечетное число, большее 10, на `"BANG!"`, а каждое нечетное число, меньшее 10, на `"BOOM!"`. Если число не нечетное, мы исключаем его из нашего списка. Для удобства мы поместим это списковое включение внутрь функции, чтобы мы могли легко использовать его повторно.

```haskell
boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] 
```

Последняя часть спискового включения - это предикат. Функция `odd` возвращает `True` для нечетного числа и `False` для четного. Элемент включается в список только в том случае, если все предикаты оцениваются как `True`.

```haskell
ghci> boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"] 
```

Мы можем включить несколько предикатов. Если бы нам нужны были все числа от 10 до 20, которые не равны 13, 15 или 19, мы бы сделали:

ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]

Мы не только можем иметь несколько предикатов в списковом включении (элемент должен удовлетворять всем предикатам, которые будут включены в результирующий список), мы также можем извлекать данные из нескольких списков. При рисовании из нескольких списковых включений создает все комбинации заданных списков, а затем объединяет их с помощью функции вывода, которую мы предоставляем. Список, созданный с помощью спискового включения, который основывается на двух списках длиной 4, будет иметь длину 16, при условии, что мы их не фильтруем. Если у нас есть два списка, `[2,5,10]` и `[8,10,11]`, и мы хотим получить произведения всех возможных комбинаций чисел в этих списках, вот что мы бы сделали.

```haskell
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110] 
```

Как и ожидалось, длина нового списка равна 9. Что, если бы нам понадобились все возможные произведения, которых более 50?

```haskell
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
[55,80,100,110] 
```

Как насчет спискового включения, которое сочетает в себе список прилагательных и список существительных ... для эпического веселья.

```haskell
ghci> let nouns = ["hobo","frog","pope"]
ghci> let adjectives = ["lazy","grouchy","scheming"]
ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"] 
```

Я знаю! Давайте напишем нашу собственную версию `длины`! Мы будем называть это `length'`.

```haskell
length' xs = sum [1 | _ <- xs] 
```

`_` означает, что нам все равно, что мы будем извлекать из списка, поэтому вместо того, чтобы писать имя переменной, которое мы никогда не будем использовать, мы просто пишем `_`. Эта функция заменяет каждый элемент списка на `1`, а затем суммирует его. Это означает, что результирующая сумма будет равна длине нашего списка.

Просто дружеское напоминание: поскольку строки являются списками, мы можем использовать списковое включение для обработки и создания строк. Вот функция, которая принимает строку и удаляет из нее все, кроме прописных букв.

```haskell
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
```

Проверяю это на практике:

```haskell
ghci> removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci> removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS" 
```

Предикат здесь выполняет всю работу. В нем говорится, что символ будет включен в новый список, только если он является элементом списка `['A'..'Z']`. Вложенное списковое включение также возможно, если вы работаете со списками, которые содержат списки. Список содержит несколько списков чисел. Давайте удалим все нечетные числа, не выравнивая список.

```haskell
ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci> [ [ x | x <- xs, even x ] | xs <- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
```

Вы можете написать списковое включение в нескольких строках. Поэтому, если вы не используете GHCI, лучше разделить более длинные списковые включения на несколько строк, особенно если они вложены.

## Кортежи

![[LYHfGG_13_tuple.png]]

В некотором смысле кортежи подобны спискам — это способ хранения нескольких значений в одном значении. Однако есть несколько фундаментальных отличий. Список чисел - это список чисел. Это его тип, и не имеет значения, содержит ли он только одно число или бесконечное количество чисел. Однако кортежи используются, когда вы точно знаете, сколько значений вы хотите объединить, а их тип зависит от того, сколько в нем компонентов и типов компонентов. Они обозначаются круглыми скобками, а их компоненты разделяются запятыми.

Еще одно ключевое отличие заключается в том, что они не обязательно должны быть однородными. В отличие от списка, кортеж может содержать комбинацию нескольких типов.

Подумайте о том, как бы мы представили двумерный вектор в Haskell. Одним из способов было бы использовать список. Это вроде как сработало бы. Итак, что, если бы мы захотели поместить пару векторов в список для представления точек фигуры на двумерной плоскости? Мы могли бы сделать что-то вроде `[[1,2],[8,11],[4,5]]`. Проблема с этим методом заключается в том, что мы также могли бы делать такие вещи, как `[[1,2],[8,11,5],[4,5]]`, с чем у Haskell нет проблем, поскольку это все еще список списков с числами, но это как бы не имеет смысла. Но кортеж второго размера (также называемый парой) имеет свой собственный тип, что означает, что в списке не может быть пары пар, а затем тройки (кортеж третьего размера), поэтому давайте используем кортеж вместо списка. Вместо того чтобы заключать векторы в квадратные скобки, мы используем круглые скобки: `[(1,2),(8,11),(4,5)]`. Что, если бы мы попытались создать форму, подобную `[(1,2),(8,11,5),(4,5)]`? Ну, мы бы получили эту ошибку:

```haskell
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
```

Это говорит нам о том, что мы пытались использовать пару и тройку в одном списке, чего не должно было произойти. Вы также не смогли бы составить список типа `[(1,2),("Один",2)]`, потому что первый элемент списка - это пара чисел, а второй элемент - это пара, состоящая из строки и числа. Кортежи также могут использоваться для представления самых разнообразных данных. Например, если бы мы хотели представить чье-то имя и возраст в Haskell, мы могли бы использовать тройку: `("Christopher", "Walken", 55)`. Как видно из этого примера, кортежи также могут содержать списки.

Используйте кортежи, когда вы заранее знаете, сколько компонентов должно быть в том или ином фрагменте данных. Кортежи намного более жесткие, потому что каждый кортеж разного размера имеет свой собственный тип, поэтому вы не можете написать общую функцию для добавления элемента к кортежу — вам пришлось бы написать функцию для добавления к паре, одну функцию для добавления к тройке, одну функцию для добавления к 4-му кортежу и т.д.

Хотя существуют одноэлементные списки, такого понятия, как одноэлементный кортеж, не существует. На самом деле это не имеет особого смысла, когда ты думаешь об этом. Одноэлементный кортеж был бы просто значением, которое он содержит, и как таковой не принес бы нам никакой пользы.

Как и списки, кортежи можно сравнивать друг с другом, если можно сравнить их компоненты. Только вы не можете сравнить два кортежа разных размеров, в то время как вы можете сравнить два списка разных размеров. Две полезные функции, которые работают с парами:

`fst` принимает пару и возвращает ее первый компонент.

```haskell
ghci> fst (8,11)
8
ghci> fst ("Wow", False)
"Wow"
```

`snd` принимает пару и возвращает ее второй компонент. Сюрприз!

```haskell
ghci> snd (8,11)
11
ghci> snd ("Wow", False)
False
```

> **Примечание** эти функции работают только с парами. Они не будут работать с тройками, 4-кортежами, 5-кортежами и т.д. Чуть позже мы рассмотрим извлечение данных из кортежей различными способами.

Классная функция, которая выдает список пар: `zip`. Он берет два списка, а затем объединяет их в один список, объединяя совпадающие элементы в пары. Это действительно простая функция, но у нее множество применений. Это особенно полезно, когда вы хотите каким-то образом объединить два списка или одновременно просматривать два списка. Вот демонстрация.

```haskell
ghci> zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
```

Он объединяет элементы в пары и создает новый список. Первый элемент сочетается с первым, второй - со вторым и т.д. Обратите внимание, что, поскольку пары могут содержать разные типы, `zip` может взять два списка, содержащих разные типы, и объединить их. Что произойдет, если длины списков не совпадут?

```haskell
ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
```

Более длинный список просто обрезается, чтобы соответствовать длине более короткого. Поскольку Haskell ленив, мы можем объединять конечные списки с бесконечными списками:

```haskell
ghci> zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
```

![[LYHfGG_14_pythag.png]]

Вот задача, которая сочетает в себе понимание кортежей и списков: какой прямоугольный треугольник, который имеет целые числа для всех сторон и все стороны которого равны или меньше 10, имеет периметр 24? Сначала давайте попробуем сгенерировать все треугольники со сторонами, равными или меньшими 10:

```haskell
ghci> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ] 
```

Мы просто рисуем из трех списков, и наша функция вывода объединяет их в тройку. Если вы оцените это, введя `triangles` в GHCI, вы получите список всех возможных треугольников со сторонами меньше или равными 10. Далее мы добавим условие, что все они должны быть прямоугольными треугольниками. Мы также модифицируем эту функцию, принимая во внимание, что сторона `b` не больше гипотенузы и что сторона `a` не больше стороны `b`.

```haskell
ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2] 
```

Мы почти закончили. Теперь мы просто модифицируем функцию, сказав, что нам нужны те, у которых периметр равен 24.

```haskell
ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci> rightTriangles'
[(6,8,10)]
```

И вот наш ответ! Это распространенный шаблон в функциональном программировании. Вы берете начальный набор решений, а затем применяете преобразования к этим решениям и фильтруете их до тех пор, пока не получите правильные.

# Сноски переводчика

