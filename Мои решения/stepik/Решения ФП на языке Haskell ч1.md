# 1. Введение


## 1.1 Установка и настройка среды

### Задание 1

Устанавливал не Haskell Platform, а ghcup

Тем не менее ответ:

```
*Main>
```

## 1.2 Функции

### Задание 1

В стандартной библиотеке Haskell есть функция вычисления логарифма по произвольному основанию `logBase`. Это функция двух переменных, которой требуется передать основание логарифма и аргумент, на котором логарифм будет вычислен. Какие из следующих вызовов обеспечат вычисление логарифма по основанию 2 от 8?

Ответ:

- [x] (logBase 2) 8
- [ ] logBase (2, 8)
- [ ] logBase (2 8)
- [ ] (logBase, 2, 8)
- [x] logBase 2 8

### Задание 2

Реализуйте функцию трех аргументов `lenVec3`, которая вычисляет длину трехмерного вектора. Аргументы функции задают декартовы координаты конца вектора, его начало подразумевается находящимся в начале координат. Для извлечения квадратного корня воспользуйтесь функцией `sqrt`, определенной в стандартной библиотеке.

```haskell
GHCi> lenVec3 2 3 6
7.0
```

Ответ:

```haskell
lenVec3 x y z = sqrt $ x^2 + y^2 + z^2
```

### Задание 3

Напишите реализацию функции `sign`, которая возвращает 1, если ей передано положительное число, (-1), если отрицательное, и 0 в случае, когда передан 0.

```haskell
GHCi> sign (-100)
-1
```

Ответ:

```haskell
sign x | x == 0    =  0
       | x <  0    = -1
       | otherwise =  1
```

или

```haskell
sign = signum
```

### Задание 4

Предположим, мы разрабатываем на Haskell интерфейс системы перевода для естественных языков. Он должен содержать функцию `translate` с параметрами `text`, `languageFrom` и `languageTo`. Расположите параметры в таком порядке, чтобы было удобно реализовывать следующие функции: `translateFromSpanishToRussian`, `translateFromEnglishToRussian` и `translateToRussian`.

Ответ:

- [ ] translate languageFrom text languageTo
- [ ] translate languageTo text languageFrom
- [ ] translate text languageTo languageFrom
- [ ] translate text languageFrom languageTo
- [ ] translate languageFrom languageTo
- [x] texttranslate languageTo languageFrom text

## 1.3 Операторы

### Задание 1

Попробуйте вычислить значение выражения `2 ^ 3 ^ 2`, не используя GHCi.

Ответ: `512`

### Задание 2

Попробуйте вычислить значение выражения `(*) 2 ((+) 1 4) ^ 2`, не используя GHCi.

Ответ: `100`

### Задание 3

Используя данное выше определение оператора `(*+*)`:

```haskell
infixl 6 *+*
(*+*) a b = a ^ 2 + b ^ 2
```

попробуйте устно вычислить значение выражения `1 + 3 *+* 2 * 2`.

Ответ: `32`

### Задание 4

Реализуйте оператор `|-|`, который возвращает модуль разности переданных ему аргументов:

```haskell
GHCi>  5 |-| 7
2
```

Ответ:

```haskell
x |-| y = abs $ x - y
```

### Задание 5

Попробуйте вычислить значение выражения ``(`mod` 14) ((+ 5) 10)``, не используя GHCi. (Функция `mod` возвращает остаток от целочисленного деления первого своего аргумента на второй.)

Ответ: `1`

### Задание 6

Используя оператор `$`, перепишите выражение `logBase 4 (min 20 (9 + 7))` без скобок. (Разделяйте все токены одним пробелом.)

```haskell
logBase 4 $ min 20 $ 9 + 7
```

## 1.4 Базовые типы

### Задание 1

Какие из следующих выражений типизированы верно, то есть не приводят к ошибкам типа?

Ответ:

- [ ] (3.0 :: Integer) + (5 :: Integer)
- [x] (3 :: Integer) + (5 :: Integer)
- [x] (3.2 :: Double) + (5 :: Double)
- [ ] (3 :: Int) + (5 :: Integer)
- [ ] (3 :: Double) + (5 :: Float)

### Задание 2

Вспомним функцию `discount`, которая возвращала итоговую сумму покупки с возможной скидкой. В качестве параметров ей передавались сумма без скидки `sum`, процент скидки `proc`, причем скидка начислялась, если переданная сумма превышает порог `limit`. Все эти параметры, как и возвращаемое значение, можно хранить в типе `Double`. (Здесь следует отметить, что в реальных финансовых приложениях использовать тип с плавающей точкой для хранения подобной информации не рекомендуется.) Тип функции можно задать в файле исходного кода вместе с ее определением:

```haskell
discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
```

Отметим, что объявление типа необязательно, хотя часто рекомендуется в качестве документации. Его обычно располагают перед определением функции, хотя это объявление верхнего уровня можно расположить в любом месте файла с исходным кодом.

Запишите тип функции `standardDiscount`, определенной как частичное применение функции `discount`:

```haskell
standardDiscount :: ???
standardDiscount = discount 1000 5 
```

Ответ:

```haskell
discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum

standardDiscount :: Double -> Double
standardDiscount = discount 1000 5
```

### Задание 3

Воспользовавшись справочной системой [Hoogle](https://www.haskell.org/hoogle/), найдите имя функции типа `Char -> Char`, переводящей символ в нижний регистр.

Ответ: `toLower`

### Задание 4

Реализуйте функцию `twoDigits2Int`, которая принимает два символа и возвращает число, составленное из этих символов, если оба символа числовые, и 100 в противном случае. (Первый символ рассматривается как количество десятков, второй — единиц.)

```haskell
GHCi> twoDigits2Int '4' '2'
42
```

Ответ:

```haskell
import Data.Char
twoDigits2Int :: Char -> Char -> Int
twoDigits2Int x y | isDigit x && isDigit y = digitToInt x * 10 + digitToInt y
                  | otherwise = 100
```

### Задание 5

Будем задавать точки на плоскости парами типа `(Double, Double)`. Реализуйте функцию `dist`, которая возвращает расстояние между двумя точками, передаваемыми ей в качестве аргументов.

```haskell
dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = ???
```

Ответ:

```haskell
dist :: (Double, Double) -> (Double, Double) -> Double
dist (x1, y1) (x2, y2) = sqrt $ (x2 - x1)^2 + (y2 - y1)^2
```

### Задание 6

Операторы `(:)` и `(++)` имеют одинаковую ассоциативность и приоритет. Укажите их. (Воспользуйтесь командой интерпретатора GHCi `:info`).

Ответ:

- [ ] infix 6
- [ ] infix 5
- [ ] infixl 6
- [ ] infixl 5
- [x] infixr 5
- [ ] infixr 6


### Задание 7

Не используя GHCi, выберите выражения, проходящие проверку типов.

Ответ:

- [x] [1,2] ++ (:) 3 [4,5,6]
- [ ] (++) [1,2] 3 : [4,5,6]
- [ ] (:) 1 (++) [2,3] [4,5,6]
- [x] (:) 1 ((++) [2,3] [4,5,6])
- [ ] [1,2] ++ [3,4,5] : 6
- [ ] [1,2] : 3 ++ [4,5,6]
- [x] [1,2] ++ 3 : [4,5,6]
- [x] 1 : [2,3] ++ [4,5,6]

## 1.5 Рекурсия

### Задание 1

Определите функцию, вычисляющую двойной факториал, то есть произведение натуральных чисел, не превосходящих заданного числа и имеющих ту же четность. Например: 7!!=7⋅5⋅3⋅17!!=7⋅5⋅3⋅1,  8!!=8⋅6⋅4⋅28!!=8⋅6⋅4⋅2. Предполагается, что аргумент функции может принимать только неотрицательные значения.

Ответ:

```haskell
doubleFact :: Integer -> Integer
doubleFact 1 = 1
doubleFact 2 = 2
doubleFact n = n * doubleFact (n - 2)
```

### Задание 2

В последнем примере предыдущего шага в охранном выражении использовался идентификатор `otherwise`. Это не ключевое слово, а константа, определенная для удобства в стандартной библиотеке:

```haskell
otherwise = ?
```

Как вы думаете, какова правая часть её определения?

Ответ: `True`

### Задание 3

Последовательность чисел Фибоначчи 0,1,1,2,3,5,8,13,2... легко определить рекурсивно, задав два первых терминирующих значения и определив любое последующее как сумму двух непосредственно предыдущих:

$F_0=0$

$F_1=1$

$F_n = F_{n-1} + F_{n-2}$

На Haskell данное определение задаётся следующей функцией:  

```haskell
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)
```

Эта функция определена лишь для неотрицательных чисел. Однако, из данного выше определения можно вывести формулу для вычисления чисел Фибоначчи при отрицательных индексах, при этом последовательность будет следующей:

$F_{-1}=1,F_{-2}=-1,...,F_{-10}=-55,...$

Измените определение функции `fibonacci` так, чтобы она была определена для всех целых чисел и порождала при отрицательных аргументах указанную последовательность.

Подсказка:

| $n$ | $F_n$ |
| --- | ----- |
| ... | ...   |
| -10 | -55   |
| -9  | 34    |
| -8  | -21   |
| -7  | 13    |
| -6  | -8    |
| -5  | 5     |
| -4  | -3    |
| -3  | 2     |
| -2  | -1    |
| -1  | 1     |
| 0   | 0     |
| 1   | 1     |
| 2   | 1     |
| 3   | 2     |
| 4   | 3     |
| 5   | 5     |
| 6   | 8     |
| 7   | 13    |
| 8   | 21    |
| 9   | 34    |
| 10  | 55    | 
| ... | ...   |

[Обобщённые числа Фибоначчи](https://ru.wikipedia.org/wiki/Обобщённые_числа_Фибоначчи)

Ответ:

Мой:

```haskell
fibonacci :: Integer -> Integer
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n | n < 0     = (-1) ^ (1 - n) * fibonacci (-n)
            | otherwise = fibonacci (n - 1) + fibonacci (n - 2)
```

Лучший:

```haskell
fibonacci :: Integer -> Integer
fibonacci n | n > 1     = fibonacci (n - 1) + fibonacci (n - 2)
            | n < 0     = fibonacci (n + 2) - fibonacci (n + 1)
            | otherwise = n
```

### Задание 4

Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении, крайне неэффективна - количество вызовов функции растет экспоненциально с ростом значения аргумента. GHCi позволяет отслеживать использование памяти и затраты времени на вычисление выражения, для этого следует выполнить команду `:set +s`:

```haskell
GHCi> :set +s
GHCi> fibonacci 30
832040
(8.36 secs, 298293400 bytes)
```

С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию, имеющую линейную сложность (по числу рекурсивных вызовов). Как и в предыдущем задании, функция должна быть определена для всех целых чисел.

Ответ:

```haskell
fibonacci :: Integer -> Integer
fibonacci n | n == 0 = 0
            | n == 1 = 1
            | n > 0  = helper 0 1 n
            | n < 0  = (-1) ^ (1 - n) * ( helper 0 1 (-n)) 

helper acc1 _    0 = acc1
helper acc1 acc2 n = helper (acc2) (acc1 + acc2) (n - 1)
```

```haskell
fibonacci 10

helper 0  1  10 = helper (1)  (0 + 1)   (10 - 1)
helper 1  1  9  = helper (1)  (1 + 1)   (9 - 1)
helper 1  2  8  = helper (2)  (1 + 2)   (8 - 1)
helper 2  3  7  = helper (3)  (2 + 3)   (7 - 1)
helper 3  5  6  = helper (5)  (3 + 5)   (6 - 1)
helper 5  8  5  = helper (8)  (5 + 8)   (5 - 1)
helper 8  13 4  = helper (13) (8 + 13)  (4 - 1)
helper 13 21 3  = helper (21) (13 + 21) (3 - 1)
helper 21 34 2  = helper (34) (21 + 34) (2 - 1)
helper 34 55 1  = helper (55) (34 + 55) (1 - 1)
helper 55 89 0  = 55
```

## 1.6 Локальные связывания и правила отступов

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



# 2. Основы программирования


## 2.1 Параметрический полиморфизм

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 2.2 Параметрический полиморфизм (2)

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 2.3 Классы типов

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 2.4 Стандартные классы типов

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 2.5 Нестрогая семантика

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 2.6 Модули и компиляция

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



# 3. Списки


## 3.1 Функции для работы со списками

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 3.2 Функции высших порядков над списками

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 3.3 Генераторы списков

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 3.4 Правая свертка

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 3.5 Левая свертка и ее сравнение с правой

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 3.6 Родственные сверткам функции

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



# 4. Типы данных


## 4.1 Типы перечислений

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.2 Типы произведений и сумм произведений

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.3 Синтаксис записей

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.4 Типы с параметрами

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.5 Рекурсивные типы данных

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.6 Синонимы и обертки для типов

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:


# 5. Монады


## 5.1 Класс типов Functor и законы для него

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.2 Определение монады

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.3 Монада Identity

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.4 Список и Maybe как монады

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.5 Монада IO

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.6 Монада Reader

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.7 Монада Writer

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.8 Монада State

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:


