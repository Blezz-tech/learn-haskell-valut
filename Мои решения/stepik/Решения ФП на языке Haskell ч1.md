# 1. Введение


## 1.1 Установка и настройка среды

### Задание 1

Устанавливал не Haskell Platform, а ghcup

Тем не менее ответ:

```
*Main>
```

## 1.2 Функции

### Задание 1

В стандартной библиотеке Haskell есть функция вычисления логарифма по произвольному основанию `logBase`. Это функция двух переменных, которой требуется передать основание логарифма и аргумент, на котором логарифм будет вычислен. Какие из следующих вызовов обеспечат вычисление логарифма по основанию 2 от 8?

Ответ:

- [x] (logBase 2) 8
- [ ] logBase (2, 8)
- [ ] logBase (2 8)
- [ ] (logBase, 2, 8)
- [x] logBase 2 8

### Задание 2

Реализуйте функцию трех аргументов `lenVec3`, которая вычисляет длину трехмерного вектора. Аргументы функции задают декартовы координаты конца вектора, его начало подразумевается находящимся в начале координат. Для извлечения квадратного корня воспользуйтесь функцией `sqrt`, определенной в стандартной библиотеке.

```haskell
GHCi> lenVec3 2 3 6
7.0
```

Ответ:

```haskell
lenVec3 x y z = sqrt $ x^2 + y^2 + z^2
```

### Задание 3

Напишите реализацию функции `sign`, которая возвращает 1, если ей передано положительное число, (-1), если отрицательное, и 0 в случае, когда передан 0.

```haskell
GHCi> sign (-100)
-1
```

Ответ:

```haskell
sign x | x == 0    =  0
       | x <  0    = -1
       | otherwise =  1
```

или

```haskell
sign = signum
```

### Задание 4

Предположим, мы разрабатываем на Haskell интерфейс системы перевода для естественных языков. Он должен содержать функцию `translate` с параметрами `text`, `languageFrom` и `languageTo`. Расположите параметры в таком порядке, чтобы было удобно реализовывать следующие функции: `translateFromSpanishToRussian`, `translateFromEnglishToRussian` и `translateToRussian`.

Ответ:

- [ ] translate languageFrom text languageTo
- [ ] translate languageTo text languageFrom
- [ ] translate text languageTo languageFrom
- [ ] translate text languageFrom languageTo
- [ ] translate languageFrom languageTo
- [x] texttranslate languageTo languageFrom text

## 1.3 Операторы

### Задание 1

Попробуйте вычислить значение выражения `2 ^ 3 ^ 2`, не используя GHCi.

Ответ: `512`

### Задание 2

Попробуйте вычислить значение выражения `(*) 2 ((+) 1 4) ^ 2`, не используя GHCi.

Ответ: `100`

### Задание 3

Используя данное выше определение оператора `(*+*)`:

```haskell
infixl 6 *+*
(*+*) a b = a ^ 2 + b ^ 2
```

попробуйте устно вычислить значение выражения `1 + 3 *+* 2 * 2`.

Ответ: `32`

### Задание 4

Реализуйте оператор `|-|`, который возвращает модуль разности переданных ему аргументов:

```haskell
GHCi>  5 |-| 7
2
```

Ответ:

```haskell
x |-| y = abs $ x - y
```

### Задание 5

Попробуйте вычислить значение выражения ``(`mod` 14) ((+ 5) 10)``, не используя GHCi. (Функция `mod` возвращает остаток от целочисленного деления первого своего аргумента на второй.)

Ответ: `1`

### Задание 6

Используя оператор `$`, перепишите выражение `logBase 4 (min 20 (9 + 7))` без скобок. (Разделяйте все токены одним пробелом.)

```haskell
logBase 4 $ min 20 $ 9 + 7
```

## 1.4 Базовые типы

### Задание 1

Какие из следующих выражений типизированы верно, то есть не приводят к ошибкам типа?

Ответ:

- [ ] (3.0 :: Integer) + (5 :: Integer)
- [x] (3 :: Integer) + (5 :: Integer)
- [x] (3.2 :: Double) + (5 :: Double)
- [ ] (3 :: Int) + (5 :: Integer)
- [ ] (3 :: Double) + (5 :: Float)

### Задание 2

Вспомним функцию `discount`, которая возвращала итоговую сумму покупки с возможной скидкой. В качестве параметров ей передавались сумма без скидки `sum`, процент скидки `proc`, причем скидка начислялась, если переданная сумма превышает порог `limit`. Все эти параметры, как и возвращаемое значение, можно хранить в типе `Double`. (Здесь следует отметить, что в реальных финансовых приложениях использовать тип с плавающей точкой для хранения подобной информации не рекомендуется.) Тип функции можно задать в файле исходного кода вместе с ее определением:

```haskell
discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
```

Отметим, что объявление типа необязательно, хотя часто рекомендуется в качестве документации. Его обычно располагают перед определением функции, хотя это объявление верхнего уровня можно расположить в любом месте файла с исходным кодом.

Запишите тип функции `standardDiscount`, определенной как частичное применение функции `discount`:

```haskell
standardDiscount :: ???
standardDiscount = discount 1000 5 
```

Ответ:

```haskell
discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum

standardDiscount :: Double -> Double
standardDiscount = discount 1000 5
```

### Задание 3

Воспользовавшись справочной системой [Hoogle](https://www.haskell.org/hoogle/), найдите имя функции типа `Char -> Char`, переводящей символ в нижний регистр.

Ответ: `toLower`

### Задание 4

Реализуйте функцию `twoDigits2Int`, которая принимает два символа и возвращает число, составленное из этих символов, если оба символа числовые, и 100 в противном случае. (Первый символ рассматривается как количество десятков, второй — единиц.)

```haskell
GHCi> twoDigits2Int '4' '2'
42
```

Ответ:

```haskell
import Data.Char
twoDigits2Int :: Char -> Char -> Int
twoDigits2Int x y | isDigit x && isDigit y = digitToInt x * 10 + digitToInt y
                  | otherwise = 100
```

### Задание 5

Будем задавать точки на плоскости парами типа `(Double, Double)`. Реализуйте функцию `dist`, которая возвращает расстояние между двумя точками, передаваемыми ей в качестве аргументов.

```haskell
dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = ???
```

Ответ:

```haskell
dist :: (Double, Double) -> (Double, Double) -> Double
dist (x1, y1) (x2, y2) = sqrt $ (x2 - x1)^2 + (y2 - y1)^2
```

### Задание 6

Операторы `(:)` и `(++)` имеют одинаковую ассоциативность и приоритет. Укажите их. (Воспользуйтесь командой интерпретатора GHCi `:info`).

Ответ:

- [ ] infix 6
- [ ] infix 5
- [ ] infixl 6
- [ ] infixl 5
- [x] infixr 5
- [ ] infixr 6


### Задание 7

Не используя GHCi, выберите выражения, проходящие проверку типов.

Ответ:

- [x] [1,2] ++ (:) 3 [4,5,6]
- [ ] (++) [1,2] 3 : [4,5,6]
- [ ] (:) 1 (++) [2,3] [4,5,6]
- [x] (:) 1 ((++) [2,3] [4,5,6])
- [ ] [1,2] ++ [3,4,5] : 6
- [ ] [1,2] : 3 ++ [4,5,6]
- [x] [1,2] ++ 3 : [4,5,6]
- [x] 1 : [2,3] ++ [4,5,6]

## 1.5 Рекурсия

### Задание 1

Определите функцию, вычисляющую двойной факториал, то есть произведение натуральных чисел, не превосходящих заданного числа и имеющих ту же четность. Например: 7!!=7⋅5⋅3⋅17!!=7⋅5⋅3⋅1,  8!!=8⋅6⋅4⋅28!!=8⋅6⋅4⋅2. Предполагается, что аргумент функции может принимать только неотрицательные значения.

Ответ:

```haskell
doubleFact :: Integer -> Integer
doubleFact 1 = 1
doubleFact 2 = 2
doubleFact n = n * doubleFact (n - 2)
```

### Задание 2

В последнем примере предыдущего шага в охранном выражении использовался идентификатор `otherwise`. Это не ключевое слово, а константа, определенная для удобства в стандартной библиотеке:

```haskell
otherwise = ?
```

Как вы думаете, какова правая часть её определения?

Ответ: `True`

### Задание 3

Последовательность чисел Фибоначчи 0,1,1,2,3,5,8,13,2... легко определить рекурсивно, задав два первых терминирующих значения и определив любое последующее как сумму двух непосредственно предыдущих:

$F_0=0$

$F_1=1$

$F_n = F_{n-1} + F_{n-2}$

На Haskell данное определение задаётся следующей функцией:  

```haskell
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)
```

Эта функция определена лишь для неотрицательных чисел. Однако, из данного выше определения можно вывести формулу для вычисления чисел Фибоначчи при отрицательных индексах, при этом последовательность будет следующей:

$F_{-1}=1,F_{-2}=-1,...,F_{-10}=-55,...$

Измените определение функции `fibonacci` так, чтобы она была определена для всех целых чисел и порождала при отрицательных аргументах указанную последовательность.

Подсказка:

| $n$ | $F_n$ |
| --- | ----- |
| ... | ...   |
| -10 | -55   |
| -9  | 34    |
| -8  | -21   |
| -7  | 13    |
| -6  | -8    |
| -5  | 5     |
| -4  | -3    |
| -3  | 2     |
| -2  | -1    |
| -1  | 1     |
| 0   | 0     |
| 1   | 1     |
| 2   | 1     |
| 3   | 2     |
| 4   | 3     |
| 5   | 5     |
| 6   | 8     |
| 7   | 13    |
| 8   | 21    |
| 9   | 34    |
| 10  | 55    | 
| ... | ...   |

[Обобщённые числа Фибоначчи](https://ru.wikipedia.org/wiki/Обобщённые_числа_Фибоначчи)

Ответ:

Мой:

```haskell
fibonacci :: Integer -> Integer
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n | n < 0     = (-1) ^ (1 - n) * fibonacci (-n)
            | otherwise = fibonacci (n - 1) + fibonacci (n - 2)
```

Лучший:

```haskell
fibonacci :: Integer -> Integer
fibonacci n | n > 1     = fibonacci (n - 1) + fibonacci (n - 2)
            | n < 0     = fibonacci (n + 2) - fibonacci (n + 1)
            | otherwise = n
```

### Задание 4

Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении, крайне неэффективна - количество вызовов функции растет экспоненциально с ростом значения аргумента. GHCi позволяет отслеживать использование памяти и затраты времени на вычисление выражения, для этого следует выполнить команду `:set +s`:

```haskell
GHCi> :set +s
GHCi> fibonacci 30
832040
(8.36 secs, 298293400 bytes)
```

С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию, имеющую линейную сложность (по числу рекурсивных вызовов). Как и в предыдущем задании, функция должна быть определена для всех целых чисел.

Ответ:

```haskell
fibonacci :: Integer -> Integer
fibonacci n | n == 0 = 0
            | n == 1 = 1
            | n > 0  = helper 0 1 n
            | n < 0  = (-1) ^ (1 - n) * ( helper 0 1 (-n)) 

helper acc1 _    0 = acc1
helper acc1 acc2 n = helper (acc2) (acc1 + acc2) (n - 1)
```

```haskell
fibonacci 10

helper 0  1  10 = helper (1)  (0 + 1)   (10 - 1)
helper 1  1  9  = helper (1)  (1 + 1)   (9 - 1)
helper 1  2  8  = helper (2)  (1 + 2)   (8 - 1)
helper 2  3  7  = helper (3)  (2 + 3)   (7 - 1)
helper 3  5  6  = helper (5)  (3 + 5)   (6 - 1)
helper 5  8  5  = helper (8)  (5 + 8)   (5 - 1)
helper 8  13 4  = helper (13) (8 + 13)  (4 - 1)
helper 13 21 3  = helper (21) (13 + 21) (3 - 1)
helper 21 34 2  = helper (34) (21 + 34) (2 - 1)
helper 34 55 1  = helper (55) (34 + 55) (1 - 1)
helper 55 89 0  = 55
```

## 1.6 Локальные связывания и правила отступов

### Задание 1

Не используя GHCi, определите строку, которая является значением выражения `(let x = 'w' in [x,'o',x]) ++ "!"`.

Ответ: `wow!`

### Задание 2

Реализуйте функцию `seqA`, находящую элементы следующей рекуррентной последовательности

$$
a_0=1;a_1=2;a_2=3;a_{k+3}=a_{k+2}+a_{k+1}-2a_k
$$

Попытайтесь найти эффективное решение.

```haskell
GHCi> seqA 301
1276538859311178639666612897162414
```

Ответ:

```haskell
seqA :: Integer -> Integer
seqA k 
  | k >= 0 = helper 1 2 3 k
  | otherwise = error "error seqA. n > 3"
   where
    helper a0 a1 a2 k 
      | k == 0    = a0
      | otherwise = helper (a1) (a2) (a2 + a1 - 2 * a0) (k - 1)
```

### Задание 3

Реализуйте функцию, находящую сумму и количество цифр десятичной записи заданного целого числа.

```haskell
sum'n'count :: Integer -> (Integer, Integer)
sum'n'count x = undefined
```

```haskell
GHCi> sum'n'count (-39)
(12,2)
```

Ответ:

```haskell
sum'n'count :: Integer -> (Integer, Integer)
sum'n'count x | x == 0    = (0, 1)
              | otherwise = helper (abs x) (0, 0)
  where
    helper x acc | x == 0    = acc 
                 | otherwise = helper (div x 10) (fst acc + (mod x 10), snd acc + 1)
```

### Задание 4

Реализуйте функцию, находящую значение определённого интеграла от заданной функции �f на заданном интервале [�,�][a,b] методом трапеций. (Используйте равномерную сетку; достаточно 1000 элементарных отрезков.)

```haskell
integration :: (Double -> Double) -> Double -> Double -> Double
integration f a b = undefined
```

```haskell
GHCi> integration sin pi 0
-2.0
```

Результат может отличаться от -2.0, но не более чем на 1e-4.

Ответ:

Моё:

```haskell
integration :: (Double -> Double) -> Double -> Double -> Double
integration f a b = let
    n = 1000000
    h =  if a < b then (b - a) / n else (a - b) / n
    helper f a b acc
      | a >= b     = h * acc
      | otherwise  = helper f (a + h) b (acc + (f a))
    in if h == 0 then
         f a
       else if a < b then
         helper f (a + h) (b - h) ((f a + f b) / 2)
       else
          -helper f (b + h) (a - h) ((f a + f b) / 2)
```

Лучшее:

```haskell
integration :: (Double -> Double) -> Double -> Double -> Double
integration f a b = h * ( (f a + f b)/2 + (sum $ map f xs) )
  where
    n = 1000
    h = (b-a)/n
    xs = [a+h*x | x <- [1..n-1]]
```

# 2. Основы программирования

## 2.1 Параметрический полиморфизм

### Задание 1

Напишите функцию трех аргументов `getSecondFrom`, полиморфную по каждому из них, которая полностью игнорирует первый и третий аргумент, а возвращает второй. Укажите ее тип.

```haskell
GHCi> getSecondFrom True 'x' "Hello"
'x'
GHCi> getSecondFrom 'x' 42 True 
42
```

Ответ:

```haskell
getSecondFrom :: a -> b -> c -> b
getSecondFrom x y z = y
```

### Задание 2

Сколько _разных_ всегда завершающихся функций с типом `a -> a -> b -> a -> a` можно реализовать?

Две функции одинаковой арности считаются _разными_, если существует набор значений их аргументов, на котором они дают разные результирующие значения.

Ответ: `3`

### Задание 3

В модуле `Data.Function` определена полезная функция высшего порядка

```haskell
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
on op f x y = f x `op` f y
```

Она принимает четыре аргумента: бинарный оператор с однотипными аргументами (типа `b`), функцию `f :: a -> b`, возвращающую значение типа `b`, и два значения типа `a`. Функция `on` применяет `f` дважды к двум значениям типа `a` и передает результат в бинарный оператор.

Используя `on` можно, например, записать функцию суммирования квадратов аргументов так:

```haskell
sumSquares = (+) `on` (^2)
```

Функция `multSecond`, перемножающая вторые элементы пар, реализована следующим образом

```haskell
multSecond = g `on` h

g = undefined

h = undefined
```

Напишите реализацию функций `g` и `h`.

```haskell
GHCi> multSecond ('A',2) ('E',7)
14
```

Ответ:

```haskell
import Data.Function

multSecond = g `on` h

g = (*)
h = snd
```

### Задание 4

Реализуйте функцию `on3`, имеющую семантику, схожую с `on`, но принимающую в качестве первого аргумента трехместную функцию:

```haskell
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = undefined
```

Например, сумма квадратов трех чисел может быть записана с использованием `on3` так

```haskell
GHCi> let sum3squares = (\x y z -> x+y+z) `on3` (^2)
GHCi> sum3squares 1 2 3
14
```

Ответ:

```haskell
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op (f x) (f y) (f z)
```

## 2.2 Параметрический полиморфизм (2)

### Задание 1

Функция одной переменной `doItYourself` выбирает наибольшее из переданного ей аргумента и числа 42, затем возводит результат выбора в куб и, наконец, вычисляет логарифм по основанию 2 от полученного числа. Эта функция реализована в виде:

```haskell
doItYourself = f . g . h
```

Напишите реализации функций `f`, `g` и `h`. Постарайтесь сделать это в бесточечном стиле.

```haskell
f = undefined

g = undefined

h = undefined
```

Ответ:

```haskell
doItYourself = f . g . h

f = logBase 2
g = (^3)
h = max 42
```

### Задание 2

Сколько разных всегда завершающихся функций с типом `a -> (a,b) -> a -> (b,a,a)` можно реализовать?

Ответ: `9`

### Задание 3

Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение `curry id`?

Ответ: `(,)`

### Задание 4

Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение `uncurry (flip const)`?

Ответ: `snd`

### Задание 5

В модуле `Data.Tuple` стандартной библиотеки определена функция `swap :: (a,b) -> (b,a)`, переставляющая местами элементы пары:

```haskell
GHCi> swap (1,'A')
('A',1)
```

Эта функция может быть выражена в виде:

```haskell
swap = f (g h)
```

где `f`, `g` и `h` — некоторые идентификаторы из следующего набора:

```no-highlight
curry uncurry flip (,) const
```

Укажите через запятую подходящую тройку `f,g,h`.

Ответ:

```haskell
uncurry,flip,(,)
```

## 2.3 Классы типов

### Задание 1

На нехватку какого представителя какого класса типов пожалуется интерпретатор при попытке вывести тип выражения

```haskell
True + False * False
```

Запишите ответ в виде _Имя_класса_типов Имя_типа_. Постарайтесь ответить, не используя GHCi.

Ответ: `Num Bool`

### Задание 2

Попробуйте, не используя GHCi или Hoogle, определить, какого контекста не хватает в типе функции

```haskell
sort :: ? => [d] -> [d]
```

сортирующей переданный в нее список. Напишите выражение, которое должно стоять на месте знака вопроса.

Ответ: `Ord d`

### Задание 3

Реализуйте класс типов `Printable`, предоставляющий один метод `toString` — функцию одной переменной, которая преобразует значение типа, являющегося представителем `Printable`, в строковое представление.

Сделайте типы данных `Bool` и `()` представителями этого класса типов, обеспечив следующее поведение:

```haskell
GHCi> toString True
"true"
GHCi> toString False
"false"
GHCi> toString ()
"unit type"
```

Ответ:

```haskell
class Printable a where
  toString :: a -> String

instance Printable () where
  toString () = "unit type"

instance Printable Bool where
  toString True  = "true"
  toString False = "false"
```

### Задание 4

Сделайте тип пары представителем класса типов `Printable`, реализованного вами в предыдущей задаче, обеспечив следующее поведение:

```haskell
GHCi> toString (False,())
"(false,unit type)"
GHCi> toString (True,False)
"(true,false)"
```

_Примечание._ Объявление класса типов `Printable` и представителей этого класса для типов `()` и  `Bool` заново реализовывать не надо — они присутствуют в программе, вызывающей ваш код.

Ответ:

```haskell
instance (Printable a, Printable b) => Printable (a, b) where
  toString (a, b) = "(" ++ toString a ++ "," ++ toString b ++ ")"
```


## 2.4 Стандартные классы типов

### Задание 1

Пусть существуют два класса типов `KnownToGork` и `KnownToMork`, которые предоставляют методы `stomp` (`stab`) и `doesEnrageGork` (`doesEnrageMork`) соответственно:

```haskell
class KnownToGork a where
    stomp :: a -> a
    doesEnrageGork :: a -> Bool

class KnownToMork a where
    stab :: a -> a
    doesEnrageMork :: a -> Bool
```

Класса типов `KnownToGorkAndMork` является расширением обоих этих классов, предоставляя дополнительно метод `stompOrStab`:

```haskell
class (KnownToGork a, KnownToMork a) => KnownToGorkAndMork a where
    stompOrStab :: a -> a
```

Задайте реализацию по умолчанию метода `stompOrStab`, которая вызывает метод `stomp`, если переданное ему значение приводит в ярость Морка; вызывает `stab`, если оно приводит в ярость Горка и вызывает сначала `stab`, а потом `stomp`, если оно приводит в ярость их обоих. Если не происходит ничего из вышеперечисленного, метод должен возвращать переданный ему аргумент.

Ответ:

```haskell
class KnownToGork a where
    stomp :: a -> a
    doesEnrageGork :: a -> Bool

class KnownToMork a where
    stab :: a -> a
    doesEnrageMork :: a -> Bool

class (KnownToGork a, KnownToMork a) => KnownToGorkAndMork a where
    stompOrStab :: a -> a
    stompOrStab a | doesEnrageMork a && not (doesEnrageGork a) = stomp a
                  | doesEnrageGork a && not (doesEnrageMork a) = stab a
                  | doesEnrageMork a && doesEnrageGork a = (stomp . stab) a
                  | otherwise = a
```

### Задание 2

Имея функцию `ip = show a ++ show b ++ show c ++ show d` определите значения `a`, `b`, `c`, `d` так, чтобы добиться следующего поведения:

```haskell
GHCi> ip
"127.224.120.12"
```

Ответ:

```haskell
a = 12
b = 7.22
c = 4.1
d = 20.12
```


### Задание 3

Реализуйте класс типов

```haskell
class SafeEnum a where
  ssucc :: a -> a
  spred :: a -> a
```

обе функции которого ведут себя как `succ` и `pred` стандартного класса `Enum`, однако являются тотальными, то есть не останавливаются с ошибкой на наибольшем и наименьшем значениях типа-перечисления соответственно, а обеспечивают циклическое поведение. Ваш класс должен быть расширением ряда классов типов стандартной библиотеки, так чтобы можно было написать реализацию по умолчанию его методов, позволяющую объявлять его представителей без необходимости писать какой бы то ни было код. Например, для типа `Bool` должно быть достаточно написать строку

```haskell
instance SafeEnum Bool
```

и получить возможность вызывать

```haskell
GHCi> ssucc False
True
GHCi> ssucc True
False
```

Ответ:

```haskell
class (Enum a, Bounded a, Eq a) => SafeEnum a where
  ssucc :: a -> a
  ssucc a | maxBound == a = minBound
          | otherwise = succ a

  spred :: a -> a
  spred a | minBound == a = maxBound
          | otherwise = pred a
```

### Задание 4

Напишите функцию с сигнатурой:

```haskell
avg :: Int -> Int -> Int -> Double
```

вычисляющую среднее значение переданных в нее аргументов:

```haskell
GHCi> avg 3 4 8
5.0
```

Ответ:

```haskell
avg :: Int -> Int -> Int -> Double
avg x y z = (/ 3) $ sum $ map fromIntegral [x, y, z]
```

## 2.5 Нестрогая семантика

### Задание 1

Предположим, что стандартные функции определены следующим образом:

```haskell
id x = x
const x y = x
max x y = if x <= y then y else x
infixr 0 $
f $ x = f x
```

Сколько редексов имеется в следующем выражении

```
const $ const (4 + 5) $ max 42
```

**Примечание.** Мы определили шаг вычислений как подстановку тела функции вместо ее имени с заменой _всех_ ее формальных параметров на фактически переданные ей выражения. Редексом при этом мы называем подвыражение, над которым можно осуществить подобный шаг.

Ответ: `3`

> Объяснение от Extrn:
> 
> Тем кто внимательно слушал лекции это и так покажется очевидным, но все же повторю
> 
> 1. Редекс - это часть выражения, которая полностью соответствует левой части какого-нибудь определения
> 2. Количество редексов в выражении это **НЕ** количество шагов, требуемых для его окончательного вычисления, это **количество вариантов подстановки**, одним из которых мы можем воспользоваться здесь и сейчас
> 
> Например, выражение
> 
> ```haskell
> max 5 $ const 3 9
> ```
> 
> содержит два редекса: мы можем подставить выражение `const 3 9` в определение функции `const` и получим
> 
> ```
> const x y = x
> const 3 9 = 3
> ```
> 
> либо можем подставить выражение `max 5 $ const 3 9` в определение оператора `$` и получим
> 
> ```haskell
> f $ x = f x
> (max 5) $ (const 3 9) = (max 5) (const 3 9)
> ```
> 
> Итого имеем два варианта **для первого шага** подстановки
> 
> ```haskell
> max 5 $ 3           -- выполнили подстановку const
> (max 5) (const 3 9) -- выполнили подстановку $
> ```
> 
> Не важно, какой путь выбрал бы Haskell, нас просят посчитать **все возможные варианты для первого шага**.
> 
> Теперь вернемся к выражению из задания
> 
> ```haskell
> const $ const (4 + 5) $ max 42
> ```
> 
> Для начала расставим скобки для удобства
> 
> ```
> const $ ((const (4 + 5)) $ (max 42))
> ```
> 
> Именно так бы их расставил (у себя в голове) Haskell согласно правилам для оператора `$` (указано в задании - наименьший приоритет, правоассоциативный) и операции применения (наивысший приоритет, левоасоциативный)
> 
> Что мы можем здесь сделать? Можем осуществить подстановку первого оператора `$`
> 
> ```haskell
> const $ ((const (4 + 5)) $ (max 42)) = const ((const (4 + 5)) $ (max 42))
> ```
> 
> Второго оператора `$`
> 
> ```haskell
> (const (4 + 5)) $ (max 42) = (const (4 + 5)) (max 42)
> ```
> 
> и сложения
> 
> ```haskell
> 4 + 5 = 9
> ```
> 
> Определение сложения не дано в задании, но очевидно, что такое определение существует, и что это выражение тоже требует подстановки, ведь как-то мы должны из `4 + 5` получить `9`.
> 
> В итоге имеем три варианта для первого шага подстановки
> 
> ```haskell
> const ((const (4 + 5)) $ (max 42)) -- выполнили подстановку первого $
> const $ ((const (4 + 5)) (max 42)) -- выполнили подстановку второго $
> const $ ((const 9) $ (max 42))     -- выполнили подстановку сложения
> ```
> 
> А что насчет `const` и `max`? С ними мы **на первом шаге** не можем делать ничего. Определение обеих функций содержит два параметра, а в представленном выражении функции применены только частично, подстановку выполнить не получится.


### Задание 2

Сколько шагов редукции потребуется, чтобы вычислить значение функции `value`, если используется ленивая стратегия вычислений с механизмом разделения?

```haskell
bar x y z = x + y
foo a b = bar a a (a + b)
value = foo (3 * 10) (5 - 2)
```

_Примечание._ Подстановку тела функции `value` вместо `value` не считайте.

Ответ: `4`

> Объяснение от Extrn:
> 
> Также процесс редукции можно записать с помощью `let ... in`, на практике это гораздо удобнее, и так же позволяет сохранить все необходимые зависимости.
> 
> ```haskell
> value = 
>   let
>     a = 3 * 10
>     b = 5 - 2
>   in
>     bar a a (a + b)       -- подстановка foo
> ```
> 
> ```haskell
> value = 
>   let
>     a = 3 * 10
>     b = 5 - 2
>   in
>     a + a                 -- подстановка bar
> ```
> 
> ```haskell
> value = 
>   let
>     a = 30                -- подстановка произведения
>     b = 5 - 2
>   in
>     a + a
> ```
> 
> ```haskell
> value = 
>   let
>     a = 30
>     b = 5 - 2
>   in
>     60                    -- подстановка сложения
> ```

### Задание 3

Отметьте функции, которые не могут привести к расходимости ни на каком корректном наборе аргументов.

```haskell
foo a = a

bar = const foo

baz x = const True

quux = let x = x in x

corge = "Sorry, my value was changed"

grault x 0 = x
grault x y = x

garply = grault 'q'

waldo = foo
```

Ответ:

- [x] corge
- [ ] bar
- [ ] garply
- [ ] quux
- [ ] grault
- [ ] foo
- [x] baz
- [ ] waldo

### Задание 4

Какие из выражений ниже не находятся в нормальной форме, но находятся в слабой головной нормальной форме?

Ответ:

- [x] [undefined, 4 + 5, -1]
- [ ] \x -> x
- [ ] fst (1,0)
- [ ] 3
- [x] (,) undefined
- [x] (+) (2 * 3 * 4)

### Задание 5

При вычислении каких из перечисленных ниже функций использование `seq` предотвратит нарастание количества невычисленных редексов при увеличении значения первого аргумента:

```haskell
foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'

bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'

baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p
```

Ответ:

- [ ] foo
- [ ] bar
- [ ] baz
- [x] quux

### Задание 6

Ниже определены функции `mySum` и `goSum`. Вызов `goSum` может выглядеть, к примеру, так:  `goSum 15`. Выберите верные утверждения, описывающие процесс вычисления подобного выражения.

```haskell
mySum acc 0 = acc
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

goSum = mySum (0, ())
```

Ответ:

- [ ] В первом аргументе функции mySum не будут накапливаться отложенные вычисления, так как при рекурсивных вызовах используется оператор $!.
- [ ] В первом аргументе функции mySum не будут накапливаться отложенные вычисления, так как он будет находиться в слабой головной нормальной форме.
- [x] В первом аргументе функции mySum будут накапливаться отложенные вычисления.
- [ ] Во втором аргументе функции mySum будут накапливаться отложенные вычисления из-за того, что его передача при рекурсивном вызове происходит с помощью оператора $, а не $!.
- [x] Во втором аргументе функции mySum не будут накапливаться отложенные вычисления, так как при каждом рекурсивном вызове происходит сопоставление с 0.
- [ ] Во втором аргументе функции mySum не будут накапливаться отложенные вычисления, так как минус - примитивная операция.


## 2.6 Модули и компиляция

### Задание 1

Что произойдет при попытке загрузить данный модуль в GHCi?

```haskell
module Test where
import Data.List hiding (union)
import Data.Set

myUnion [] ys = ys
myUnion xs ys = union xs ys
```

Ответ:


- [ ] Все пройдет нормально
- [ ] Произойдет ошибка из-за неопределенности при выборе функции
- [x] Произойдет ошибка из-за несовпадения типа аргумента и ожидаемого типа функции

### Задание 2

Пусть модуль `Foo` содержит следующий код:

```haskell
module Foo (a, b) where

a = undefined
b = undefined
c = undefined
```

а модуль `Bar` такой:

```haskell
module Bar (a, d) where

import Foo (a, b)

d = undefined
```

Отметьте функции, доступные для использования после загрузки в модуле `Baz` со следующим кодом:  

```haskell
module Baz where

import Bar
```

Ответ:

- [x] a
- [x] d
- [ ] c
- [ ] b

# 3. Списки


## 3.1 Функции для работы со списками

### Задание 1

Реализуйте функцию `addTwoElements`, которая бы добавляла два переданных ей значения в голову переданного списка.

```haskell
GHCi> addTwoElements 2 12 [85,0,6]
[2,12,85,0,6]
```

Ответ:

Мой ответ:

```haskell
addTwoElements :: a -> a -> [a] -> [a]
addTwoElements x y xs = x : y : xs
```

Лучший:

```haskell
import Data.Function

addTwoElements :: a -> a -> [a] -> [a]
addTwoElements = (.) `on` (:)
```

### Задание 2

Реализуйте функцию `nTimes`, которая возвращает список, состоящий из повторяющихся значений ее первого аргумента. Количество повторов определяется значением второго аргумента этой функции.

```haskell
GHCi> nTimes 42 3
[42,42,42]
GHCi> nTimes 'z' 5
"zzzzz"
```

Ответ:

Моё:

```haskell
nTimes:: a -> Int -> [a]
nTimes x y = take y (repeat x)
```

Лучшее:

```haskell
nTimes:: a -> Int -> [a]
nTimes = flip replicate
```

### Задание 3

Исследуйте тип функции

```haskell
sndHead = snd . head
```

и разберитесь, каково ее поведение. Эту функцию можно реализовать, используя сопоставление с образцом

```haskell
sndHead некоторый_образец = x
```

Отметьте те образцы, которые подходят для этой цели.

Ответ:

- [ ] `((,) ((:) _ _) x)`
- [x] `((:) ((,) _ x) y)`
- [x] `((,) y x : z)`
- [ ] `((,) y z : x)`
- [ ] `((,) x y : z)`
- [x] `((_, x) : _)`

### Задание 4

Сформируйте список целых чисел, содержащий только те элементы исходного списка, значение которых нечетно.

```haskell
GHCi> oddsOnly [2,5,7,10,11,12]
[5,7,11]
```

Для анализа четности можно использовать функции `odd` и `even` стандартной библиотеки.

Ответ:

```haskell
oddsOnly :: Integral a => [a] -> [a]
oddsOnly = filter odd
```


### Задание 5

Реализуйте функцию `isPalindrome`, которая определяет, является ли переданный ей список палиндромом.

```haskell
GHCi> isPalindrome "saippuakivikauppias"
True
GHCi> isPalindrome [1]
True
GHCi> isPalindrome [1, 2]
False
```

Ответ:

```haskell
isPalindrome :: Eq a => [a] -> Bool
isPalindrome a = a == reverse a
```

### Задание 6

Составьте список сумм соответствующих элементов трех заданных списков. Длина результирующего списка должна быть равна длине самого длинного из заданных списков, при этом «закончившиеся» списки не должны давать вклада в суммы.

```haskell
GHCi> sum3 [1,2,3] [4,5] [6]
[11,7,3]
```

Ответ:

```haskell
sum3 :: Num a => [a] -> [a] -> [a] -> [a]
sum3 xs ys zs = xs `sum2` ys `sum2` zs
  where
    sum2 [] bs = bs
    sum2 as [] = as
    sum2 (a : as) (b : bs) = (a + b) : sum2 as bs
```

### Задание 7

Напишите функцию `groupElems` которая группирует одинаковые элементы в списке (если они идут подряд) и возвращает список таких групп.

```haskell
GHCi> groupElems []
[]
GHCi> groupElems [1,2]
[[1],[2]]
GHCi> groupElems [1,2,2,2,4]
[[1],[2,2,2],[4]]
GHCi> groupElems [1,2,3,2,4]
[[1],[2],[3],[2],[4]]
```

Разрешается использовать только функции, доступные из библиотеки `Prelude`.

Ответ:

Моё первое решение (Да... Я украл функцию из стандартной библиотеки):

```haskell
groupElems :: Eq a => [a] -> [[a]]
groupElems =  groupBy (==)

groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
groupBy _  []     =  []
groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
    where (ys,zs) = span (eq x) xs
```

Беспалевное решение:

```haskell
groupElems :: Eq a => [a] -> [[a]]
groupElems []     = []
groupElems (x:xs) = (x:ys) : groupElems zs
    where (ys,zs) = span (== x) xs
```

## 3.2 Функции высших порядков над списками

### Задание 1

Напишите функцию `readDigits`, принимающую строку и возвращающую пару строк.  
Первый элемент пары содержит цифровой префикс исходной строки, а второй - ее оставшуюся часть.

```haskell
GHCi> readDigits "365ads"
("365","ads")
GHCi> readDigits "365"
("365","")
```

В решении вам поможет функция `isDigit` из модуля `Data.Char`.

Ответ:

Моё:

```haskell
import Data.Char

readDigits :: String -> (String, String)
readDigits = break (not . isDigit)
```

Лучшее:

```haskell
import Data.Char

readDigits :: String -> (String, String)
readDigits = span isDigit
```

### Задание 2

Реализуйте функцию `filterDisj`, принимающую два унарных предиката и список, и возвращающую список элементов, удовлетворяющих хотя бы одному из предикатов.

```haskell
GHCi> filterDisj (< 10) odd [7,8,10,11,12]
[7,8,11]
```

Ответ:

```haskell
filterDisj :: (a -> Bool) -> (a -> Bool) -> [a] -> [a]
filterDisj pred1 pred2  xs = filter (\x -> pred1 x || pred2 x ) xs
```

### Задание 3

Напишите реализацию функции `qsort`. Функция `qsort` должная принимать на вход список элементов и сортировать его в порядке возрастания с помощью сортировки Хоара: для какого-то элемента `x` изначального списка (обычно выбирают первый) делить список на элементы меньше и не меньше `x`, и потом запускаться рекурсивно на обеих частях.

```haskell
GHCi> qsort [1,3,2,5]
[1,2,3,5]
```

Разрешается использовать только функции, доступные из библиотеки `Prelude`.

Ответ:

Моё (списано с Изучай хаскель во имя добра):

```haskell
qsort :: (Ord a) => [a] -> [a]
qsort [] = []
qsort (x:xs) =
  let smallerSorted = qsort [a | a <- xs, a <= x]
      biggerSorted = qsort [a | a <- xs, a > x]
  in smallerSorted ++ (x : biggerSorted)
```

Лучшее:

```haskell
qsort [] = []
qsort :: Ord a => [a] -> [a]
qsort (x:xs) = qsort (filter (<x) xs) ++ (x : qsort (filter (>=x) xs))
```

### Задание 4

Напишите функцию `squares'n'cubes`, принимающую список чисел,  
и возвращающую список квадратов и кубов элементов исходного списка.

```haskell
GHCi> squares'n'cubes [3,4,5]
[9,27,16,64,25,125]
```

Ответ:

Моё:

```haskell
squares'n'cubes :: Num a => [a] -> [a]
squares'n'cubes = foldr (\x accum -> x^2 : x^3 : accum) []
```

Лучшее:

```haskell
squares'n'cubes :: Num a => [a] -> [a]
squares'n'cubes = concatMap (\x -> [x ^ 2, x ^ 3])
```

```haskell
squares'n'cubes :: Num a => [a] -> [a]
squares'n'cubes [] = []
squares'n'cubes (x:xs) = x^2 : x^3 : squares'n'cubes xs
```

### Задание 5

Воспользовавшись функциями `map` и `concatMap`, определите функцию `perms`, которая возвращает все перестановки, которые можно получить из данного списка, в любом порядке.

```haskell
GHCi> perms [1,2,3]
[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

Считайте, что все элементы в списке уникальны, и что для пустого списка имеется одна перестановка.

Ответ (Украл, уж лучше пойду дальше, чем буду биться над одной задачей):

```haskell
perms :: [a] -> [[a]]
perms []     = [[]]
perms (x:xs) = [y | p <- perms xs, y <- interleave p]
  where
    interleave []     = [[x]]
    interleave (y:ys) = (x:y:ys) : map (y:) (interleave ys)
```

Лучшее:

```haskell
perms :: [a] -> [[a]]
perms [] = [[]]
perms [x] = [[x]]
perms (x:xs) = concatMap (insertElem x) (perms xs) where
			insertElem x [] = [[x]]
			insertElem x yss@(y:ys) = (x:yss) : map (y:) (insertElem x ys)
```

Пояснение:

Поскольку, это именно то решение, которое мы ожидали, давайте я поясню здесь для будущих читателей, как оно работает.

Идея состоит в том, чтобы сгенерировать все перестановки рекурсивно. Для этого мы вызываем `perms xs` и, по предположению, получаем все перестановки для хвоста нашего списка. Например, если список был `[1, 2, 3]`, мы получили все перестановки списка `[2, 3]`, то есть `[[2, 3], [3, 2]]`. Теперь надо преобразовать этот ответ для хвоста в ответ для нашего исходного списка. Для этого требуется недостающий элемент `1` вставить всеми возможными способами в полученные перестановки.

Чтобы сделать это, мы реализуем функцию `insertElem x xs`, которая вставляет `x` во все позиции списка `xs`, то есть, первым элементом, между первым и вторым, между вторым и третьим, и так далее. Эта функция тоже работает рекурсивно.

Таким образом, `insertElem 1 [2,3] = [[1,2,3], [2,1,3], [2,3,1]]`, а `insertElem 1 [3,2] = [[1,3,2], [3,1,2], [3,2,1]]`. Соответственно, остается только применить функцию `insertElem x` к полученным рекурсивно перестановкам хвоста и сплющить полученный список, для чего и подходит функция `concatMap`.

### Задание 6

Реализуйте функцию `delAllUpper`, удаляющую из текста все слова, целиком состоящие из символов в верхнем регистре. Предполагается, что текст состоит только из символов алфавита и пробелов, знаки пунктуации, цифры и т.п. отсутствуют.

```haskell
GHCi> delAllUpper "Abc IS not ABC"
"Abc not"
```

Постарайтесь реализовать эту функцию как цепочку композиций, аналогично `revWords` из предыдущего видео.

Ответ:

Моё:

```haskell
import Data.Char (isUpper) 
​
delAllUpper :: String -> String
delAllUpper = unwords . filter (not . all isUpper) . words
```

Лучшее:

```haskell
import Data.Char (isLower) 

delAllUpper :: String -> String
delAllUpper = unwords . filter (any isLower) . words
```

### Задание 7

Напишите функцию `max3`, которой передаются три списка одинаковой длины и которая возвращает список той же длины, содержащий на k-ой позиции наибольшее значение из величин на этой позиции в списках-аргументах.

```haskell
GHCi> max3 [7,2,9] [3,6,8] [1,8,10]
[7,8,10]
GHCi> max3 "AXZ" "YDW" "MLK"
"YXZ"
```

Ответ:

Моё:

```haskell
max3 :: Ord a => [a] -> [a] -> [a] -> [a]
max3 x y z = map (\ (x, y, z) -> max z $ max x y) $ zip3 x y z
```

Лучшее:

```haskell
max3 :: Ord a => [a] -> [a] -> [a] -> [a]
max3 = zipWith3 ((max .) . max)
```


## 3.3 Генераторы списков

### Задание 1

Реализуйте c использованием функции `zipWith` функцию `fibStream`, возвращающую бесконечный список чисел Фибоначчи.

```haskell
GHCi> take 10 $ fibStream
[0,1,1,2,3,5,8,13,21,34]
```

Ответ:

```haskell
fibStream :: [Integer]
fibStream = 0 : 1 : zipWith (+) fibStream (tail fibStream)
```

### Задание 2

Предположим, что функция `repeat`, была бы определена следующим образом:

```haskell
repeat = iterate repeatHelper
```

определите, как должна выглядеть функция `repeatHelper`.

Ответ:

```haskell
repeatHelper = id
```

### Задание 3

Пусть задан тип `Odd` нечетных чисел следующим образом:

```haskell
data Odd = Odd Integer 
  deriving (Eq, Show)
```

Сделайте этот тип представителем класса типов `Enum`.

```haskell
GHCi> succ $ Odd (-100000000000003)
Odd (-100000000000001)
```

Конструкции с четным аргументом, типа `Odd 2`, считаются недопустимыми и не тестируются.

_Примечание._ Мы еще не знакомились с объявлениями пользовательских типов данных, однако, скорее всего, приведенное объявление не вызовет сложностей. Здесь объявляется тип данных `Odd` с конструктором `Odd`. Фактически это простая упаковка для типа `Integer`. Часть `deriving (Eq, Show)` указывает компилятору, чтобы он автоматически сгенерировал представителей соответствующих классов типов для нашего типа (такая возможность имеется для ряда стандартных классов типов). Значения типа `Odd` можно конструировать следующим образом:

```haskell
GHCi> let x = Odd 33
GHCi> x
Odd 33
```

и использовать конструктор данных `Odd` в сопоставлении с образцом:

```haskell
addEven :: Odd -> Integer -> Odd
addEven (Odd n) m | m `mod` 2 == 0 = Odd (n + m)
                  | otherwise      = error "addEven: second parameter cannot be odd"
```

Ответ:

```haskell
instance Enum Odd where
  succ (Odd x) = Odd $ x + 2
  pred (Odd x) = Odd $ x - 2
  toEnum x = Odd $ toInteger x * 2 + 1
  fromEnum (Odd x) = quot (fromInteger x - 1) 2
  enumFrom = iterate succ
  enumFromThen (Odd x) (Odd y) = map Odd [x, y ..]
  enumFromTo (Odd x) (Odd y) = map Odd [x, x + 2 .. y]
  enumFromThenTo (Odd x) (Odd y) (Odd z) = map Odd [x , y .. z]
```

### Задание 4

Пусть есть список положительных достоинств монет `coins`, отсортированный по возрастанию. Воспользовавшись механизмом генераторов списков, напишите функцию `change`, которая разбивает переданную ей положительную сумму денег на монеты достоинств из списка `coins` всеми возможными способами. Например, если `coins = [2, 3, 7]`:

```haskell
GHCi> change 7
[[2,2,3],[2,3,2],[3,2,2],[7]]
```

_Примечание_. Порядок монет в каждом разбиении имеет значение, то есть наборы `[2,2,3]` и `[2,3,2]` — различаются.
Список coins определять не надо.


Ответ:

```haskell
change :: (Ord a, Num a) => a -> [[a]]
change n | n < 0     = []
         | n == 0    = [[]]
         | otherwise = [ x : xs | x <- coins, xs <- change (n - x) ]
```

## 3.4 Правая свертка

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 3.5 Левая свертка и ее сравнение с правой

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 3.6 Родственные сверткам функции

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



# 4. Типы данных


## 4.1 Типы перечислений

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.2 Типы произведений и сумм произведений

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.3 Синтаксис записей

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.4 Типы с параметрами

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.5 Рекурсивные типы данных

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 4.6 Синонимы и обертки для типов

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:


# 5. Монады


## 5.1 Класс типов Functor и законы для него

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.2 Определение монады

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.3 Монада Identity

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.4 Список и Maybe как монады

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.5 Монада IO

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.6 Монада Reader

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.7 Монада Writer

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:



## 5.8 Монада State

### Задание 1


Ответ:


### Задание 2


Ответ:


### Задание 3


Ответ:


### Задание 4


Ответ:


### Задание 5


Ответ:


### Задание 6


Ответ:


### Задание 7


Ответ:


