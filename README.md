
[Ссылка на сайт откуда был взят курс](https://coda.io/@metalamp/education/back-end-3)

Курс будет пройден не полностью за время практики, так как рассчитан на 1 год
Основная цель - сделать бота из [Задания 3](https://coda.io/@metalamp/education/3-14)

---
# Задание 1.1 Первичная теория

- [x] [Установка Haskell](https://coda.io/@metalamp/education/1-12#:~:text=%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%B0%D1%82%D1%8B-,%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%9F%D0%9E,-%D0%A0%D0%B5%D0%BA%D0%BE%D0%BC%D0%B5%D0%BD%D0%B4%D1%83%D0%B5%D0%BC%20%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D1%8C)
- [ ] [О Haskell по-человечески](https://www.ohaskell.guide/) Итого 23 \* 30 = 690 мин = 11,5 часов
	- [x] [Приветствие](https://www.ohaskell.guide/init.html)
	- [x] [Первые вопросы](https://www.ohaskell.guide/haskell-faq.html)
	- [x] [Об этой книге](https://www.ohaskell.guide/this-book.html)
	- [x] [Приготовимся](https://www.ohaskell.guide/setup.html)
	- [x] [Киты и Черепаха](https://www.ohaskell.guide/whales-n-turtle.html)
	- [x] [Неизменность и чистота](https://www.ohaskell.guide/immutability-n-purity.html)
	- [x] [Выбираем и возвращаемся](https://www.ohaskell.guide/if-n-return.html)
	- [x] [Выбор и образцы](https://www.ohaskell.guide/choose-n-patterns.html)
	- [x] [Пусть будет там, Где…](https://www.ohaskell.guide/let-n-where.html)
	- [x] [Мир операторов](https://www.ohaskell.guide/operators.html)
	- [x] [Список](https://www.ohaskell.guide/list.html)
	- [x] [Кортеж](https://www.ohaskell.guide/tuple.html)
	- [x] [Лямбда-функция](https://www.ohaskell.guide/lambda-function.html)
	- [x] [Композиция функций](https://www.ohaskell.guide/function-composition.html)
	- [x] [ФВП](https://www.ohaskell.guide/hof.html)
	- [x] [Hackage и библиотеки](https://www.ohaskell.guide/hackage.html)
	- [x] [Рекурсия](https://www.ohaskell.guide/recursion.html)
	- [x] [Лень](https://www.ohaskell.guide/laziness.html)
	- [x] [Наши типы](https://www.ohaskell.guide/own-types.html)
	- [x] [АТД](https://www.ohaskell.guide/adt.html)
	- [x] [АТД: поля с метками](https://www.ohaskell.guide/adt-field-labels.html)
	- [x] [Новый тип](https://www.ohaskell.guide/newtype.html)
	- [x] [Конструктор типа](https://www.ohaskell.guide/type-constructor.html)
	- [x] Конец книги 0 мин
- [ ] [Пройти учебник на английском](http://learnyouahaskell.com/chapters) Итого 1110 мин = 18,5 часов
	- [ ] [Introduction](http://learnyouahaskell.com/introduction) 45 мин
		- [ ] [About this tutorial](http://learnyouahaskell.com/introduction#about-this-tutorial) 15 мин
		- [ ] [So what's Haskell?](http://learnyouahaskell.com/introduction#so-whats-haskell) 15 мин
		- [ ] [What you need to dive in](http://learnyouahaskell.com/introduction#what-you-need) 15 мин
	- [ ] [Starting Out](http://learnyouahaskell.com/starting-out) 90 мин
		- [ ] [Ready, set, go!](http://learnyouahaskell.com/starting-out#ready-set-go) 15 мин
		- [ ] [Baby's first functions](http://learnyouahaskell.com/starting-out#babys-first-functions) 15 мин
		- [ ] [An intro to lists](http://learnyouahaskell.com/starting-out#an-intro-to-lists) 15 мин
		- [ ] [Texas ranges](http://learnyouahaskell.com/starting-out#texas-ranges) 15 мин
		- [ ] [I'm a list comprehension](http://learnyouahaskell.com/starting-out#im-a-list-comprehension) 15 мин
		- [ ] [Tuples](http://learnyouahaskell.com/starting-out#tuples) 15 мин
	- [ ] [Types and Typeclasses](http://learnyouahaskell.com/types-and-typeclasses) 45 мин
		- [ ] [Believe the type](http://learnyouahaskell.com/types-and-typeclasses#believe-the-type) 15 мин
		- [ ] [Type variables](http://learnyouahaskell.com/types-and-typeclasses#type-variables) 15 мин
		- [ ] [Typeclasses 101](http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101) 15 мин
	- [ ] [Syntax in Functions](http://learnyouahaskell.com/syntax-in-functions) 75 мин
		- [ ] [Pattern matching](http://learnyouahaskell.com/syntax-in-functions#pattern-matching) 15 мин
		- [ ] [Guards, guards!](http://learnyouahaskell.com/syntax-in-functions#guards-guards) 15 мин
		- [ ] [Where!?](http://learnyouahaskell.com/syntax-in-functions#where) 15 мин
		- [ ] [Let it be](http://learnyouahaskell.com/syntax-in-functions#let-it-be) 15 мин
		- [ ] [Case expressions](http://learnyouahaskell.com/syntax-in-functions#case-expressions) 15 мин
	- [ ] [Recursion](http://learnyouahaskell.com/recursion) 75 мин
		- [ ] [Hello recursion!](http://learnyouahaskell.com/recursion#hello-recursion) 15 мин
		- [ ] [Maximum awesome](http://learnyouahaskell.com/recursion#maximum-awesome)15 мин
		- [ ] [A few more recursive functions](http://learnyouahaskell.com/recursion#a-few-more-recursive-functions) 15 мин
		- [ ] [Quick, sort!](http://learnyouahaskell.com/recursion#quick-sort) 15 мин
		- [ ] [Thinking recursively](http://learnyouahaskell.com/recursion#thinking-recursively) 15 мин
	- [ ] [Higher Order Functions](http://learnyouahaskell.com/higher-order-functions) 105 мин
		- [ ] [Curried functions](http://learnyouahaskell.com/higher-order-functions#curried-functions) 15 мин
		- [ ] [Some higher-orderism is in order](http://learnyouahaskell.com/higher-order-functions#higher-orderism) 15 мин
		- [ ] [Maps and filters](http://learnyouahaskell.com/higher-order-functions#maps-and-filters) 15 мин
		- [ ] [Lambdas](http://learnyouahaskell.com/higher-order-functions#lambdas) 15 мин
		- [ ] [Only folds and horses](http://learnyouahaskell.com/higher-order-functions#folds) 15 мин
		- [ ] [Function application with $](http://learnyouahaskell.com/higher-order-functions#function-application) 15 мин
		- [ ] [Function composition](http://learnyouahaskell.com/higher-order-functions#composition) 15 мин
	- [ ] [Modules](http://learnyouahaskell.com/modules) 90 мин
		- [ ] [Loading modules](http://learnyouahaskell.com/modules#loading-modules) 15 мин
		- [ ] [Data.List](http://learnyouahaskell.com/modules#data-list) 15 мин
		- [ ] [Data.Char](http://learnyouahaskell.com/modules#data-char) 15 мин
		- [ ] [Data.Map](http://learnyouahaskell.com/modules#data-map) 15 мин
		- [ ] [Data.Set](http://learnyouahaskell.com/modules#data-set) 15 мин
		- [ ] [Making our own modules](http://learnyouahaskell.com/modules#making-our-own-modules) 15 мин
	- [ ] [Making Our Own Types and Typeclasses](http://learnyouahaskell.com/making-our-own-types-and-typeclasses) 150 мин
		- [ ] [Algebraic data types intro](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types) 15 мин
		- [ ] [Record syntax](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax) 15 мин
		- [ ] [Type parameters](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-parameters) 15 мин
		- [ ] [Derived instances](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#derived-instances) 15 мин
		- [ ] [Type synonyms](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-synonyms) 15 мин
		- [ ] [Recursive data structures](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures) 15 мин
		- [ ] [Typeclasses 102](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102) 15 мин
		- [ ] [A yes-no typeclass](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#a-yes-no-typeclass) 15 мин
		- [ ] [The Functor typeclass](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass) 15 мин
		- [ ] [Kinds and some type-foo](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo) 15 мин
	- [ ] [Input and Output](http://learnyouahaskell.com/input-and-output) 90 мин
		- [ ] [Hello, world!](http://learnyouahaskell.com/input-and-output#hello-world) 15 мин
		- [ ] [Files and streams](http://learnyouahaskell.com/input-and-output#files-and-streams) 15 мин
		- [ ] [Command line arguments](http://learnyouahaskell.com/input-and-output#command-line-arguments) 15 мин
		- [ ] [Randomness](http://learnyouahaskell.com/input-and-output#randomness) 15 мин
		- [ ] [Bytestrings](http://learnyouahaskell.com/input-and-output#bytestrings) 15 мин
		- [ ] [Exceptions](http://learnyouahaskell.com/input-and-output#exceptions) 15 мин
	- [ ] [Functionally Solving Problems](http://learnyouahaskell.com/functionally-solving-problems) 30 мин
		- [ ] [Reverse Polish notation calculator](http://learnyouahaskell.com/functionally-solving-problems#reverse-polish-notation-calculator) 15 мин
		- [ ] [Heathrow to London](http://learnyouahaskell.com/functionally-solving-problems#heathrow-to-london) 15 мин
	- [ ] [Functors, Applicative Functors and Monoids](http://learnyouahaskell.com/functors-applicative-functors-and-monoids) 60 мин
		- [ ] [Functors redux](http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux) 15 мин
		- [ ] [Applicative functors](http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors) 15 мин
		- [ ] [The newtype keyword](http://learnyouahaskell.com/functors-applicative-functors-and-monoids#the-newtype-keyword) 15 мин
		- [ ] [Monoids](http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids) 15 мин
	- [ ] [A Fistful of Monads](http://learnyouahaskell.com/a-fistful-of-monads) 90 мин
		- [ ] [Getting our feet wet with Maybe](http://learnyouahaskell.com/a-fistful-of-monads#getting-our-feet-wet-with-maybe) 15 мин
		- [ ] [The Monad type class](http://learnyouahaskell.com/a-fistful-of-monads#the-monad-type-class) 15 мин
		- [ ] [Walk the line](http://learnyouahaskell.com/a-fistful-of-monads#walk-the-line) 15 мин
		- [ ] [do notation](http://learnyouahaskell.com/a-fistful-of-monads#do-notation) 15 мин
		- [ ] [The list monad](http://learnyouahaskell.com/a-fistful-of-monads#the-list-monad) 15 мин
		- [ ] [Monad laws](http://learnyouahaskell.com/a-fistful-of-monads#monad-laws) 15 мин
	- [ ] [For a Few Monads More](http://learnyouahaskell.com/for-a-few-monads-more) 90 мин
		- [ ] [Writer? I hardly know her!](http://learnyouahaskell.com/for-a-few-monads-more#writer) 15 мин
		- [ ] [Reader? Ugh, not this joke again.](http://learnyouahaskell.com/for-a-few-monads-more#reader) 15 мин
		- [ ] [Tasteful stateful computations](http://learnyouahaskell.com/for-a-few-monads-more#state) 15 мин
		- [ ] [Error error on the wall](http://learnyouahaskell.com/for-a-few-monads-more#error) 15 мин
		- [ ] [Some useful monadic functions](http://learnyouahaskell.com/for-a-few-monads-more#useful-monadic-functions) 15 мин
		- [ ] [Making monads](http://learnyouahaskell.com/for-a-few-monads-more#making-monads) 15 мин
	- [ ] [Zippers](http://learnyouahaskell.com/zippers) 75 мин
		- [ ] [Taking a walk](http://learnyouahaskell.com/zippers#taking-a-walk) 15 мин
		- [ ] [A trail of breadcrumbs](http://learnyouahaskell.com/zippers#a-trail-of-breadcrumbs) 15 мин
		- [ ] [Focusing on lists](http://learnyouahaskell.com/zippers#focusing-on-lists) 15 мин
		- [ ] [A very simple file system](http://learnyouahaskell.com/zippers#a-very-simple-file-system) 15 мин
		- [ ] [Watch your step](http://learnyouahaskell.com/zippers#watch-your-step) 15 мин


---
# Задание 1.2 Первичная практика

- [ ] [Codewars](https://www.codewars.com/kata/search/haskell) Выполнение обязательных ката на codewars **неизвестно** мин
	- [ ] [Is this a triangle](https://www.codewars.com/kata/is-this-a-triangle) **неизвестно** мин^[Определение, могут ли данных три числа быть длинами сторон треугольника.
		  С этой катой тренируются базовые логические конструкции. Полезно, что есть простор и для элегантных решений, и для решений "в лоб".
		  Есть вероятность, что практикующий потренирует так же совсем базовую работу со списками (хотя тут это необязательно).]
	- [ ] [Disemvowel trolls](https://www.codewars.com/kata/disemvowel-trolls) **неизвестно** мин^[Задача на удаление всех гласных (почти) из строки.
	      Позволяет закрепить отношение к строкам, как к списку символов, тренирует работу со списками, особенно базовые навыки фильтрации. Ката была выбрана в том числе из-за интересного оформления самой задачи и конкретного use case, где нужно защищаться от кричащих троллей :)]
	- [ ] [Highest and lowest](https://www.codewars.com/kata/highest-and-lowest) **неизвестно** мин^[Найти самое большое и самое маленькое значение из строки чисел, которую надо предварительно распарсить.
	      Отличная задача для начального уровня, позволяет натренировать парсинг инстансов Read и самую базовую работу со списками (на поиск наименьшего и наибольшего значений). Естественно, и то, и другое, будет полезно уже при решении реальных задач.]
	- [ ] [Isograms](https://www.codewars.com/kata/isograms/) **неизвестно** мин^[Задача на вычисление дубликатов в массиве. Это наглядный экземпляр стандартного алгоритмического задания, которое в разных вариациях часто встречается в упражнениях почти на всех языках. Здесь же можно опробовать её на Хаскеле и сравнить (на деле или интуитивно) с тем, как бы это решалось на остальных языках.
	      Как и почти во всех классических задачах, тут есть простор для фантазии, несмотря на простоту описания. Можно решать как банальными конструкциями, а можно попытаться найти что-то изящное :)]
	- [ ] [Split strings](https://www.codewars.com/kata/split-strings) **неизвестно** мин^[Задача с предельно простым описанием, очень ясным примером, но которая не такая очевидная в решении. Хорошо иллюстрирует работы с паттерн-матчингом и конструированием списков, которые тут приходится то разбирать, то собирать. Ну и, естественно, отличная тренировка самой базовой рекурсии.]
	- [ ] [Tribonacci sequence](https://www.codewars.com/kata/tribonacci-sequence) **неизвестно** мин^[Интересная вариация набившей оскомину задачи про ряд Фибоначчи. Очень простое с виду изменение правил игры заставляет призадуматься. Ката отлично тренирует конструирование списков и рекурсию, либо умение обходиться без рекурсии стандартными функциями высшего порядка :)]
	- [ ] [Title case](https://www.codewars.com/kata/title-case) **неизвестно** мин^[Кульминация базовых тренировок, где необходимо уметь работать и с символами, и со строками, и со списками. Задача, которая действительно может встретиться в боевых условиях, и которая позволит показать навыки написания "читаемого" кода. Здесь есть возможность, как для явной рекурсии, так и для использования стандартных функций высшего порядка, есть интересное требование замены буквы на заглавный аналог и условие, когда вообще ничего делать не надо :)]
- [ ] [Codewars](https://www.codewars.com/kata/search/haskell) Выполнение не обязательных ката на codewars **неизвестно** мин
	- [ ] [Dubstep](https://www.codewars.com/kata/dubstep/) **неизвестно** мин^[Позволяет ещё немного потренироваться работать со списками. Можно написать рекурсивное решение, либо попробовать работать со свёртками, либо просто глубже поковырять стандартную библиотеку и найти в ней функции, позволяющие легко справиться с задачей.]
	- [ ] [Valid braces](https://www.codewars.com/kata/5277c8a221e209d3f6000b56) **неизвестно** мин^[Нужно проверить все ли скобки в выражении закрываются. Можно решать разными способами.
		Она заставляет задуматься, что является аналогом стека в хаскеле, и тренирует навыки обращения со свертками.]
	- [ ] [Product of consecutive Fib numbers](https://www.codewars.com/kata/5541f58a944b85ce6d00006a) **неизвестно** мин^[Нужно найти является ли переданное число произведением соседних чисел в последовательности Фибоначчи.
		Задача тренирует навыки создания рекурсии, или обращения с функциями из Data.List.]
	- [ ] [Reverse words](https://www.codewars.com/kata/reverse-words) **неизвестно** мин^[Перевернуть все слова по отдельности. Пробелы оставить как есть. У этой каты есть красивое решение с использованием комбинатора из Data.Function. Будет полезно познакомиться с этим модулем.]
	- [ ] [Snail](https://www.codewars.com/kata/snail/haskell) **неизвестно** мин^[Интересная с задача с простым условием, для которой сразу понятен императивный алгоритм с вложенными циклами, но не сразу — функциональный.
		Помечена как 4-ый кью, но на самом деле достаточно первых глав LYAH и умения работать со списками.]
	- [ ] [Equal sides of array](https://www.codewars.com/kata/equal-sides-of-an-array/train/haskell) **неизвестно** мин^[В задаче нужно найти индекс элемента в списке, где сумма элементов списка слева будет равна сумме элементов списка справа от найденного элемента. Если же такого элемента нет, то вывести -1.
		В этой кате можно отработать работу со списками, поискать вспомогательные функции в модуле Data.List или же просто посмотреть интересные решение других людей.]
	- [ ] [Go so far around to the right that you end up left](https://www.codewars.com/kata/5424e78460d77749f2000279) **неизвестно** мин^[Необходимо реализовать левую свертку через правую. Для решения нужно ознакомиться с реализацией обеих сверток и хорошо понимать, как работает каждая из них.
		Для решения нужно хорошо разобраться в принципе работы обеих сверток, так как использовать reverse = читерить.]
	- [ ] [Take a Ten Minute Walk](https://www.codewars.com/kata/54da539698b8a2ad76000228) **неизвестно** мин^[Нужно проверить предложенный маршрут (движение по сторонам света) на два условия: длительность (10 минут при минуте на одно перемещение) и совпадение начальной и конечной точки (вернуться туда, откуда пришёл).
		Тренирует работу со списками или использование Data.List.]
	- [ ] [Highest Rank Number in an Array](https://www.codewars.com/kata/5420fc9bb5b2c7fd57000004/haskell) **неизвестно** мин^[Небольшая ката для практики бесточечного стиля и работы со стандартными модулями типа Data.List, Data.Ord и т.д. на ваш выбор.]
	- [ ] [Duplicate Encoder](https://www.codewars.com/kata/54b42f9314d9229fd6000d9c) **неизвестно** мин^[Простая ката, нацеленная на поиск дубликатов в массиве, что часто встречается в реальных задачах.]
	- [ ] [Next bigger number with the same digits](https://www.codewars.com/kata/55983863da40caa2c900004e) **неизвестно** мин^[Ката с очевидным брутфорс-решением. Попытайтесь найти наиболее оптимальный алгоритм, потому как если написать слишком просто, то все тесты пройти не успеет.]
	- [ ] [Find The Parity Outlier](https://www.codewars.com/kata/5526fc09a1bbd946250002dc/haskell) **неизвестно** мин^[У FindOutlier множестово разных решений функциями из Data.List, или можно в лоб, сверткой, тренирует паттерн матчинг и функции как объекты первого класса.]
	- [ ] [Most frequently used words in a text](https://www.codewars.com/kata/51e056fe544cf36c410000fb/haskell) **неизвестно** мин^[Достаточно простая ката для 4 кью. Тренирует обработку строки с использованием Data.Char и Data.List.]
	- [ ] [Fibonacci, Tribonacci and friends](https://www.codewars.com/kata/556e0fccc392c527f20000c5/haskell) **неизвестно** мин^[Логическое продолжение каты Tribonacci, достаточно интересное и неординарное решение, тренирует мозги.]
	- [ ] [Sortable Shapes](https://www.codewars.com/kata/586669a8442e3fc307000048) **неизвестно** мин^[Это простая ката 6 кью (30 минут на решение достаточно) позволит Вам потренироваться в создании пользовательского типа данных. Основной результат - это понимание реализации каких классов нужно предусмотреть для созданного типа, чтобы данные могли отправляться в функцию sort.]
	- [ ] [Recurrence relations](https://www.codewars.com/kata/recurrence-relations/haskell) **неизвестно** мин
	- [ ] [Simple Fun #74: Growing Plant](https://www.codewars.com/kata/58941fec8afa3618c9000184) **неизвестно** мин
	- [ ] [Coloured Triangles](https://www.codewars.com/kata/coloured-triangles) **неизвестно** мин
	- [ ] [Digital Root](https://www.codewars.com/kata/541c8630095125aba6000c00) **неизвестно** мин
	- [ ] [Twice linear](https://www.codewars.com/kata/5672682212c8ecf83e000050/train/haskell) **неизвестно** мин
	- [ ] [Playing with laziness](https://www.codewars.com/kata/5516b80d891547c9b50007fd/haskell) **неизвестно** мин
	- [ ] [Break camelCase](https://www.codewars.com/kata/5208f99aee097e6552000148) **неизвестно** мин
	- [ ] [CamelCase Method](https://www.codewars.com/kata/587731fda577b3d1b0001196) **неизвестно** мин
	- [ ] [Speed Control](https://www.codewars.com/kata/speed-control/haskell) **неизвестно** мин

---
# Более глубокая теория
## Обязательно

- [ ] [учебник чуть более глубоко описывающий Haskell](https://anton-k.github.io/ru-haskell-book/book/home.html).^[Позволяет понять многие теоретические моменты. Обязательны к прочтению главы 1-9, остальные по желанию.]
- [ ] видео-курс на степик от Дениса Москвина. (Ниже разбит на части)
	- [ ] [Шпаргалка по Решениям (Если прям долго не получается и чтобы не тянуть время)](https://github.com/rgordeev/functional_programming_in_haskell)
- [ ] [Функциональное программирование на языке Haskell](https://stepik.org/course/75/).^[первая часть курса, очень системный и развернутый материал по Haskell. Она обязательна к изучению.]
	- [ ] Введение
		- [ ] [1.1 Установка и настройка среды](https://stepik.org/lesson/8119/step/1?unit=1375) ≈17 мин
		- [ ] [1.2 Функции](https://stepik.org/lesson/7859/step/1?unit=1351) ≈ 31 мин
		- [ ] [1.3 Операторы](https://stepik.org/lesson/8411/step/1?unit=1550) ≈ 26 мин
		- [ ] [1.4 Базовые типы](https://stepik.org/lesson/8412/step/1?unit=1551) ≈ 48 мин
		- [ ] [1.5 Рекурсия](https://stepik.org/lesson/8413/step/1?unit=1552) ≈ 1ч 15 мин
		- [ ] [1.6 Локальные связывания и правила отступов](https://stepik.org/lesson/8414/step/1?unit=1553) ≈ 1 ч 35 мин
	- [ ] Основы программирования
		- [ ] [2.1 Параметрический полиморфизм](https://stepik.org/lesson/8417/step/1?unit=1555) ≈ 51 мин
		- [ ] [2.2 Параметрический полиморфизм (2)](https://stepik.org/lesson/12398/step/1?unit=2828) ≈ 52 мин
		- [ ] [2.3 Классы типов](https://stepik.org/lesson/8420/step/1?unit=1556) ≈ 45 мин
		- [ ] [2.4 Стандартные классы типов](https://stepik.org/lesson/12399/step/1?unit=2829) ≈ 1 ч 15 мин
		- [ ] [2.5 Нестрогая семантика](https://stepik.org/lesson/8421/step/1?unit=1557) ≈ 1 ч 5 мин
		- [ ] [2.6 Модули и компиляция](https://stepik.org/lesson/8422/step/1?unit=1558) ≈ 23 мин
	- [ ] Списки
		- [ ] [3.1 Функции для работы со списками](https://stepik.org/lesson/8326/step/1?unit=1474) ≈ 1 ч 45 мин
		- [ ] [3.2 Функции высших порядков над списками](https://stepik.org/lesson/12321/step/1?unit=2785) ≈ 1 ч 34 мин
		- [ ] [3.3 Генераторы списков](https://stepik.org/lesson/8328/step/1?unit=1476) ≈ 1 ч 41 мин
		- [ ] [3.4 Правая свертка](https://stepik.org/lesson/4745/step/1?unit=1081) ≈ 29 мин
		- [ ] [3.5 Левая свертка и ее сравнение с правой](https://stepik.org/lesson/5790/step/1?unit=1136) ≈ 46 мин
		- [ ] [3.6 Родственные сверткам функции](https://stepik.org/lesson/6196/step/1?unit=1229) ≈ 56 мин
	- [ ] Типы данных
		- [ ] [4.1 Типы перечислений](https://stepik.org/lesson/4916/step/1?unit=1082) ≈ 48 мин
		- [ ] [4.2 Типы произведений и сумм произведений](https://stepik.org/lesson/4985/step/1?unit=1083) ≈ 1 ч 10  мин
		- [ ] [4.3 Синтаксис записей](https://stepik.org/lesson/5431/step/1?unit=1132) ≈ 41 мин
		- [ ] [4.4 Типы с параметрами](https://stepik.org/lesson/5746/step/1?unit=1256) ≈ 1 ч 24 мин
		- [ ] [4.5 Рекурсивные типы данных](https://stepik.org/lesson/7009/step/1?unit=1472) ≈ 53 мин
		- [ ] [4.6 Синонимы и обертки для типов](https://stepik.org/lesson/7602/step/1?unit=1473) ≈ 1 ч 57 мин
	- [ ] Монады
		- [ ] [5.1 Класс типов Functor и законы для него](https://stepik.org/lesson/8432/step/1?unit=2743) ≈ 1 ч 9 мин
		- [ ] [5.2 Определение монады](https://stepik.org/lesson/8437/step/1?unit=1572) ≈ 1 ч 2 мин
		- [ ] [5.3 Монада Identity](https://stepik.org/lesson/8438/step/1?unit=1573) ≈ 1 ч 6 мин
		- [ ] [5.4 Список и Maybe как монады](https://stepik.org/lesson/8439/step/1?unit=1574) ≈ 1 ч 27 мин
		- [ ] [5.5 Монада IO](https://stepik.org/lesson/8443/step/1?unit=1578) ≈ 1 ч 33 мин
		- [ ] [5.6 Монада Reader](https://stepik.org/lesson/8441/step/1?unit=1576) ≈ 54 мин
		- [ ] [5.7 Монада Writer](https://stepik.org/lesson/8442/step/1?unit=1577) ≈ 40 мин
		- [ ] [5.8 Монада State](https://stepik.org/lesson/8444/step/1?unit=1579) ≈ 1 ч 8 мин
- [ ] [Функциональное программирование на языке Haskell (часть 2)](https://stepik.org/course/693/).^[2-я часть курса, она уже необязательна. Материал тут достаточно сложный, его рекомендуем изучать после того, как сделаны первые версии бота и сервера, чтобы закрепить полученные на практике знания и расширить/углубить их.]
	- [ ] Аппликативные функторы
		- [ ] [1.1 Определение аппликативного функтора](https://stepik.org/lesson/28880/step/1?unit=9912) ≈ 2 ч 3 мин
		- [ ] [1.2 Представители класса типов Applicative](https://stepik.org/lesson/30424/step/1?unit=11041) ≈ 1 ч 34 мин
		- [ ] [1.3 Аппликативный парсер Parsec](https://stepik.org/lesson/42245/step/1?unit=20509) ≈ 43 мин
		- [ ] [1.4 Аппликативный парсер своими руками](https://stepik.org/lesson/30425/step/1?unit=11042) ≈ 1 ч 51 мин
		- [ ] [1.5 Композиция на уровне типов](https://stepik.org/lesson/30426/step/1?unit=11043) ≈ 1 ч 15 мин
	- [ ] Управление эффектами
		- [ ] [2.1 Класс типов Foldable](https://stepik.org/lesson/30427/step/1?unit=11044) ≈ 1 ч 41 мин
		- [ ] [2.2 Класс типов Traversable](https://stepik.org/lesson/30428/step/1?unit=11045) ≈ 1 ч 47 мин
		- [ ] [2.3 Законы и свойства класса Traversable](https://stepik.org/lesson/31555/step/1?unit=11808) ≈ 1 ч 44 мин
		- [ ] [2.4 Связь классов Monad и Applicative](https://stepik.org/lesson/28881/step/1?unit=9913) ≈ 1 ч 32 мин
		- [ ] [2.5 Классы типов Alternative и MonadPlus](https://stepik.org/lesson/30721/step/1?unit=11244) ≈ 57 мин
	- [ ] Монады и эффекты
		- [ ] [3.1 Монада Except](https://stepik.org/lesson/30722/step/1?unit=11809) ≈ 1 ч 18 мин
		- [ ] [3.2 Монада Cont](https://stepik.org/lesson/30723/step/1?unit=11811) ≈ 57 мин
		- [ ] [3.3 Трансформеры монад](https://stepik.org/lesson/31556/step/1?unit=11810) ≈ 46 мин
		- [ ] [3.4 Трансформер ReaderT](https://stepik.org/lesson/38577/step/1?unit=17396) ≈ 1 ч 46 мин
	- [ ] Трансформеры монад
		- [ ] [4.1 Трансформер WriterT](https://stepik.org/lesson/38578/step/1?unit=20503) ≈ 1 ч 23 мин
		- [ ] [4.2 Трансформер StateT](https://stepik.org/lesson/38579/step/1?unit=20504) ≈ 1 ч 4 мин
		- [ ] [4.3 Трансформер ExceptT](https://stepik.org/lesson/38580/step/1?unit=20505) ≈ 1 ч 0 мин
		- [ ] [4.4 Неявный лифтинг](https://stepik.org/lesson/38581/step/1?unit=20506) ≈ 57 мин
		- [ ] [4.5 Задачи на трансформеры](https://stepik.org/lesson/45331/step/1?unit=23645) ≈ 5 мин
- [ ] [Typeclassopedia](https://wiki.haskell.org/Typeclassopedia). **неизвестно** мин^[системное описание почти всех самых популярных тайпклассов]

## Необязательно

- [ ] Очень рекомендуется: книга для начинающих с хорошим практическим уклоном Get Programming with Haskell (W. Kurt).^[Т.к. эта книга не доступна бесплатно, мы не включили её в обязательную часть, но очень рекомендуем. Здесь есть очень приближенные к реальным задачи, с помощью которых вы можете быстро и эффективно начать писать свои приложения, вроде бота. Книга максимально свежая и актуальная, хорошо написана. Практика показала, что изучающие её в рамках нашей программы потом её активно хвалили :)]
- [ ] сделать упражнения из глав [Real World Haskell](http://book.realworldhaskell.org/), которые помогут освоиться с приближенными к реальным задачам.
- [ ] По желанию: часто рекомендуемая многими новичками книга [http://haskellbook.com/](http://haskellbook.com/).
- [ ] По желанию: [видео-курс от Николая Кудасова](https://www.youtube.com/watch?v=jNQVa5INdDk&list=PLov3NSwpY86cfkfXyVroSZkHemxoAdnrd&index=1).
- [ ] По желанию: Write Yourself a Scheme in 48 Hours.-     
	Упражнение по написанию простого интерпретатора для языка Scheme (язык, с которого был слизан JavaScript). [https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours](https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours).
	.
	Есть так же перевод на русский (там могут быть не все части или неактуальные данные): [https://ru.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours](https://ru.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours).
	.
	Очень рекомендую пройти, на самом деле туториал довольно небольшой, но дает хороший пример написания средних по размеру програм, в то время как почти все остальные туториалы нацелены на примеры совсем тривиальных вещей в один-два файла.
- [ ] [Выводы и ссылки на рецензии о современных книгах по Haskell](https://medium.com/@_bravit/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8-%D0%BF%D0%BE-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E-%D0%BD%D0%B0-haskell-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D1%8B-712c1f5b7749).
- [ ] Статьи по различным темам, которые могут оказаться полезными для понимания того или иного материала
	- [ ] [Pitfalls in Haskell](http://web.archive.org/web/20150505013645/http://users.jyu.fi:80/~sapekiis/haskell-pitfalls/)
	- [ ] [Thinking Functionally with Haskell](https://pragprog.com/magazines/2012-09/thinking-functionally-with-haskell)
	- [ ] [Функторы, монады и аппликативы в картинках](https://habr.com/post/183150/)
	- [ ] [Три полезные монады (в картинках)](https://habr.com/post/184722/)
	- [ ] [«Страшные» абстракции Haskell без математики и без кода (почти). Часть I](https://habr.com/post/272115/)
	- [ ] [Моноиды, полугруппы и все-все-все](https://habr.com/company/jugru/blog/340178/). Оригинал [тут](http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory/)

---
# Задание 2: задачки по языку

- [ ] Рекомендуемые каты
	- [ ] [Бесконечные структуры](https://www.codewars.com/kata/functional-streams)
	- [ ] [Создание своих инстансов для 5 базовых монад](https://www.codewars.com/kata/five-fundamental-monads)
	- [ ] [Монадный стек Maybe + List + State](https://www.codewars.com/kata/escape-the-mines-or-die)
	- [ ] [Представление структур данных из функций](https://www.codewars.com/kata/scott-encoding/train/haskell).^[Практически любой тип данных можно представить даже в языке без специальных синтаксических конструкций, если этот язык поддерживает функции высшего порядка и замыкания. Haskell как раз имеет специальные синтаксические конструкции для создания алгебраических типов данных, однако на замену им могут прийти простые функции. Как с их помощью сэмулировать пары, Maybe и даже списки как раз продемонстрирует эта ката.
		  .
		  Также для закрепления концепции алгебраических типов данных рекомендую подглаву 2.1 книги SICP, там этот подход отлично описан. Саму книгу в целом тоже рекомендую в дальнейшем прочесть, хотя многие темы там уже по продвинутым темам.]
	- [ ] [Изоморфизм (на самом деле довольно простая и интересная ката)](https://www.codewars.com/kata/isomorphism)
- [ ] Необязательные каты
	- [ ] [Алгебраические изоморфизмы (после каты Изоморфизм)](https://www.codewars.com/kata/algebraic-isomorphism/haskell)
	- [ ] [Синглтоны](https://www.codewars.com/kata/54750ed320c64c64e20002e2).^[Несложная ката, решив которую можно познакомиться с зависимыми типами. Несмотря на то, что в Хаскеле на данный момент зависимых типов нет, последние можно сымитировать при помощи некоторых расширений ghci и типов-синглтонов - типов, имеющих только одно значение.]
	- [ ] [Корутины](https://www.codewars.com/kata/547a77a6b84a1fb8bf000211)
	- [ ] [Lens](https://www.codewars.com/kata/54258ffb430ca2e4b5000239)
	- [ ] [Простой компилятор](https://www.codewars.com/kata/5265b0885fda8eac5900093b)
	- [ ] Обязательно попробуйте найти и пройти еще от 3-х кат (1, 2 или 3 kyu) самостоятельно.

---
# Задание 3: бот

Нужно написать эхо-бота, который умеет просто отправлять сообщение от пользователя ему же в ответ.

Бот должен уметь работать с сообщениями через несколько механизмов доставки:

- консоль: сообщение пользователя вводится со стандартного ввода, ответ бота выводится в стандартный вывод (например, с помощью [getLine](https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html#v:getLine) и [putStrLn](https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html#v:putStrLn)).
- Telegram: [https://core.telegram.org/bots/api#poll](https://core.telegram.org/bots/api#poll)
- Вместо Telegram можно выбрать VK (см. [документацию](https://vk.com/dev/bots_longpoll)) или Slack.

## Функциональные требования

1. Пользователь может отправить команду /help и увидеть текст, описывающий бота.
2. Пользователь может отправить команду /repeat, и в ответ бот отправит, какое сейчас выбрано значение повторов и вопрос, сколько раз повторять сообщение в дальнейшем. К вопросу будут прилагаться кнопки для выбора ответа (кнопки с цифрами от 1 до 5). После выбора пользователем все ответы бота должны дублировать сообщение пользователя указанное кол-во раз. Кол-во повторов должно быть индивидуальным для каждого пользователя, т. е. если один пользователь выбрал 3 повторения, то второму мы по-прежнему показываем начальное кол-во сообщений.
3. Все должно быть максимально кастомизируемо через конфиги:
	1.  Сообщение, отправляемое в ответ на /help.
	2.  Вопрос по команде /repeat.
	3.  Начальное кол-во повторов на каждый ответ.
4. Бот должен уметь повторять только текстовые сообщения и какой-нибудь один вид мультимедийных сообщений (например, стикеры или картинки). Остальные виды сообщений можно игнорировать. Конечно, этот пункт не распространяется на сообщения из консоли.

## Технические требования

1. Можно взять за основу [шаблон проекта](https://github.com/fullstack-development/haskell-internship/tree/master/echo-bot-template). Он содержит "скелет" логики бота и некоторые тесты. Запустите stack test и попробуйте исправить логику, чтобы тесты начали проходить. Шаблон можно как угодно править по своему усмотрению, а можно не использовать совсем.
2. Для основного кода проекта (кроме тестов) использовать только библиотеки из стандартной поставки [Haskell Platform](https://coda.io/d/_dXh0LxbfZxo/_suHtD) и три сторонние:
	1. Для отправки http-запросов
	2.  Для парсинга json
	3.  Для работы с конфигом.
3. Все остальное должно быть сделано по максимуму без библиотек. Для тестов можете использовать любой удобный вам инструмент (hspec, HUnit, etc).
4. Обновления от Телеграма получать не посредством веб-хуков, а посредством поллинга. Отправлять запрос за апдейтами телеграму, тот сам будет ставить ответ на паузу, если обновок нет, и отвечать сразу, как только что-то появилось. Ну или отвечать пустым массивом по таймауту. Это требование вкупе с тем, что в следующем задании надо будет свой сервер на Warp реализовать, поможет лучше понять, что такое модель поллинга и модель пуша (через веб-хуки), в чем преимущества и недостатки каждой из моделей.
5. Результатом должно быть одно приложение, а не два. В каком режиме его запускать (Telegram или консоль), определяется параметром в конфиге или опцией командной строки.

## Следующие технические требования также распространяются и на следующее задание "Веб-сервер"

1. Проект должен быть в отдельном репозитории на github, во время выполнения задания коммиты делать как можно чаще, как минимум раз в день, когда написана хоть строчка кода.
2. Использовать [stack](https://www.haskellstack.org/), все используемые библиотеки должны быть зафиксированы в файле package.yaml, сам проект должен быть инициирован командой stack new, которая создает базовую структуру Haskell-проекта.
3. Для разворачивания должно быть достаточно клонирования репозитория и запуска stack build. Обязательно проверить это правило клонированием репозитория в отдельную папку у себя и запуска stack build — результатом должны быть собранные и рабочие бинарники.
4. У каждого проекта должно быть README с описанием того, как разворачивать проект локально и как его запускать, а так же с описанием базовой структуры, чтобы новичок мог легко разобраться (представьте, что после вас проект будет поддерживать совсем нулевой джуниор). Все должно быть на английском.
5. Проект должен иметь файл .gitignore, куда внесены все автогенерируемые файлы проекта, локальные конфиги и т.д. Обязательно добавьте туда следующие папки (даже если вы не пользуетесь редактором VSCode, им пользуемся мы и это правило для нашего удобства при проверке):
	- .vscode
	- .history
6. Проект должен быть покрыт unit-тестами, которые бы покрывали главные use-case каждого модуля в приложении.
7. Конфиги должны быть вынесены в отдельный файл с возможностью переписать локально какие-нибудь значения, но не изменять файлы из git-репозитория, чтобы случайно не запушить пароль или токен.
8. Проект должен поддерживать логи разных уровней, все ключевые моменты должны грамотно логироваться, логи должны легко конфигурироваться хотя бы так, чтобы можно было включать/выключать логи до определенного уровня (например, показывать все от DEBUG и выше, или показывать все от WARN и выше).
9. Для понятной архитектуры рекомендуем использовать [Handle Pattern](https://jaspervdj.be/posts/2018-03-08-handle-pattern.html), так как мы применяем его в большинстве своих проектов.
10. Чтобы добиться понятной архитектуры проекта, и получить тестируемый код, также можно применять различные техники (паттерны) описанные сообществом:
	- [The Service Pattern](https://www.schoolofhaskell.com/user/meiersi/the-service-pattern)
	- [The ReaderT Design Pattern (Discussion)](https://www.fpcomplete.com/blog/2017/06/readert-design-pattern)
	- [Three Layer Haskell Cake](https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html)
12. Полезно почитать требования к проекту из задания 5 (код-ревью). На старте проекта необязательно забивать себе ими голову — потом успеете, но, все-таки, если знать их заранее, придется меньше исправлять.

## Источники

- Для начала можно посмотреть [простую статью](https://www.bekk.christmas/post/2019/23/making-a-small-haskell-application) про то, как начать собирать первое приложение по отправке HTTP-запроса и получению одного нужного поля из JSON
- [Designing Testable Components](http://felixmulder.com/writing/2019/10/05/Designing-testable-components.html)
- Полезные статьи для данного задания:
- [Telegram-бот на Python: от первой строчки до запуска на Heroku](https://web.archive.org/web/20210120102233/https://tproger.ru/translations/telegram-bot-create-and-deploy/amp/)
	- [https://artyom.me/aeson](https://artyom.me/aeson)
	- [https://ruhaskell.org/posts/packages/2015/02/03/aeson-hello-world.html](https://ruhaskell.org/posts/packages/2015/02/03/aeson-hello-world.html)
	- [https://ruhaskell.org/posts/packages/2015/03/05/aeson-next.html](https://ruhaskell.org/posts/packages/2015/03/05/aeson-next.html)

---

# Задание 4 Сайт (Пока не перенесено)

# Задание 5 (От себя, будет дополняться по времени)

- [ ] [Прочесть и написать отчеты Error vs. Exception - HaskellWiki](https://wiki.haskell.org/Error_vs._Exception)
- [ ] [Блог Нила Митчелла (Haskell и т. д.): В погоне за утечкой пространства при встряхивании](http://neilmitchell.blogspot.com/2013/02/chasing-space-leak-in-shake.html)
- [ ] 
- [ ] 

# Отчеты

## 2023.06.08

### Краткий отчет

- Установка Haskell 9:00-9:20
- О Haskell по-человечески
	- Приветствие 09:20-09:25
	- Первые вопросы 09:25-09:30
	- Об этой книге 9:30-9:40
	- Приготовимся 9:40-9:55
	- Киты и Черепаха 9:55-10:30
	- Неизменность и чистота 10:30-10:50
	- Выбираем и возвращаемся 10:50-11:00
	- Выбор и образцы 11:00-11:40
	- Пусть будет там, Где… 11:40-12:20
	- Мир операторов 12:20-12:40
	- Список 12:40-13:20
	- Кортеж 13:20-13:30
	- Лямбда-функция 13:30-13:40
	- Композиция функций 13:40-13:50
	- ФВП 13:50-14:10
	- Hackage и библиотеки 14:10-14:50
	- Рекурсия 14:50-15:10
	- Лень 15:10-15:20
	- Наши типы 15:20-15:35
	- АТД 15:35-16:00
	- АТД: поля с метками 16:00-16:20
	- Новый тип 16:20-16:40
	- Конструктор типа 16:40-17:00

### Подробный отчет

#### Установка Haskell

Установил stack
Для решения задач на `codewars` буду использовать [Онлайн компилятор](https://play.haskell.org/)

#### Приветствие

Приветствие с читателем. В нём указывается цель книги, причины её на писания.

#### Первые вопросы

Введение, в котором рассказывается некоторые особенности книги, языка программирования, порога входа в язык и небольшое сравнение с другими языками программирования

#### Об этой книге

Рассказывается о чем будет книга, чего не будет в книге, что будет в книге, как читать книгу, пояснение как читать код, благодарность членам сообщества Haskell, которые помогли советами, замечаниями и исправлениями, а так же что изменило с первым изданием.

#### Приготовимся

Установка stack (Установил ранее)
Создание проекта:
```bash
$ stack new real
```

Структура проекта:
```
.
├── app
│   └── Main.hs <- Главный модуль программы
├── LICENSE
├── README.md
├── real.cabal  <- Сборочный конфиг проекта
├── Setup.hs
├── src
│   └── Lib.hs  <- Ещё один модуль
├── stack.yaml  <- Конфиг Stack
└── test
    └── Spec.hs <- Тесты, они нам пока не нужны
```

Сборка проекта:
```bash
$ stack build
```

В результате сборки появится файл `real-exe`. Располагается он внутри скрытого каталога `.stack-work` в корне проекта.
Чтобы сразу его запустить, не копаясь во внутренностях этого скрытого каталога, используем команду:
```bash
$ stack exec real-exe
someFunc
```

Чтобы не писать `stack exec real-exe`, упростим себе жизнь командой:
```bash
$ stack install
```

В результате исполняемый файл будет скопирован в каталог `~/.local/bin` (подразумевается, что такой каталог у вас уже имеется). Если `~/.local/bin` нету в `PATH`, необходимо его добавить.

Содержимое начальных файлов:

Модуль `src/Lib.hs`:
```haskell
module Lib      -- Имя модуля
    ( someFunc  -- Интерфейс модуля
    ) where

-- Всё содержимое модуля - эта функция.
someFunc :: IO ()
someFunc = putStrLn "someFunc"
```

Модуль `app/Main.hs`:

```haskell
module Main where

import Lib      -- Импортируем модуль Lib...

main :: IO ()
main = someFunc -- Используем его содержимое...
```

#### Киты и Черепаха

##### Черепаха

Haskell стоит на Трёх Китах, имена которым: **Функция**, **Тип** и **Класс типов**. Они же, в свою очередь, покоятся на огромной Черепахе, имя которой — **Выражение**.

Haskell-программа представляет собой совокупность выражений (англ. expression). Пример:

```haskell
1 + 2
```

> Выражение — это то, что может дать нам некий полезный результат.

Полезный результат мы получаем в результате вычисления (англ. evaluation) выражения.
Все выражения являются вычисляемыми, однако одни выражения в результате вычисления уменьшаются (англ. reduce), а другие — нет. Первые называются редуцируемыми выражениями, а вторые — нередуцируемые.

Редуцируемое выражение:

```haskell
1 + 2
```

Нередуцируемое выражение:

```haskell
3
```

##### Первый Кит

> Функция — это закон, описывающий зависимость одного значения от другого.

Входное значение функции называют аргументом. А так как функция определяет однозначную зависимость выходного значения от аргумента, её, функцию, называют ещё отображением: она отображает/проецирует входное значение на выходное.

Выражение `1 + 2` является применение функции.

```haskell
(+) 1 2
```

> Вычислить выражение — это значит применить какие-то функции (одну или более) к каким-то аргументам (одному или более).

В Haskell функции не вызывают.  Понятие «вызов» функции пришло к нам из почтенного языка C. Там функции действительно вызывают (англ. call), потому что в C, в отличие от Haskell, понятие «функция» не имеет никакого отношения к математике. Там это подпрограмма, то есть обособленный кусочек программы, доступный по некоторому адресу в памяти. В Haskell функция — это функция в математическом смысле слова, поэтому её не вызывают, а применяют к чему-то.

##### Второй Кит

Аргумент представляет собой некоторое значение, его ещё называют «данное» (англ. data). Данные в Haskell — это сущности, обладающие двумя главными характеристиками: типом и конкретным значением/содержимым.

Тип — это Второй Кит в Haskell. Тип отражает конкретное содержимое данных, а потому все данные в программе обязательно имеют некий тип. Когда мы видим данное типа `Double`, мы точно знаем, что перед нами число с плавающей точкой, а когда видим данные типа `String` — можем ручаться, что перед нами строки.

Отношение к типам в Haskell очень серьёзное, и работа с типами характеризуется тремя важными чертами:

1. статическая проверка,
	1. Статическая проверка типов (англ. static type checking) — это проверка типов всех данных в программе, осуществляемая на этапе компиляции. Haskell-компилятор упрям: когда ему что-либо не нравится в типах, он громко ругается.
2. сила,
	1. Сильная (англ. strong) система типов — это бескомпромиссный контроль соответствия ожидаемого действительному. Сила делает работу с типами ещё более аккуратной.
	2. Гарантирует отсутствие скрытого приведения типов (англ. implicit type casting)
	3. Компилятор скрупулёзно отслеживает соответствие ожидаемого типа фактическому, поэтому когда компиляция завершается успешно, мы абсолютно уверены в гармонии между типами всех наших данных.
3. выведение.
	1. Выведение (англ. inference) типов — это способность определить тип данных автоматически, по конкретному выражению.
	2. однако в Haskell мы напишем просто: `value = 122.04`, и компилятор автоматически выведет тип `value` как `Double`.

Простейшие типы данных:

```haskell
123         Int,    Целое число
23.5798     Double, Дробное число
'a'         Char,   Буква
"Hello!"    String, Строка
True        Bool,   Истина
False       Bool,   Ложь
```

Имя типа в Haskell всегда начинается с большой буквы.

##### Третий Кит

А вот о Третьем Ките, о **Классе типов**, нам не рассказали, но обещали рассказать позже.

#### Неизменность и чистота

Haskell «чисто функциональный» язык и почему в нём нет места оператору присваивания.

Объявление (англ. declaration) функции. (Говорит о том, что функция существует и о том, с какими типами она работает)

```haskell
square :: Int -> Int
```

Определение (англ. definition) функции. (Говорит о том, что конкретно она делает)

```haskell
square v = v * v
```

Пример объявления с пояснениями. (Ищем крайнюю правую стрелку, и всё что левее от неё — то типы аргументов, а всё что правее — то тип вычисленного значения)

```haskell
prod    :: Int      -> Int      -> Int

имя        тип         тип         тип
функции    первого     второго     вычисленного
           аргумента   аргумента   значения
```

Пример определения с пояснениями. (слева от знака равенства — имя функции и имена аргументов (имена, а не типы), разделённые пробелами, а справа — выражение, составляющее суть функции, её содержимое. Иногда эти части называют «головой» и «телом»)

```haskell
prod     x          y         =    x * y

имя      имя        имя       это  выражение
функции  первого    второго
         аргумента  аргумента
```

Здесь идёт именно о знаке равенства, а никак не об операторе присваивания. Мы ничего не присваиваем, мы лишь декларируем равенство левой и правой частей.

Haskell — чисто функциональный (англ. purely functional) язык. Центральное место в нём уделено чистой функции (англ. pure function).

Функция `prod` является чистой, а потому характеризуется отсутствием побочных эффектов (англ. side effects): она не способна сделать ничего, кроме как вернуть произведение двух своих аргументов.

Присваивание (англ. assignment) пришло к нам из императивных языков.
Императивное программирование (англ. imperative programming) — это направление в разработке, объединяющее несколько парадигм программирования, одной из которых является знаменитая объектно-ориентированная парадигма. В рамках этого направления программа воспринимается как набор инструкций, выполнение которых неразрывно связано с изменением состояния (англ. state) этой программы. Вот почему в императивных языках обязательно присутствует понятие «переменная» (англ. variable).

Однако существует принципиально иной подход к разработке, а именно декларативное программирование (англ. declarative programming). Данное направление также включает в себя несколько парадигм, одной из которых является функциональная парадигма, нашедшая своё воплощение в Haskell. При этом подходе программа воспринимается уже не как набор инструкций, а как набор выражений. А поскольку выражения вычисляются путём применения функций к аргументам (то есть, по сути, к другим выражениям), там нет места ни переменным, ни оператору присваивания. Все данные в Haskell-программе, будучи созданными единожды, уже не могут быть изменены. Поэтому нам не нужен не только оператор присваивания, но и ключевое слово `const`.

#### Выбираем и возвращаемся

Комментарии в Haskell

```haskell
{-
    Я - сложный многострочный
     комментарий, содержащий
  нечто
        очень важное!
-}
main :: IO ()
main =
  -- А я - скромный однострочный комментарий.
  putStrLn "Hi, real world!"
```

Существует несколько способов задания условной конструкции.

Базовый вариант:

```haskell
if CONDITION then EXPR1 else EXPR2
```

- `CONDITION` — логическое выражение, дающее ложь или истину
- `EXPR1` — выражение, используемое в случае `True`,
- `EXPR2` — выражение, используемое в случае `False`

Пример:

```haskell
checkLocalhost :: String -> String
checkLocalhost ip =
  -- True или False?
  if ip == "127.0.0.1" || ip == "0.0.0.0"
    -- Если True - идёт туда...
    then "It's a localhost!"
    -- А если False - сюда...
    else "No, it's not a localhost."

main :: IO ()
main = putStrLn (checkLocalhost "127.0.0.1")
```

Далее там было очень подробное объяснение, как это работает. 

#### Выбор и образцы

##### Не только из двух

Данный код:

```haskell
analyzeGold :: Int -> String
analyzeGold standard =
  if standard == 999
    then "Wow! 999 standard!"
    else if standard == 750
           then "Great! 750 standard."
           else if standard == 585
                  then "Not bad! 585 standard."
                  else "I don't know such a standard..."

main :: IO ()
main = putStrLn (analyzeGold 999)
```

Можно сократить до такого:

```haskell
{-# LANGUAGE MultiWayIf #-}  -- магия

analyzeGold :: Int -> String
analyzeGold standard =
  if | standard == 999 -> "Wow! 999 standard!"
     | standard == 750 -> "Great! 750 standard."
     | standard == 585 -> "Not bad! 585 standard."
     | otherwise -> "I don't know such a standard..."

main :: IO ()
main = putStrLn (analyzeGold 999)
```

Схема работы:

```haskell
if | COND1 -> EXPR1
   | COND2 -> EXPR2
   | ...
   | CONDn -> EXPRn
   | otherwise -> COMMON_EXPR
```

1. `COND1..n` — выражения, дающие ложь или истину
2. `EXPR1..n` — соответствующие им результирующие выражения
3. Особая функция `otherwise` соответствует общему случаю, когда ни одно из логических выражений не дало `True`, и в этой ситуации результатом условной конструкции послужит выражение `COMMON_EXPR`

Если не указать `otherwise`, то компиляция завершится успешно

```haskell
{-# LANGUAGE MultiWayIf #-}  -- магия

analyzeGold :: Int -> String
analyzeGold standard =
  if | standard == 999 -> "Wow! 999 standard!"
     | standard == 750 -> "Great! 750 standard."
     | standard == 585 -> "Not bad! 585 standard."

main :: IO ()
main = putStrLn (analyzeGold 583)  -- Ой...
```

однако в момент запуска программы вас ожидает неприятный сюрприз в виде ошибки:

```
Non-exhaustive guards in multi-way if
```

Так что используем `otherwise` и всё в порядке:

```haskell
{-# LANGUAGE MultiWayIf #-}  -- Что это за магия??

module Main where

analyzeGold :: Int -> String
analyzeGold standard =
  if | standard == 999 -> "Wow! 999 standard!"
     | standard == 750 -> "Great! 750 standard."
     | standard == 585 -> "Not bad! 585 standard."
     | otherwise -> "I don't know such a standard..."

main :: IO ()
main = putStrLn (analyzeGold 999)
```

Но что это за магия в начале модуля?

Стандарт [Haskell 2010](https://www.haskell.org/onlinereport/haskell2010/) — это официальный стержень языка. Однако компилятор GHC, давно уж ставший компилятором по умолчанию при разработке на Haskell, обладает рядом особых возможностей. По умолчанию многие из этих возможностей выключены, а прагма `LANGUAGE` как раз для того и предназначена, чтобы их включать/активизировать. В данном случае мы включили расширение `MultiWayIf`. Именно это расширение позволяет нам использовать множественный `if`. Такого рода расширений существует очень много, и мы будем часто их использовать.

Расширение, в включенное в модуле, действует лишь в рамках текущего модуля

Добавлю от себя: С одной стороны, люди хотели снова собраться и создать новый стандарт, но возникло противоречие

1. У языка Haskell основной компилятор один - `ghc`
2. Так как конкуренты отсутствуют, то и стандарт расширять будет просто переписыванием решений принятых `ghc`? Поэтому некоторые не видят необходимости в создании нового стандарта, так как `ghc` стандарт де факто.
3. Все новшества обрабатываются и включаются в языковые расширения, так что необходимости в новом стандарте нету.

##### Без Если

Так же можно ещё сократить и избавиться от оператора `if`:

```haskell
analyzeGold :: Int -> String
analyzeGold standard
  | standard == 999 = "Wow! 999 standard!"
  | standard == 750 = "Great! 750 standard."
  | standard == 585 = "Not bad! 585 standard."
  | otherwise = "I don't know such a standard..."

main :: IO ()
main = putStrLn (analyzeGold 999)
```

Схема:

```haskell
function arg  -- Нет знака равенства?
  | COND1 = EXPR1
  | COND2 = EXPR2
  | ...
  | CONDn = EXPRn
  | otherwise = COMMON_EXPR
```

##### Сравнение с образцом

Так же мы можем избавиться от наших «ИЛИ»:

```haskell
analyzeGold :: Int -> String  -- Одно объявление.
-- И множество определений...
analyzeGold 999 = "Wow! 999 standard!"
analyzeGold 750 = "Great! 750 standard."
analyzeGold 585 = "Not bad! 585 standard."
analyzeGold _   = "I don't know such a standard..."

main :: IO ()
main = putStrLn (analyzeGold 999)
```

Сравнение с образцом, называемое ещё «сопоставлением с образцом» используется в Haskell чрезвычайно широко. В русскоязычной литературе перевод словосочетания «pattern matching» не особо закрепился, вместо этого так и говорят «паттерн матчинг».

Символ `_` — это универсальный образец, сравнение с которым всегда истинно (ещё говорят, что с ним матчится (англ. match) всё что угодно).
Если просто, то символ, который можно прочесть как «всё равно».
Мы как бы говорим: «В данном случае нас не интересует конкретное содержимое аргумента, нам всё равно, мы просто возвращаем строку `I don't know such a standard...`».

Сравнение аргумента с образцами происходит последовательно, сверху вниз.

Если мы напишем:

```haskell
analyzeGold :: Int -> String
analyzeGold _   = "I don't know such a standard..."
analyzeGold 999 = "Wow! 999 standard!"
analyzeGold 750 = "Great! 750 standard."
analyzeGold 585 = "Not bad! 585 standard."

main :: IO ()
main = putStrLn (analyzeGold 999)
```

Функция `analyzeGold` всегда будет возвращать `I don't know such a standard...`

Существует ещё один вид паттерн матчинга, с помощью конструкции `case-of`:

```haskell
analyzeGold standard =
  case standard of
    999 -> "Wow! 999 standard!"
    750 -> "Great! 750 standard."
    585 -> "Not bad! 585 standard."
    _   -> "I don't know such a standard..."

main :: IO ()
main = putStrLn (analyzeGold 999)
```

Схема:

```haskell
case EXPRESSION of
  PATTERN1 -> EXPR1
  PATTERN2 -> EXPR2
  ...
  PATTERNn -> EXPRn
  _        -> COMMON_EXPR
```

- `EXPRESSION` — анализируемое выражение, последовательно сравниваемое с образцами `PATTERN1..n`
- Если ни одно не сработало — как обычно, упираемся в универсальный образец `_` и выдаём `COMMON_EXPR`.

Обещали показать другие виды паттерн матчинага.

#### Пусть будет там, Где…

##### Пусть

Мы считаем время некоторого события, и если исходное время меньше `40` секунд — результирующее время увеличено на `120` секунд, в противном случае — ещё на `8` секунд сверх того. Перед нами классический пример «магических чисел» (англ. magic numbers), когда смысл конкретных значений скрыт за семью печатями.

```haskell
{-# LANGUAGE MultiWayIf #-}

calculateTime :: Int -> Int
calculateTime timeInS =
  if | timeInS <  40 -> timeInS + 120
     | timeInS >= 40 -> timeInS + 8 + 120

```

```haskell
{-# LANGUAGE MultiWayIf #-}

calculateTime :: Int -> Int
calculateTime timeInS =
  let threshold  = 40
      correction = 120
      delta      = 8
  in
  if | timeInS <  threshold -> timeInS + correction
     | timeInS >= threshold -> timeInS + delta + correction
```

Мы избавились от «магических чисел», введя поясняющие выражения `threshold`, `correction` и `delta`.

Схема конструкции `let-in`:

```haskell
let DECLARATIONS in EXPRESSION
```

- `DECLARATIONS` — выражения, декларируемые нами
- `EXPRESSION` — выражение, в котором используется выражения из `DECLARATION`

Мы также можем ещё упростить функцию, использовав `otherwise`:

```haskell
{-# LANGUAGE MultiWayIf #-}

calculateTime :: Int -> Int
calculateTime timeInS =
  let threshold  = 40
      correction = 120
      delta      = 8
  in
  if | timeInS <  threshold -> timeInS + correction
     | otherwise  -> timeInS + delta + correction
```

Все введённые конструкцией `let-in` выражения существуют лишь в рамках выражения, следующего за словом `in`

##### Где

Иной способ введения промежуточных выражений:

```haskell
{-# LANGUAGE MultiWayIf #-}

calculateTime :: Int -> Int
calculateTime timeInS =
  if | timeInS < threshold -> timeInS + correction
     | otherwise -> timeInS +
                    delta +
                    correction
  where
    threshold  = 40
    correction = 120
    delta      = 8
```

Ключевое слово `where` делает примерно то же, что и `let`, но промежуточные выражения задаются в конце функции. Такая конструкция читается подобно научной формуле:

```haskell
S = V * t,      -- Выражение
 где
  -- Всё то, что
  -- используется
  -- в выражении.
  S = расстояние,
  V = скорость,
  t = время.
```

##### Вместе

Мы можем использовать `let-in` и `where` совместно, в рамках одной функции:

```haskell
{-# LANGUAGE MultiWayIf #-}

calculateTime :: Int -> Int
calculateTime timeInS =
  let threshold = 40 in
  if | timeInS < threshold -> timeInS + correction
     | otherwise -> timeInS + delta + correction
  where
    correction = 120
    delta      = 8
```

Общая рекомендация: не смешивайте let-in и where без особой надобности, такой код читается тяжело, избыточно.

В качестве промежуточных могут выступать и более сложные выражения. Например:

```haskell
{-# LANGUAGE MultiWayIf #-}

calculateTime :: Int -> Int
calculateTime timeInS =
  let threshold = 40 in
  if | timeInS < threshold -> timeInS + correction
     | otherwise -> timeInS + delta + correction
  where
    -- Это промежуточное выражение зависит от аргумента...
    correction = timeInS * 2
    -- А это - от другого выражения...
    delta      = correction - 4
```

Выражение `correction` равно `timeInS * 2`, то есть теперь оно зависит от значения аргумента функции. А выражение `delta` зависит в свою очередь от `correction`. Причём мы можем менять порядок задания выражений:

Внутри конструкции `let-in` можно использовать выражения из `where`, но обратное делать нельзя.

#### Мир операторов

> Оператор (англ. operator) — частный случай функции

```haskell
1 + 2
```

Функция `+` записана в инфиксной (англ. infix) форме, то есть между своими аргументами. Такая запись выглядит естественнее, нежели обычная:

```haskell
(+) 1 2
```

Для использования функции в инфиксной форме по умолчанию имя функции в определении заключено в круглые скобки:

```haskell
(+) :: ...
```

> Функции, предназначенные для инфиксной формы применения, называют операторами.

Если же имя функции не заключено в круглые скобки, то используется обычная форма применения. Однако функцию можно применять инфиксно.
Для этого имя функции должно заключаться в обратные одинарные кавычки (англ. backtick).

Определим функцию `isEqualTo`, являющуюся аналогом оператора проверки на равенство для двух целочисленных значений:

```haskell
isEqualTo :: Int -> Int -> Bool
isEqualTo x y = x == y
```

Обычная запись:

```haskell
...
if isEqualTo code1 code2 then ... else ...
where code1 = 123
	  code2 = 124
...
```

Инфиксная форма:

```haskell
...
if code1 `isEqualTo` code2 then ... else ...
where code1 = 123
	  code2 = 124
...
```

##### Зачем это нужно?

Почти все ASCII-символы (а также их всевозможные комбинации) можно использовать в качестве операторов в Haskell. Это даёт нам широкие возможности для реализации различных EDSL (англ. Embedded Domain Specific Language), своего рода «языков в языке». Вот пример:

```haskell
div ! class_ "nav-wrapper" $
  a ! class_ "brand-logo sans" ! href "/" $
    "#ohaskell"
```

Это [кусочек кода](https://github.com/denisshevchenko/ohaskell.guide/blob/master/src/CreateHtmlTemplates.hs#L56), строящего HTML-шаблон для веб-варианта данной книги. То что вы видите — это совершенно легальный Haskell-код, в процессе работы которого генерируется реальный HTML: тег `<div>` с классом `nav-wrapper`, внутри которого лежит `<a>`-ссылка с двумя классами, корневым адресом и внутренним текстом `#ohaskell`.

Идентификаторы `div`, `class_` и `href` — это имена функций, а символы `!` и `$` — это операторы, записанные в инфиксной форме. Самое главное, что для понимания этого кода нам абсолютно необязательно знать, где определены все эти функции/операторы и как они работают.

> Чтобы использовать функции, нам вовсе необязательно знать их внутренности.

Нам обещали ещё встретится с EDSL.

#### Список

Список (англ. list) — это стандартный тип, характеризующий уже не просто данные, но структуру данных (англ. data structure). Эта структура представляет собой набор данных одного типа, и едва ли хоть одна реальная Haskell-программа может обойтись без списков.

> Структуры, содержащие данные одного типа, называют ещё гомогенными (в переводе с греческого: «одного рода»).

Вот список из трёх целых чисел:

```haskell
[1, 2, 3]
```

Квадратные скобки и значения, разделённые запятыми. Вот так выглядит список из двух значений типа `Double`:

```haskell
[1.3, 45.7899]
```

а вот и список из одного-единственного символа:

```haskell
['H']
```

или вот из четырёх строк, отражающих имена протоколов транспортного уровня OSI-модели:

```haskell
["TCP", "UDP", "DCCP", "SCTP"]
```

Это список списков строк. Форматирование в отношении квадратных скобок весьма вольное, при желании можно и так написать:

```haskell
[["DHCP", "FTP", "HTTP"        ],
 ["TCP",  "UDP", "DCCP", "SCTP"],
 ["ARP",  "NDP", "OSPF"        ]]
```

Список может быть и пустым, то есть не содержать в себе никаких данных:

```haskell
[]
```

В Haskell существуют массивы (англ. array), но это несколько иная структура данных, так что не следует её путать со списками.

##### Тип списка

```haskell
[Int]       -- Список целых чисел
[Char]      -- Список символов
[String]    -- Список строк
[[String]]  -- Список списков строк
```

Схема:

```haskell
[   [String]    ]

   │  Тип   │
   └ данных ┘

│     Тип       │
│    списка     │
└─ этих данных ─┘
```

Хранить данные разных типов в стандартном списке невозможно.

##### Действия над списками

 В стандартной Haskell-библиотеке существует отдельный модуль `Data.List`, включающий широкий набор функций, работающих со списком.

```haskell
-- Стандартный модуль для работы со списками.
import Data.List

main :: IO ()
main = putStrLn (head ["Vim", "Emacs", "Atom"])
```

Функция tail возвращает хвост:

```haskell
import Data.List

main :: IO ()
main = print (tail ["Vim", "Emacs", "Atom"])
```

Модель такая:

```haskell
["Vim"  ,  "Emacs", "Atom"]

 голова    └─── хвост ───┘
```

Функция `length` возвращает длинну списка

```haskell
main :: IO ()
main = print $ length [1..100]
```

##### Неизменность списка

Мы не можем изменить существующий список, мы можем лишь создать на его основе новый список

```haskell
addTo :: String -> [String] -> [String]
addTo newHost hosts = newHost : hosts

main :: IO ()
main = print ("124.67.54.90" `addTo` hosts)
  where hosts = ["45.67.78.89", "123.45.65.54"]
```

Стандартный оператор `:` добавляет значение, являющееся левым операндом, в начало списка, являющегося правым операндом. Читается это так:

```haskell
newHost   :         hosts

          этот
          оператор

берёт
это
значение
                    и добавляет
                    его в начало
                    этого списка
```

Тип значения слева обязан совпадать с типом значений, содержащихся в списке справа.

##### Перечисление

Нам понадобился список целых чисел от одного до десяти:

```haskell
main :: IO ()
main = print [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Сокращаем до:

```haskell
main :: IO ()
main = print [1..10]
```

Мы можем задать шаг

```haskell
main :: IO ()
main = print [2,4..10]
```

Схема:

```haskell
[2,      4      .. 10]

 первый            конец
         второй

 │  разница   │
 └─ даёт шаг ─┘
```

Можно задать и нисходящий диапазон:

```haskell
main :: IO ()
main = print [9,8..1]
```

Можно даже отрицательные числа:

```haskell
main :: IO ()
main = print [-9, -8.. -1]
```

Можно взять также и числа с плавающей точкой:

```haskell
main :: IO ()
main = print [1.02,1.04..1.16]
```

Символы:

```haskell
main :: IO ()
main = print ['a'..'z']
```

Символы с шагом:

```haskell
main :: IO ()
main = print ['a','c'..'z']
```

#### Кортеж

Кортеж (англ. tuple) — ещё одна стандартная структура данных, но, в отличие от списка, она может содержать данные как одного типа, так и разных.

Структуры, способные содержать данные разных типов, называют гетерогенными (в переводе с греческого: «разного рода»).

Вот как выглядит кортеж:

```haskell
("Haskell", 2010)
```

##### Тип кортежа

Тип списка строк, как вы помните, `[String]`. И не важно, сколько строк мы запихнули в список, одну или миллион — его тип останется неизменным. С кортежем же дело обстоит абсолютно иначе.

Тип кортежа зависит от количества его элементов. Вот тип кортежа, содержащего две строки:

```haskell
(String, String)
```

Вот ещё пример:

```haskell
(Double, Double, Int)
```

И ещё:

```haskell
(Bool, Double, Int, String)
```

Тип кортежа явно отражает его содержимое. Поэтому если функция применяется к кортежу из двух строк, применить её к кортежу из трёх никак не получится, ведь типы этих кортежей различаются:

```haskell
-- Разные типы
(String, String)
(String, String, String)
```

##### Действия над кортежами

Со списками можно делать много всего, а вот с кортежами — не очень. Самые частые действия — собственно формирование кортежа и извлечение хранящихся в нём данных. Например:

```haskell
makeAlias :: String -> String -> (String, String, String)
makeAlias host alias = (host, "https://" ++ host, alias)
```

Оператор `++` — это оператор конкатенации, склеивающий две строки в одну. Строго говоря, он склеивает два списка, но мы-то с вами уже знаем, что `String` есть ни что иное, как `[Char]`. Таким образом, `"https://"` ++ `"www.google.com"` даёт нам `"https://www.google.com"`.

Извлечение данных из кортежа:

```haskell
getHost :: (String, String, String) -> String
getHost host _ _ = host
```

Итого:

```haskell
makeAlias :: String -> String -> (String, String, String)
makeAlias host alias = (host, "https://" ++ host, alias)

getHttps :: (String, String, String) -> String
getHttps (host, https, alias) = host

main :: IO ()
main = print ( getHttps (makeAlias "173.194.71.106" "www.ohaskell.guide"))
```

Ещё один пример:

```haskell
chessMove :: String
          -> (String, String)
          -> (String, (String, String))
chessMove color (from, to) = (color, (from, to))

main :: IO ()
main = print (color ++ ": " ++ from ++ "-" ++ to)
  where
    (color, (from, to)) = chessMove "white" ("e2", "e4")
```

Можно использовать универсальный образец:

```haskell
-- Поясняющие псевдонимы
type UUID     = String
type FullName = String
type Email    = String
type Age      = Int
type Patient = (UUID, FullName, Email, Age)

patientEmail :: Patient -> Email
patientEmail (_, _, email, _) = email

main :: IO ()
main =
  putStrLn (patientEmail ( "63ab89d"
                         , "John Smith"
                         , "johnsm@gmail.com"
                         , 59
                         ))
```

##### Дополнение

Для работы с элементами многоэлементных кортежей можно использовать готовые библиотеки, во избежание длинных паттерн матчинговых цепочек. Например, пакет [tuple](http://hackage.haskell.org/package/tuple):

```haskell
Data.Tuple.Select

main :: IO ()
main = print (sel4 (123, 7, "hydra", "DC:4", 44, "12.04"))
```

Функция `sel4` из модуля `Data.Tuple.Select` извлекает четвёртый по счёту элемент кортежа, в данном случае строку `"DC:4"`. Там есть функции вплоть до `sel32`, авторы вполне разумно сочли, что никто, находясь в здравом уме и твёрдой памяти, не станет оперировать кортежами, состоящими из более чем 32 элементов.

Кроме того, мы и обновлять элементы кортежа можем:

```haskell
import Data.Tuple.Update

main :: IO ()
main = print (upd2 2 ("si", 45))
```

Естественно, по причине неизменности кортежа, никакого обновления тут не происходит, но выглядит симпатично. При запуске получаем результат:

```haskell
("si",2)
```

Второй элемент кортежа изменился с `45` на `2`.

#### Лямбда-функция

```haskell
\x -> x * x
```

Лямбда функции (они же анонимные функции)

Функцию можно записать как промежуточное значение 

```haskell
main :: IO ()
main = print (mul 10 4)
  where mul = \x y -> x * y
```

##### Локальные функции

Раз уж между ЛФ и простыми функциями фактически нет различий, а функции есть частный случай данных, мы можем создавать функции локально для других функций:

```haskell
-- Здесь определены функции
-- isInfixOf и isSuffixOf.
import Data.List

validComEmail :: String -> Bool
validComEmail email =
    containsAtSign email && endsWithCom email
  where
    containsAtSign e = "@" `isInfixOf` e
    endsWithCom e = ".com" `isSuffixOf` e

main :: IO ()
main = putStrLn (if validComEmail myEmail
                   then "It's ok!"
                   else "Non-com email!")
  where
    myEmail = "haskeller@gmail.com"
```

С лямбда-абстракциями:

```haskell
-- Здесь определены функции
-- isInfixOf и isSuffixOf.
import Data.List

validComEmail :: String -> Bool
validComEmail email =
    containsAtSign email && endsWithCom email
  where
    containsAtSign = \e -> "@" `isInfixOf` e
    endsWithCom = \e -> ".com" `isSuffixOf` e

main :: IO ()
main = putStrLn (if validComEmail myEmail
                   then "It's ok!"
                   else "Non-com email!")
  where
    myEmail = "haskeller@gmail.com"
```

Теперь выражения `containsAtSign` и `endsWithCom` приравнены к ЛФ от одного аргумента. В этом случае мы не указываем тип этих выражений. Впрочем, если очень хочется, можно и указать:

```haskell
containsAtSign =
    (\e -> "@" `isInfixOf` e) :: String -> Bool

    лямбда-абстракция            тип этой абстракции
```

Лямбда-абстракция взята в скобки, чтобы указание типа относилось к функции в целом, а не только к аргументу `e`:

```haskell
containsAtSign =
    \e -> "@" `isInfixOf` e :: String -> Bool

                               в этом случае это
                               тип аргумента e,
                               а вовсе не всей
                               функции!
```

#### Композиция функций

Если применение функции представляет собой выражение, не можем ли мы как-нибудь компоновать их друг с другом? Конечно можем, мы уже делали это много раз, вспомните:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "173.194.22.100")
```

Здесь компонуются две функции, `putStrLn` и `checkLocalhost`, потому что тип выражения на выходе функции `checkLocalhost` совпадает с типом выражения на входе функции `putStrLn`. Схематично это можно изобразить так:

```haskell
         ┌──────────────┐            ┌────────┐
String ->│checkLocalhost│-> String ->│putStrLn│-> ...
         └──────────────┘            └────────┘

IP-адрес                    сообщение             текст
                            об этом               в нашем
                            IP-адресе             терминале
```

Получается эдакий конвейер: на входе строка с IP-адресом, на выходе — сообщение в нашем терминале. Существует иной способ соединения двух функций воедино.

##### Композиция и применение

```haskell
main :: IO ()
main = putStrLn . checkLocalhost $ "173.194.22.100"
```

Необычно? Перед нами два новых стандартных оператора, избавляющие нас от лишних скобок и делающие наш код проще. Оператор `.` — это оператор композиции функций (англ. function composition), а оператор `$` — это оператор применения (англ. application operator). Эти операторы часто используют совместно друг с другом. И отныне мы будем использовать их чуть ли не в каждой главе.

Схема:

```haskell
UNCTION  $            ARGUMENT
вот эта   применяется  вот этому
функция   к            аргументу
```

Для нашей объединённой функции это выглядит так:

```haskell
main :: IO ()
main =
  putStrLn . checkLocalhost  $            "173.194.22.100"

  объединённая функция       применяется
                             к            этому аргументу
```

Ещё одно замечание про оператор применения функции. Он весьма гибок, и мы можем написать так:

```haskell
main = putStrLn . checkLocalhost $ "173.194.22.100"

       объединённая функция        └─ её аргумент ─┘
```

а можем и так:

```haskell
main = putStrLn $ checkLocalhost "173.194.22.100"

       обычная    └──────── её аргумент ────────┘
       функция
```

Эти две формы, как вы уже поняли, эквивалентны. Я показываю это для того, чтобы вновь и вновь продемонстрировать вам, сколь гибко можно работать с данными и функциями в Haskell.

##### Длинные цепочки

```haskell
func0 = \x -> x ++ "0"
func1 = \x -> x ++ "1"
func2 = \x -> x ++ "2"
func3 = \x -> x ++ "3"
func4 = \x -> x ++ "4"
func5 = \x -> x ++ "5"
func6 = \x -> x ++ "6"
func7 = \x -> x ++ "7"

main :: IO ()
main = print
  . func0
  . func1
  . func2
  . func3
  . func4
  . func5
  . func6
  . func7 $ ""
```

#### ФВП

ФВП, или Функции Высшего Порядка (англ. HOF, Higher Order Functions) — важная концепция в Haskell, с которой, однако, мы уже знакомы. Как мы узнали из предыдущих глав, функциями можно оперировать как значениями. Так вот функции, оперирующие другими функциями как аргументами и/или как результирующим выражением, носят название функций высшего порядка.

Так, оператор композиции функций является ФВП, потому что он, во-первых, принимает функции в качестве аргументов, а во-вторых, возвращает другую функцию (в виде ЛФ) как результат своего применения. Использование функций в качестве аргументов — чрезвычайно распространённая практика в Haskell.

##### Отображение

Функция `map`. Эта стандартная функция используется для отображения (англ. mapping) функции на элементы списка. Отображение функции на элемент фактически означает её применение к этому элементу.

Вот объявление функции `map`:

```haskell
map :: (a -> b) -> [a] -> [b]
```

Малой буквой принято именовать полиморфный (англ. polymorphic) тип. Полиморфизм — это многообразность, многоформенность. В данном случае речь идёт не об указании конкретного типа, а о «типовой заглушке». Мы говорим: «Функция `map` применяется к функции из какого-то типа `a` в какой-то тип `b` и к списку типа `[a]`, а результат её работы — это другой список типа `[b]`». Типовой заглушкой я назвал их потому, что на их место встают конкретные типы, что делает функцию `map` очень гибкой. Например:

```haskell
import Data.Char

toUpperCase :: String -> String
toUpperCase str = map toUpper str

main :: IO ()
main = putStrLn . toUpperCase $ "haskell.org"
```

Данное выражение:

```haskell
map toUpper "haskell.org"
```

Аналогично:

```haskell
map toUpper ['h','a','s','k','e','l','l','.','o','r','g']
```

Схема преобразования:

```haskell
map toUpper [ 'h'  >>  [ 'H'
            , 'a'  >>  , 'A'
            , 's'  >>  , 'S'
            , 'k'  >>  , 'K'
            , 'e'  >>  , 'E'
            , 'l'  >>  , 'L'
            , 'l'  >>  , 'L'
            , '.'  >>  , '.'
            , 'o'  >>  , 'O'
            , 'r'  >>  , 'R'
            , 'g'  >>  , 'G'
            ]          ]
```

Другой пример, когда типовые заглушки `a` и `b` замещаются разными типами:

```haskell
toStr :: [Double] -> [String]
toStr numbers = map show numbers

main :: IO ()
main = print . toStr $ [1.2, 1,4, 1.6]
```

И ещё:

```haskell
ten :: [Double] -> [Double]
ten = map (\n -> n * 10)

main :: IO ()
main = print . ten $ [1.2, 1,4, 1.6]
```

##### Частичное применение

Функция `map` ожидает два аргумента, это отражено в её типе. Но что будет, если применить её не к двум аргументам, а лишь к одному? В этом случае произойдёт ещё одно «магическое» превращение, называющееся частичным применением (англ. partial application) функции. Частичным называют такое применение, когда аргументов меньше чем ожидается.

Вспомним сокращённое определение функции `ten`:

```haskell
ten = map (\n -> n * 10)

          первый         а где же
          аргумент       второй??
          есть
```

Функция `map` получила лишь первый аргумент, а где же второй? Второй, как мы уже знаем, будет получен ею уже потом, после того, как мы подставим это выражение на место функции `ten`. Но что же происходит с функцией `map` до этого? А до этого с ней происходит частичное применение. Понятно, что она ещё не может выполнить свою работу, поэтому, будучи применённой лишь к одному аргументу, она возвращает ЛФ!

> Функция от нескольких аргументов может быть разложена на последовательность применений временных функций от одного аргумента каждая.

```haskell
main = print . (map (\n -> n * 10)) $ [1.2, 1,4, 1.6]

               │     частично     │
               └─ применённая map ┘

       │    композиция функции    │
       │     print и частично     │
       └───── применённой map ────┘
                                      аргумент для
                                      композиции
```

##### Композиция для отображения

Вернёмся к функции `map`. Если мы можем передать ей некую функцию для работы с элементами списка, значит мы можем передать ей и композицию двух или более функций. Например:

```haskell
import Data.Char

pretty :: [String] -> [String]
pretty = map (stars . big)
  where
    big = map toUpper
    stars = \s -> "* " ++ s ++ " *"

main :: IO ()
main = print . pretty $ ["haskell", "lisp", "coq"]
```

#### Hackage и библиотеки

Ранее я уже упоминал о библиотеках, пришло время познакомиться с ними поближе, ведь в последующих главах мы будем использовать их постоянно.

##### Библиотеки большие и маленькие

За годы существования Haskell разработчики со всего мира создали множество библиотек. Библиотеки избавляют нас от необходимости вновь и вновь писать то, что уже написано до нас. Для любого живого языка программирования написано множество библиотек. В мире Haskell их, конечно, не такая туча, как для той же Java, но порядочно: стабильных есть не менее двух тысяч, многие из которых очень качественные и уже многократно испытаны в серьёзных проектах.

С модулями — файлами, содержащими Haskell-код, — мы уже знакомы, они являются основным кирпичом любого Haskell-проекта. Библиотека, также являясь Haskell-проектом, тоже состоит из модулей (не важно, из одного или из сотен). Поэтому использование библиотеки сводится к использованию входящих в неё модулей. И мы уже неоднократно делали это в предыдущих главах.

Вспомним пример из главы про ФВП:

```haskell
import Data.Char

toUpperCase :: String -> String
toUpperCase str = map toUpper str

main :: IO ()
main = putStrLn . toUpperCase $ "haskell.org"
```

Функция `toUpper` определена в модуле `Data.Char`, который, в свою очередь, живёт в стандартной библиотеке. Библиотек есть множество, но стандартная лишь одна. Она содержит самые базовые, наиболее широко используемые инструменты. А прежде чем продолжить, зададимся важным вопросом: «Где живут все эти библиотеки?» Они живут в разных местах, но главное из них — Hackage.

##### Hackage

Hackage — это центральный репозиторий Haskell-библиотек, или, как принято у нас называть, пакетов (англ. package). Название репозитория происходит от слияния слов `Haskell` и `package`. Hackage существует с 2008 года и живёт [здесь](http://hackage.haskell.org/). Ранее упомянутая стандартная библиотека тоже живёт в Hackage и называется она `base`. Каждой библиотеке выделена своя страница.

Каждый из Hackage-пакетов живёт по адресу, сформированному по неизменной схеме: `http://hackage.haskell.org/package/ИМЯПАКЕТА`. Так, дом стандартной библиотеки — `http://hackage.haskell.org/package/base`. Hackage — открытый репозиторий: любой разработчик может добавить туда свои пакеты.

Стандартная библиотека включает в себя более сотни модулей, но есть среди них самый известный, носящий имя `Prelude`. Этот модуль по умолчанию всегда с нами: всё его содержимое автоматически импортируется во все модули нашего проекта.

Hackage весьма большой, поэтому искать пакеты можно двумя способами. Первый — на [единой странице всех пакетов](http://hackage.haskell.org/packages/). Здесь перечислены все пакеты, а для нашего удобства они расположены по тематическим категориям.

Второй способ — через специальный поисковик, коих существует два:

1. [Hoogle](https://hoogle.haskell.org/)
2. [Hayoo!](http://holumbus.fh-wedel.de/hayoo/hayoo.html)

К сожалению Hayoo недоступен... 

Рассказывается как правильно импортировать, экспортировать модули и функции.

#### Рекурсия

> Чтобы понять рекурсию, нужно сначала понять рекурсию.

Идея рекурсии предельно проста:

> Если нам нужно повторить вычисление, производимое некой функцией, мы должны применить эту функцию внутри себя самой. И получится зацикливание.

Взглянем на определение функции `map`:

```haskell
map _ []     = []
map f (x:xs) = f x : map f xs
```

А теперь разберём это интереснейшее определение по косточкам.

##### Правда о списке

Первым аргументом, как мы помним, выступает некая функция, а вторым — список, к элементам которого применяется эта функция. Но что это за странного вида конструкция в круглых скобках?

```haskell
(x:xs)
```

Это — особый образец, используемый для работы со списками. И чтобы он стал понятен, я должен рассказать вам правду о формировании списка.

Как мы помним, формируется список предельно просто:

```haskell
[1, 2, 3]  -- Список из трёх целых чисел.
```

Однако в действительности он формируется несколько иначе. Привычная нам конструкция в квадратных скобках есть ни что иное, как синтаксический сахар (англ. syntactic sugar). Синтаксическим сахаром называют некое упрощение кода, делающее его слаще, приятнее для нас. Если же мы уберём сахар (или, как ещё говорят, рассахарим код), то увидим вот что:

```haskell
1 : 2 : 3 : []
```

Именно так список из трёх целых чисел формируется на самом деле. Стандартный оператор `:` нам уже знаком, мы встретились с ним в главе о списках:

```haskell
newHost   :         hosts

          этот
          оператор

берёт
это
значение
                    и добавляет
                    его в начало
                    этого списка
```

То есть список строится путём добавления элемента в его «голову», начиная с пустого списка:

```haskell
  1 : 2 : 3 : []

= 1 : 2 : [3]

= 1 : [2, 3]

= [1, 2, 3]
```

Далее разжевывается как работает функция `map`

##### Туда и обратно

Определяя рекурсивную функцию, важно помнить о том, что в ней должно быть как правило зацикливания, так и правило выхода из цикла:

```haskell
map _ []     = []              -- Выходим из цикла.
map f (x:xs) = f x : map f xs  -- Зацикливаемся,
                               -- применяя саму себя.
```

Если бы мы опустили первое определение, компилятор предусмотрительно сообщил бы нам о проблеме:

```
Pattern match(es) are non-exhaustive
```

И это совершенно правильно: если на каждой итерации мы уменьшаем список, то рано или поздно список точно останется пустым, а следовательно, мы обязаны объяснить, что же делать в этом случае.

##### Для любопытных

Открою секрет: рекурсивными в Haskell бывают не только функции, но и типы. Но об этом в последующих главах.

#### Лень

Объясняется две модели вычисления аргументов, а именно энергичная (англ. eager) и ленивая (англ. lazy).

При энергичной модели (называемой ещё «жадной» или «строгой») выражение, являющееся аргументом функции, будет вычислено ещё до того, как попадёт в тело функции. На фоне определения функции `square` будет яснее:

```haskell
square     x   = x * x
         /   \
square $ 2 + 2
         \   /
           4   = 4 * 4 = 16
```

То есть видим выражение `2 + 2`, жадно на него набрасываемся, полностью вычисляем, а уже потом результат этого вычисления передаём в функцию `square`.

При ленивой же модели всё наоборот: выражение, являющееся аргументом функции, передаётся в функцию прямо так, без вычисления. Изобразить это можно следующим образом:

```haskell
square     x   =    x    *    x
         /   \    /   \     /   \
square $ 2 + 2 = (2 + 2) * (2 + 2) = 16
```

Но какая разница, спросите вы? Всё равно в итоге получим `16`, хоть там сложили, хоть тут. Так и есть: модель вычисления не влияет на результат этого вычисления, но она влияет на путь к этому результату.

##### Рациональность

Как уже было упомянуто, ленивая стратегия помогает программе быть рациональной и не делать лишнюю работу. Рассмотрим пример:

```haskell
main :: IO ()
main = print $ take 5 evens
  where evens = [2, 4 .. 100]
```

##### Бесконечность

А что будет, если мы запросим из списка `evens` 500 элементов? Вот так:

```haskell
main :: IO ()
main = print $ take 500 evens
  where evens = [2, 4 .. 100]
```

Ничего страшного не случится, функция `take` проверяет выход за границы и в случае, если её первый аргумент превышает длину списка, она просто даёт нам тот же список. Да, но ведь мы хотим увидеть пятьсот чётных чисел, а не пятьдесят! Можно было бы увеличить список:

```haskell
main :: IO ()
main = print $ take 500 evens
  where evens = [2, 4 .. 100000]
```

но это ненадёжно, ведь потом опять может потребоваться ещё больше. Нужно что-нибудь универсальное, и в Haskell есть подходящее решение:

```haskell
main :: IO ()
main = print $ take 500 evens
  where evens = [2, 4 ..]  -- Что это?
```

Теперь не сомневайтесь: в списке `evens` будет не менее пятисот чётных чисел. Но что это за конструкция такая? Начало дано, шаг дан, а где же конец? Познакомьтесь, это бесконечный список:

```haskell
[2, 4 ..]
```
  
Конечно, если бы мы решили похулиганить:

```haskell
main :: IO ()
main = print evens  -- Дай нам всё!
  where evens = [2, 4 ..]
```

##### Space leak

Да, я должен рассказать вам правду: есть у ленивой стратегии вычислений тёмная сторона, получившая название space leak (букв. «утечка пространства»). И вот в чём её суть.

Вспомним пример с делением:

```haskell
main :: IO ()
main = print . strange $ 2 `div` 0
```

Как мы помним, деления на ноль так и не произошло за ненадобностью его результата. В этом случае выражение осталось в виде thunk. Возникает вопрос: что же с ним стало? У нас есть функция `div` и есть два значения типа `Int`, `2` и `0`. Если функция `div` так и не была применена к ним, где же всё это хозяйство находилось в процессе работы нашей программы? Оно находилось в памяти, в виде особого графа, который можно изобразить так:

```haskell
 ┌─────────────┐
 │ div │   │   │
 └─────────────┘
         │   │
         v   v
      ┌───┐ ┌───┐
      │ 2 │ │ 0 │
      └───┘ └───┘
```

То есть сама функция и два значения, которые должны были занять место двух её аргументов. И вот этот граф в памяти так и остался невостребованным. Казалось бы, ну и в чём проблема? А проблема в количестве. Если мы смогли написать код, при работе которого в память отложился один thunk, значит теоретически мы можем написать и такой код, количество thunk-ов при работе которого будет исчисляться миллионами. А учитывая тот факт, что каждый thunk занимает в памяти хотя бы несколько байт, вы можете себе представить масштаб проблемы.

Причём возникнуть эта проблема может из весьма невинного на первый взгляд кода:

```haskell
bad :: [Int] -> Int -> Int
bad []         c = c
bad (_:others) c = bad others $ c + 1
```

Простенькая рекурсивная функция, пробегающаяся по ненужному ей списку и увеличивающаяся свой второй аргумент на единицу. Но я не просто так назвал её `bad`. Давайте применим её:

```haskell
bad [1, 2, 3] 0
```

Подставим в определение, содержащее зацикливание:

```haskell
bad (_: others) c = bad others $ c + 1

bad [1, 2, 3]   0 = bad [2, 3] $ 0 + 1

        ____            ______

                =                =
```

«Голова» списка откусывается и игнорируется, а к `0` прибавляется `1`. Но поскольку результат сложения пока что никому не нужен, сложение не производится. Вместо этого, на второй итерации, мы видим следующее:

```haskell
bad [2, 3] $ 0 + 1 = bad [3] $ (0 + 1) + 1
```

К предыдущему выражению вновь прибавляется единица — и мы опять входим в очередную итерацию, так и не выполнив сложения:

```haskell
bad [3] $ (0 + 1) + 1 = bad [] $ ((0 + 1) + 1) + 1
```

Опа! Упёрлись в пустой список, вспоминаем правило выхода из рекурсии:

```haskell
bad [] c = c
```

Итак, в этом случае мы просто возвращаем значение второго аргумента. Сделаем же это:

```haskell
bad [] $ ((0 + 1) + 1) + 1 = ((0 + 1) + 1) + 1 = 3
```

И вот только здесь мы реально вычисляем второй аргумент, складывая три единицы. Вы спросите, почему же мы накапливали эти сложения вместо того, чтобы делать их сразу? Потому что мы ленивы: раз результат сложения понадобился нам лишь на последней итерации, значит до этой итерации никакого сложения не будет, ведь лень вынуждает нас откладывать работу до конца.

Вот в этом-то накоплении вся беда. Представим, что мы написали так:

```haskell
main :: IO ()
main = print $ bad [1..50000000] 0
```

50 миллионов элементов, а значит, 50 миллионов раз сложение второго аргумента с единицей будет откладываться, накапливая гигантский «хвост» из (пока что) невычисленных выражений. Хотите знать, что произойдёт при запуске такой программы? Её выполнение, на MacBook Pro 2014 года, займёт приблизительно 63 секунды и скушает, ни много ни мало, 6,4 ГБ памяти! А теперь представьте, что случилось бы, если бы элементов в списке было не 50 миллионов, а 50 миллиардов…

Иногда space leak ошибочно путают с другой проблемой, называемой memory leak (англ. «утечка памяти»), однако это вовсе не одно и то же. Утечка памяти — это ошибка, характерная для языков с ручным управлением памятью, например, C. Если мы выделим память в куче (англ. heap), а затем потеряем указатель, связывающий нас с этой памятью — всё, выделенная память утекла, она потеряна для нас навеки. Но в случае space leak мы не теряем память: когда весь этот «хвост» из сложений в конце концов вычислится, память, занимаемая миллионами thunk-ов, освободится. Мы не теряем память, мы просто используем её слишком много.

##### Борьба

мы должны убрать излишнюю ленивость и заменить её строгостью.
Вот два способа.

###### Оптимизация

Первый способа самый простой — оптимизация. Когда компилятор превращает наш код в программу, его можно попросить оптимизировать наш код, сделав его более эффективным, по тем или иным критериям. Чтобы попросить компилятор провести оптимизацию, мы должны использовать специальный флаг. Откроем сборочный файл нашего проекта `real.cabal`, найдём секцию `executable real-exe`, в которой есть строка:

```haskell
  ghc-options:         ...
```

Эта строка содержит различные опции компилятора GHC, и оптимизационный флаг дописывается именно сюда. Попробуем подставить туда сначала флаг `-O0`, а затем `-O2`. Результаты запуска программы будут такими:

```haskell
Оптимизация    Время    Память

-O0            63 c     6,4 ГБ

-O2            3,2 с    104 кБ
```

Впечатляющая разница, не правда ли? Флаг `-O0` говорит компилятору о том, чтобы тот не производил никакую оптимизацию, в этом случае говорят о нулевом уровне оптимизации. Флаг `-O2`, напротив, устанавливает стандартный для production-проектов уровень оптимизации. Так вот при стандартном уровне компилятор способен распознать излишнюю ленивость в нашем коде и добавить чуток жадности. В примере выше компилятор увидит накопление thunk-ов сложения и пресечёт оное. Согласитесь, с гигабайтов прыгнуть сразу на килобайты — это круто.

Так что же, проблемы нет? Ну, если оптимизация `-O2` и так стандартна — так давайте ставить её в наши проекты и забудем про space leak! К сожалению, не всё так просто.

Во-первых, компиляторная оптимизация сродни чёрной магии, на неё трудно полагаться. Мы очень благодарны компилятору GHC за попытку помочь нам, но эта помощь не всегда соответствует нашим ожиданиям. И во-вторых, к сожалению, компилятор не всегда способен распознать излишнюю лень в нашем коде, и в этом случае нам приходится-таки прибегнуть ко второму способу борьбы со space leak.

###### Вручную

Вернёмся к определению функции `bad`:

```haskell
bad :: [Int] -> Int -> Int
bad []         c = c
bad (_:others) c = bad others $ c + 1
```

Проблема, как мы уже поняли, во втором аргументе:

```haskell
bad others $ c + 1

             накопление
             thunk-ов...
```

Превратим же злую функцию в добрую:

```haskell
good :: [Int] -> Int -> Int
good []         c = c
good (_:others) c = good others $! c + 1
```

Этот код даст нам приблизительно такой же выигрыш, что и оптимизация уровня `-O2`: секунды вместо минуты и килобайты вместо гигабайтов. Что же изменилось? Смотрим внимательно:

```haskell
good others $! c + 1

             ^
```

Вместо привычного оператора применения `$` мы видим оператор строго применения `$!` (англ. strict application operator). Этот оператор говорит аргументу: «Забудь о лени, я приказываю тебе немедленно вычислиться до слабой головной формы»:

```haskell
good others $!       c + 1

            вычисли  этот
                     аргумент

            строго,
            а не
            лениво!
```

Вот потому-то наш «хвост» из thunk-ов и не будет накапливаться, ведь на каждой из 50 миллионов итераций будет происходить незамедлительное применение оператора сложения. Таким образом, заставить аргумент тут же вычислиться до слабой головной или нормальной формы можно как посредством того, что этот аргумент прямо сейчас кому-то понадобился, так и посредством строгого применения.

##### Лень и строгость вместе

Функцию называют ленивой по тем аргументам, которые не вычисляются, и строгой по тем аргументам, которые вычисляются. Примитивный пример:

```haskell
fakeSum :: Int -> Int -> Int
fakeSum x _ = x + 100
```

Функция `fakeSum` строга по своему первому аргументу и ленива по своему второму аргументу. Первый аргумент `x` непременно будет вычислен, ведь он передаётся оператору сложения. Второй же аргумент игнорируется, оставшись невычисленным. И кстати, существует простой способ проверить, строга ли функция по некоторому аргументу или ленива.

В стандартной библиотеке Haskell определена особая функция `undefined`. Это — чёрная дыра: при попытке прикоснуться к ней программа гарантированно падает с ошибкой. Проверяем:

```haskell
main :: IO ()
main = print $ fakeSum 1 undefined
```

В этом случае мы получим результат:

```haskell
101
```

Чёрная дыра была проигнорирована, ведь функция `fakeSum` ленива по второму аргументу. Если же мы напишем так:

```haskell
main :: IO ()
main = print $ fakeSum undefined 45
```

программа, попытавшись передать `undefined` оператору сложения, аварийно остановится. Или вот другой пример:

```haskell
main :: IO ()
main = print . head $ [23, undefined, undefined]
```

Не сомневайтесь: программа спокойно вернёт нам `23`, ведь функция `head` строга лишь по первому элементу переданного ей списка, остальное содержимое оного её абсолютно не интересует. Но если попробуете вытащить второй или третий элемент из подобного списка — крах неминуем.

##### Для любопытных

Haskell — не первый язык с ленивой стратегией вычислений. Открою вам исторический факт: у языка Haskell был предшественник, язык программирования с красивым женским именем [Miranda](https://en.wikipedia.org/wiki/Miranda_(programming_language)). Лень и чистая функциональность пришли в Haskell именно из Miranda, и лишь в этих двух языках ленивая стратегия вычисления аргументов используется по умолчанию. На сегодняшний день, насколько мне известно, язык Miranda мёртв. Впрочем, как сугубо исследовательский язык он, может быть, кем-то и используется.

Что же касается проблемы space leak, то к счастью, существуют способы обнаружения функций, шибко прожорливых до памяти. В самом деле, представьте себе большой проект, тысячи функций, и что-то кушает гигабайты памяти. Как найти виновного? Этот процесс называют ещё «space leak профилированием». Рассказывать об этом здесь я не стану, материал довольно объёмный. Но для особо любопытных привожу ссылку на неплохую англоязычную статью по теме: [Chasing a Space Leak in Shake](http://neilmitchell.blogspot.am/2013/02/chasing-space-leak-in-shake.html).

И ещё вспомним вот это:

```haskell
square     x   =    x      *    x
         /   \    /   \       /   \
square $ 2 + 2 = (2 + 2)   * (2 + 2)    = 16

                 вычисляем   и что,
                             опять
                             вычисляем?!
```

Внимательный читатель удивится, мол, неужели выражение `2 + 2` вычисляется дважды?! Ведь это нерационально. Конечно нерационально, поэтому в действительности оно будет вычислено единожды. В Haskell есть особый механизм «шаринга» (англ. sharing), позволяющий избежать напрасной работы. И если у нас есть несколько одинаковых выражений, вычисление оного происходит один раз, результат же сохраняется и потом просто подставляется в нужные места. Например:

```
main :: IO ()
main =
  let x = sin 2 in print x * x
```

Если бы не sharing-механизм, функция `sin` была бы применена к `2` дважды. К счастью, значение синуса будет вычислено единожды и тут же сохранено, чтобы потом просто встать на места тех двух `x`.

#### Наши типы

Удивительно, но в Haskell очень мало встроенных типов, то есть таких, о которых компилятор знает с самого начала. Есть `Int`, есть `Double`, `Char`, ну и ещё несколько. Все же остальные типы, даже носящие статус стандартных, не являются встроенными в язык. Вместо этого они определены в стандартной или иных библиотеках, причём определены точно так же, как мы будем определять и наши собственные типы. А поскольку без своих типов написать сколь-нибудь серьёзное приложение у нас не получится, тема эта достойна самого пристального взгляда.

Определим тип `Transport` для двух известных протоколов транспортного уровня модели OSI:

```haskell
data Transport = TCP | UDP
```

Перед нами — очень простой, но уже наш собственный тип. Рассмотрим его внимательнее.

Ключевое слово `data` — это начало определения типа. Далее следует название типа, в данном случае `Transport`. Имя любого типа обязано начинаться с большой буквы. Затем идёт знак равенства, после которого начинается фактическое описание типа, его «тело». В данном случае оно состоит из двух простейших конструкторов. Конструктор значения (англ. data constructor) — это то, что строит значение данного типа. Здесь у нас два конструктора, `TCP` и `UDP`, каждый из которых строит значение типа `Transport`. Имя конструктора тоже обязано начинаться с большой буквы. Иногда для краткости конструктор значения называют просто конструктором.

Подобное определение легко читается:

```haskell
data  Transport  =    TCP  |    UDP

тип   Transport  это  TCP  или  UDP
```

Теперь мы можем использовать тип `Transport`, то есть создавать значения этого типа и что-то с ними делать. Например, в `let`-выражении:

```haskell
  let protocol = TCP
```

Мы создали значение `protocol` типа `Transport`, использовав конструктор `TCP`. А можно и так:

```haskell
  let protocol = UDP
```

Хотя мы использовали разные конструкторы, тип значения `protocol` в обоих случаях один и тот же — `Transport`.

Расширить подобный тип предельно просто. Добавим новый протокол SCTP (Stream Control Transmission Protocol):

```haskell
data Transport = TCP | UDP | SCTP
```

Третий конструктор значения дал нам третий способ создать значение типа `Transport`.

##### Значение-пустышка

Задумаемся: говоря о значении типа `Transport` — о чём в действительности идёт речь? Казалось бы, значения-то фактического нет: ни числа никакого, ни строки — просто три конструктора. Так вот они и есть значения. Когда мы пишем:

```haskell
  let protocol = SCTP
```

мы создаём значение типа `Transport` с конкретным содержимым в виде `SCTP`. Конструктор — это и есть содержимое. Данный вид конструктора называется нульарным (англ. nullary). Тип `Transport` имеет три нульарных конструктора. И даже столь простой тип уже может быть полезен нам:

```haskell
checkProtocol :: Transport -> String
checkProtocol transport = case transport of
  TCP  -> "That's TCP protocol."
  UDP  -> "That's UDP protocol."
  SCTP -> "That's SCTP protocol."

main :: IO ()
main = putStrLn . checkProtocol $ TCP
```

В результате увидим:

```haskell
That's TCP protocol.
```

Функция `checkProtocol` объявлена как принимающая аргумент типа `Transport`, а применяется она к значению, порождённому конструктором `TCP`. В данном случае конструкция `case-of` сравнивает аргумент с конструкторами. Именно поэтому нам не нужна функция `otherwise`, ведь никаким иным способом, кроме как с помощью трёх конструкторов, значение типа `Transport` создать невозможно, а значит, один из конструкторов гарантированно совпадёт.

Тип, состоящий только из нульарных конструкторов, называют ещё перечислением (англ. enumeration). Конструкторов может быть сколько угодно, в том числе один-единственный (хотя польза от подобного типа была бы невелика). Вот ещё один известный пример:

```haskell
data Day = Sunday
         | Monday
         | Tuesday
         | Wednesday
         | Thursday
         | Friday
         | Saturday
```

Обратите внимание на форматирование, когда ментальные «ИЛИ» выровнены строго под знаком равенства. Такой стиль вы встретите во многих реальных Haskell-проектах.

Значение типа `Day` отражено одним из семи конструкторов. Сделаем же с ними что-нибудь:

```haskell
data WorkMode = FiveDays | SixDays

workingDays :: WorkMode -> [Day]
workingDays FiveDays = [ Monday
                       , Tuesday
                       , Wednesday
                       , Thursday
                       , Friday
                       ]
workingDays SixDays = [ Monday
                      , Tuesday
                      , Wednesday
                      , Thursday
                      , Friday
                      , Saturday
                      ]
```

Итого рабочий пример от меня:

```haskell
data Day = Sunday
         | Monday
         | Tuesday
         | Wednesday
         | Thursday
         | Friday
         | Saturday

data WorkMode = FiveDays | SixDays

workingDays :: WorkMode -> [Day]
workingDays FiveDays = [ Monday
                       , Tuesday
                       , Wednesday
                       , Thursday
                       , Friday
                       ]
workingDays SixDays = [ Monday
                      , Tuesday
                      , Wednesday
                      , Thursday
                      , Friday
                      , Saturday
                      ]

dayToString :: Day -> String
dayToString Sunday    = "Sunday"
dayToString Monday    = "Monday"
dayToString Tuesday   = "Tuesday"
dayToString Wednesday = "Wednesday"
dayToString Thursday  = "Thursday"
dayToString Friday    = "Friday"
dayToString Saturday  = "Saturday"



main :: IO ()
main = print . map dayToString $ workingDays SixDays
```

Функция `workingDays` возвращает список типа `[Day]`, и в случае пятидневной рабочей недели, отражённой конструктором `FiveDays`, этот список сформирован пятью конструкторами, а в случае шестидневной — шестью конструкторами.

Польза от типов, сформированных нульарными конструкторами, не очень велика, хотя встречаться с такими типами вы будете часто.

Приоткрою секрет: новый тип можно определить не только с помощью ключевого слова `data`, но об этом узнаем в одной из следующих глав.

А теперь мы можем познакомиться с типами куда более полезными.

#### АТД

АТД, или Алгебраические Типы Данных (англ. ADT, Algebraic Data Type), занимают почётное место в мире типов Haskell. Абсолютно подавляющее большинство ваших собственных типов будут алгебраическими, и то же можно сказать о типах из множества Haskell-пакетов. Алгебраическим типом данных называют такой тип, который составлен из других типов. Мы берём простые типы и строим из них, как из кирпичей, типы сложные, а из них — ещё более сложные. Это даёт нам невероятный простор для творчества.

Оставим сетевые протоколы и дни недели, рассмотрим такой пример:

```haskell
data IPAddress = IPAddress String
```

Тип `IPAddress` использует один-единственный конструктор значения, но кое-что изменилось. Во-первых, имена типа и конструктора совпадают. Это вполне легально, вы встретите такое не раз. Во-вторых, конструктор уже не нульарный, а унарный (англ. unary), потому что теперь он связан с одним значением типа `String`. И вот как создаются значения типа `IPAddress`:

```haskell
  let ip = IPAddress "127.0.0.1"
```

Значение `ip` типа `IPAddress` образовано конструктором и конкретным значением некоего типа:

```haskell
  let ip = IPAddress       "127.0.0.1"

           конструктор     значение
           значения        типа
           типа IPAddress  String

           └ значение типа IPAddress ┘
```

Значение внутри нашего типа называют ещё полем (англ. field):

```haskell
data IPAddress = IPAddress    String

     тип         конструктор  поле
```

Расширим тип `IPAddress`, сделав его более современным:

```haskell
data IPAddress = IPv4 String | IPv6 String
```

Теперь у нас два конструктора, соответствующих разным IP-версиям. Это позволит нам создавать значение типа `IPAddress` так:

```haskell
  let ip = IPv4 "127.0.0.1"
```

или так:

```haskell
  let ip = IPv6 "2001:0db8:0000:0042:0000:8a2e:0370:7334"
```

Сделаем тип ещё более удобным. Так, при работе с IP-адресом нам часто требуется `localhost`. И чтобы явно не писать `"127.0.0.1"` и `"0:0:0:0:0:0:0:1"`, введём ещё два конструктора:

```haskell
data IPAddress = IPv4 String
               | IPv4Localhost
               | IPv6 String
               | IPv6Localhost
```

Поскольку значения `localhost` нам заведомо известны, нет нужды указывать их явно. Вместо этого, когда нам понадобится `IPv4-localhost`, пишем так:

```haskell
    let ip = IPv4Localhost
```

##### Извлекаем значение

Допустим, мы создали значение `google`:

```haskell
  let google = IPv4 "173.194.122.194"
```

Как же нам потом извлечь конкретное строковое значение из `google`? С помощью нашего старого друга, паттерн матчинга:

```haskell
checkIP :: IPAddress -> String
checkIP (IPv4 address) = "IP is '" ++ address ++ "'."

main :: IO ()
main = putStrLn . checkIP $ IPv4 "173.194.122.194"
```

Результат:

```haskell
IP is '173.194.122.194'.
```

Взглянем на определение:

```haskell
checkIP (IPv4 address) = "IP is '" ++ address ++ "'."
```

Здесь мы говорим: «Мы знаем, что значение типа `IPAddress` сформировано с конструктором и строкой». Однако внимательный компилятор сделает нам замечание:

```haskell
Pattern match(es) are non-exhaustive
In an equation for ‘checkIP’:
    Patterns not matched:
        IPv4Localhost
        IPv6 _
        IPv6Localhost
```

В самом деле, откуда мы знаем, что значение, к которому применили функцию `checkIP`, было сформировано именно с помощью конструктора `IPv4`? У нас же есть ещё три конструктора, и нам следует проверить их все:

```haskell
checkIP :: IPAddress -> String
checkIP (IPv4 address) = "IPv4 is '" ++ address ++ "'."
checkIP IPv4Localhost  = "IPv4, localhost."
checkIP (IPv6 address) = "IPv6 is '" ++ address ++ "'."
checkIP IPv6Localhost  = "IPv6, localhost."
```

С каким конструктором совпало — с таким и было создано значение. Можно, конечно, и так проверить:

```haskell
checkIP :: IPAddress -> String
checkIP addr = case addr of
    IPv4 address  -> "IPv4 is '" ++ address ++ "'."
    IPv4Localhost -> "IPv4, localhost."
    IPv6 address  -> "IPv6 is '" ++ address ++ "'."
    IPv6Localhost -> "IPv6, localhost."
```

##### Строим

Определим тип для сетевой точки:

```haskell
data EndPoint = EndPoint String Int
```

Конструктор `EndPoint` — бинарный, ведь здесь уже два значения. Создаём обычным образом:

```haskell
  let googlePoint = EndPoint "173.194.122.194" 80
```

Конкретные значения извлекаем опять-таки через паттерн матчинг:

```haskell
main :: IO ()
main = putStrLn $ "The host is: " ++ host
  where
    EndPoint host _ = EndPoint "173.194.122.194" 80

    └── образец ──┘   └──────── значение ─────────┘
```

Обратите внимание, что второе поле, соответствующее порту, отражено универсальным образцом `_`, потому что в данном случае нас интересует только значение хоста, а порт просто игнорируется.

И всё бы хорошо, но тип `EndPoint` мне не очень нравится. Есть в нём что-то некрасивое. Первым полем выступает строка, содержащая IP-адрес, но зачем нам строка? У нас же есть прекрасный тип `IPAddress`, он куда лучше безликой строки. Это общее правило для Haskell-разработчика: чем больше информации несёт в себе тип, тем он лучше. Давайте заменим определение:

```haskell
data EndPoint = EndPoint IPAddress Int
```

Тип стал понятнее, и вот как мы теперь будем создавать значения:

```haskell
  let google = EndPoint (IPv4 "173.194.122.194") 80
```

Красиво. Извлекать конкретные значения будем так:

```haskell
main :: IO ()
main = putStrLn $ "The host is: " ++ ip
  where
    EndPoint (IPv4 ip) _ = EndPoint (IPv4 "173.194.122.194") 80
              ____                   ____

                   ==                     =================
```

Здесь мы опять-таки игнорируем порт, но значение IP-адреса извлекаем уже на основе образца с конструктором `IPv4`.

Это простой пример того, как из простых типов строятся более сложные. Но сложный тип вовсе не означает сложную работу с ним, паттерн матчинг элегантен как всегда. А вскоре мы узнаем о другом способе работы с полями типов, без паттерн матчинга.

Любопытно, что конструкторы типов тоже можно компоновать, взгляните:

```haskell
main :: IO ()
main = putStrLn $ "The host is: " ++ ip
  where
    EndPoint (IPv4 ip) _ = (EndPoint . IPv4 $ "173.194.122.194") 80
```

Это похоже на маленькое волшебство, но конструкторы типов можно компоновать знакомым нам оператором композиции функций:

```haskell
(EndPoint . IPv4 $ "173.194.122.194") 80

            │       значение типа      │
            └──────── IPAddress ───────┘
```

Вам это ничего не напоминает? Это же в точности так, как мы работали с функциями! Из этого мы делаем вывод: конструктор значения можно рассматривать как особую функцию. В самом деле:

```haskell
EndPoint   (IPv4 "173.194.122.194")  80

"функция"  │        первый        │  второй
           └────── аргумент ──────┘  аргумент
```

Мы как бы применяем конструктор к конкретным значениям как к аргументам, в результате чего получаем значение нашего типа. А раз так, мы можем компоновать конструкторы так же, как и обычные функции, лишь бы их типы были комбинируемыми. В данном случае всё в порядке: тип значения, возвращаемого конструктором `IPv4`, совпадает с типом первого аргумента конструктора `EndPoint`.

Вот мы и познакомились с настоящими типами. Пришло время узнать о более удобной работе с полями типов.

Итого:

```haskell
data IPAddress = IPv4 String
               | IPv4Localhost
               | IPv6 String
               | IPv6Localhost

checkIP :: IPAddress -> String
checkIP (IPv4 address) = "IPv4 is '" ++ address ++ "'."
checkIP IPv4Localhost  = "IPv4, localhost."
checkIP (IPv6 address) = "IPv6 is '" ++ address ++ "'."
checkIP IPv6Localhost  = "IPv6, localhost."


data EndPoint = EndPoint IPAddress Int


main :: IO ()
main = putStrLn $ "The host is: " ++ ip
  where
    EndPoint (IPv4 ip) _ = EndPoint (IPv4  "173.194.122.194") 80
```

#### АТД: поля с метками

Многие типы в реальных проектах довольно велики. Взгляните:

```haskell
data Arguments = Arguments Port
                           Endpoint
                           RedirectData
                           FilePath
                           FilePath
                           Bool
                           FilePath
```

Значение типа `Arguments` хранит в своих полях некоторые значения, извлечённые из параметров командной строки, с которыми запущена одна из моих программ. И всё бы хорошо, но работать с таким типом абсолютно неудобно. Он содержит семь полей, и паттерн матчинг был бы слишком громоздким, представьте себе:

```haskell
...
  where
    Arguments _ _ _ redirectLib _ _ xpi = arguments
```

Более того, когда мы смотрим на определение типа, назначение его полей остаётся тайной за семью печатями. Видите предпоследнее поле? Оно имеет тип `Bool` и, понятное дело, отражает какой-то флаг. Но что это за флаг, читатель не представляет. К счастью, существует способ, спасающих нас от обеих этих проблем.

##### Метки

Мы можем снабдить наши поля метками (англ. label). Вот как это выглядит:

```haskell
data Arguments = Arguments { runWDServer    :: Port
                           , withWDServer   :: Endpoint
                           , redirect       :: RedirectData
                           , redirectLib    :: FilePath
                           , screenshotsDir :: FilePath
                           , noScreenshots  :: Bool
                           , harWithXPI     :: FilePath
                           }
```

Теперь назначение меток куда понятнее. Схема определения такова:

```haskell
data Arguments = Arguments   { runWDServer :: Port }

тип  такой-то    конструктор   метка поля     тип
                                              поля
```

Теперь поле имеет не только тип, но и название, что и делает наше определение значительно более читабельным. Поля в этом случае разделены запятыми и заключены в фигурные скобки.

Если подряд идут два или более поля одного типа, его можно указать лишь для последней из меток. Так, если у нас есть вот такой тип:

```haskell
data Patient = Patient { firstName :: String
                       , lastName  :: String
                       , email     :: String
                       }
```

его определение можно чуток упростить и написать так:

```haskell
data Patient = Patient { firstName
                       , lastName
                       , email     :: String
                       }
```

Раз тип всех трёх полей одинаков, мы указываем его лишь для последней из меток. Ещё пример полной формы:

```haskell
data Patient = Patient { firstName    :: String
                       , lastName     :: String
                       , email        :: String
                       , age          :: Int
                       , diseaseId    :: Int
                       , isIndoor     :: Bool
                       , hasInsurance :: Bool
                       }
```

и тут же упрощаем:

```haskell
data Patient = Patient { firstName
                       , lastName
                       , email        :: String
                       , age
                       , diseaseId    :: Int
                       , isIndoor
                       , hasInsurance :: Bool
                       }
```

Поля `firstName`, `lastName` и `email` имеют тип `String`, поля `age` и `diseaseId` — тип `Int`, и оставшиеся два поля — тип `Bool`.

##### Getter и Setter?

Что же представляют собой метки? Фактически, это особые функции, сгенерированные автоматически. Эти функции имеют три предназначения: создавать, извлекать и изменять. Да, я не оговорился, изменять. Но об этом чуть позже, пусть будет маленькая интрига.

Вот как мы создаём значение типа `Patient`

```haskell
main :: IO ()
main = print $ diseaseId patient
  where
    patient = Patient {
        firstName    = "John"
      , lastName     = "Doe"
      , email        = "john.doe@gmail.com"
      , age          = 24
      , diseaseId    = 431
      , isIndoor     = True
      , hasInsurance = True
    }
```

Метки полей используются как своего рода setter (от англ. set, «устанавливать»):

```haskell
patient = Patient { firstName    =      "John"
в этом    типа      поле с
значении  Patient   этой меткой  равно  этой строке
```

Кроме того, метку можно использовать и как getter (от англ. get, «получать»):

```haskell
main = print $ diseaseId  patient

               метка как  аргумент
               функции
```

Мы применяем метку к значению типа `Patient` и получаем значение соответствующего данной метке поля. Поэтому для получения значений полей нам уже не нужен паттерн матчинг.

Но что же за интригу я приготовил под конец? Выше я упомянул, что метки используются не только для задания значений полей и для их извлечения, но и для изменения. Вот что я имел в виду:

```haskell
main :: IO ()
main = print $ email patientWithChangedEmail
  where
    patientWithChangedEmail = patient {
      email = "j.d@gmail.com"  -- Изменяем???
    }

    patient = Patient {
        firstName    = "John"
      , lastName     = "Doe"
      , email        = "john.doe@gmail.com"
      , age          = 24
      , diseaseId    = 431
      , isIndoor     = True
      , hasInsurance = True
    }
```

При запуске программы получим:

```haskell
j.d@gmail.com
```

Но постойте, что же тут произошло? Ведь в Haskell, как мы знаем, нет оператора присваивания, однако значение поля с меткой `email` поменялось. Помню, когда я впервые увидел подобный пример, то очень удивился, мол, уж не ввели ли меня в заблуждение по поводу неизменности значений в Haskell?!

Нет, не ввели. Подобная запись:

```haskell
patientWithChangedEmail = patient {
  email = "j.d@gmail.com"
}
```

действительно похожа на изменение поля через присваивание ему нового значения, но в действительности никакого изменения не произошло. Когда я назвал метку setter-ом, я немного слукавил, ведь классический setter из мира ООП был бы невозможен в Haskell. Посмотрим ещё раз внимательнее:

```haskell
...
  where
    patientWithChangedEmail = patient {
      email = "j.d@gmail.com"  -- Изменяем???
    }

    patient = Patient {
        firstName    = "John"
      , lastName     = "Doe"
      , email        = "john.doe@gmail.com"
      , age          = 24
      , diseaseId    = 431
      , isIndoor     = True
      , hasInsurance = True
    }
```

Взгляните, ведь у нас теперь два значения типа `Patient`, `patient` и `patientWithChangedEmail`. Эти значения не имеют друг ко другу ни малейшего отношения. Вспомните, как я говорил, что в Haskell нельзя изменить имеющееся значение, а можно лишь создать на основе имеющегося новое значение. Это именно то, что здесь произошло: мы взяли имеющееся значение `patient` и на его основе создали уже новое значение `patientWithChangedEmail`, значение поля `email` в котором теперь другое. Понятно, что поле `email` в значении `patient` осталось неизменным.

Будьте внимательны при инициализации значения с полями: вы обязаны предоставить значения для всех полей. Если вы напишете так:

```haskell
main :: IO ()
main = print $ email patientWithChangedEmail
  where
    patientWithChangedEmail = patient {
      email = "j.d@gmail.com"  -- Изменяем???
    }

    patient = Patient {
        firstName    = "John"
      , lastName     = "Doe"
      , email        = "john.doe@gmail.com"
      , age          = 24
      , diseaseId    = 431
      , isIndoor     = True
    }

    -- Поле hasInsurance забыли!
```

код скомпилируется, но внимательный компилятор предупредит вас о проблеме:

```haskell
Fields of ‘Patient’ not initialised: hasInsurance
```

Пожалуйста, не пренебрегайте подобным предупреждением, ведь если вы проигнорируете его и затем попытаетесь обратиться к неинициализированному полю:

```haskell
main = print $ hasInsurance patient
  ...
```

ваша программа аварийно завершится на этапе выполнения с ожидаемой ошибкой:

```haskell
Missing field in record construction hasInsurance
```

Не забывайте: компилятор — ваш добрый друг.

##### Без меток

Помните, что метки полей — это синтаксический сахар, без которого мы вполне можем обойтись. Даже если тип был определён с метками, как наш `Patient`, мы можем работать с ним по-старинке:

```haskell
data Patient = Patient { firstName    :: String
                       , lastName     :: String
                       , email        :: String
                       , age          :: Int
                       , diseaseId    :: Int
                       , isIndoor     :: Bool
                       , hasInsurance :: Bool
                       }

main :: IO ()
main = print $ hasInsurance patient
  where
    -- Создаём по-старинке...
    patient = Patient "John"
                      "Doe"
                      "john.doe@gmail.com"
                      24
                      431
                      True
                      True
```

Соответственно, извлекать значения полей тоже можно по-старинке, через паттерн матчинг:

```haskell
main :: IO ()
main = print insurance
  where
    -- Жутко неудобно, но если желаете...
    Patient _ _ _ _ _ _ insurance = patient
    patient = Patient "John"
                      "Doe"
                      "john.doe@gmail.com"
                      24
                      431
                      True
                      True
```

С другими видами синтаксического сахара мы встретимся ещё не раз, на куда более продвинутых примерах.

Итого:

```haskell
data Patient = Patient { firstName
                       , lastName
                       , email        :: String
                       , age
                       , diseaseId    :: Int
                       , isIndoor
                       , hasInsurance :: Bool
                       }

-- По старинке
{-
main :: IO ()
main = print insurance
  where
    -- Жутко неудобно, но если желаете...
    Patient _ _ _ _ _ _ insurance = patient
    patient = Patient "John"
                      "Doe"
                      "john.doe@gmail.com"
                      24
                      431
                      True
                      True
-}

-- С сахарком :3
main :: IO ()
main = print $ email patientWithChangedEmail
  where
    patientWithChangedEmail = patient {
      email = "j.d@gmail.com"  -- Изменяем???
    }

    patient = Patient {
        firstName    = "John"
      , lastName     = "Doe"
      , email        = "john.doe@gmail.com"
      , age          = 24
      , diseaseId    = 431
      , isIndoor     = True
      , hasInsurance = True
    }
```

#### Новый тип

Помимо `data` существует ещё одно ключевое слово, предназначенное для определения нового типа. Оно так и называется — `newtype`. Эти слова похожи друг на друга «в одну сторону»: вы можете поставить `data` на место `newtype`, но не наоборот.

##### Различия

Тип, определяемый с помощью слова `newtype`, обязан иметь один и только один конструктор значения. Мы можем написать так:  

```haskell
newtype IPAddress = IP String
```

А вот так не можем:

```haskell
newtype IPAddress = IP String | Localhost
```

Компилятор заупрямится:

```haskell
A newtype must have exactly one constructor,
  but ‘IPAddress’ has two
In the newtype declaration for ‘IPAddress’
```

Кроме того, в таком типе должно быть одно и лишь одно поле. То есть можно так:

```haskell
newtype IPAddress = IP String
```

Или же так, с меткой:

```haskell
newtype IPAddress = IP { value :: String }
```

А вот два или более полей запихнуть не удастся:

```haskell
newtype EndPoint = EndPoint String Int
```

Компилятор вновь обратит наше внимание на проблему:

```haskell
The constructor of a newtype must have exactly one field
  but ‘EndPoint’ has two
In the definition of data constructor ‘EndPoint’
In the newtype declaration for ‘EndPoint’
```

Более того, нульарный конструктор тоже не подойдёт:

```haskell
newtype HardDay = Monday
```

И вновь ошибка:

```haskell
The constructor of a newtype must have exactly one field
  but ‘Monday’ has none
```

##### Зачем он нужен?

В самом деле, зачем нам нужно такое хозяйство? Это нельзя, то нельзя. Какой смысл?

Смысл в оптимизации. Обратите внимание на модель `newtype`:

```haskell
newtype IPAddress = IP           String

новый   название    конструктор  Поле
тип                 значения
```

Фактически, `newtype` берёт одно-единственное значение некоторого существующего типа и всего лишь оборачивает его в свой конструктор. Именно поэтому тип, введённый с помощью `newtype`, не относится к АТД, и с точки зрения компилятора он является лишь переименованием типа (англ. type renaming). Это делает такой тип более простым и эффективным с точки зрения представления в памяти, нежели тип, определяемый с `data`.

Когда мы пишем так:

```haskell
data IPAddress = IP String
```

мы говорим компилятору: «`IPAddress` — это абсолютно новый и самобытный тип, которого никогда не было ранее». А когда пишем так:

```haskell
newtype IPAddress = IP String
```

мы говорим: «`IPAddress` — это всего лишь обёртка для значения уже существующего типа `String`».

##### type vs newtype

Внимательный читатель спросит, в чём же фундаментальное отличие типов, вводимых с помощью `newtype`, от типов, вводимых с помощью `type`? Там синоним, тут — обёртка. Отличие вот в чём.

Когда мы пишем так:

```haskell
type String = [Char]
```

мы объявляем: «Тип `String` — это эквивалентная замена типу `[Char]`». И поэтому везде, где в коде стоит `[Char]`, мы можем поставить `String`, и везде, где стоит `String`, мы можем поставить `[Char]`. Например, если функция объявлена так:

```haskell
replace :: String
        -> String
        -> String
        -> String
```

мы можем спокойно переписать объявление:

```haskell
replace :: [Char]
        -> [Char]
        -> [Char]
        -> [Char]
```

и ничего не изменится.

Когда же мы пишем так:

```haskell
newtype MyInt = MyInt Int
```

мы объявляем: «Тип `MyInt` — это новый тип, представление которого такое же, как у типа `Int`». Мы не можем просто взять и поставить `MyInt` на место `Int`, потому что эти типы равны лишь с точки зрения представления в памяти, с точки зрения системы типов они абсолютно различны.

А зачем же нам нужно это? Для простоты и надёжности кода. Допустим, есть такая функция:

```haskell
getBuildsInfo :: String -> Int -> BuildsInfo
getBuildsInfo projectName limit = ...
```

Эта функция запрашивает у CI-сервиса (через REST API) информацию о сборках проекта. Из определения мы видим, что первым аргументом выступает имя проекта, а вторым — количество сборок. Однако в месте применения функции это может быть не столь очевидным:

```haskell
  let info = getBuildsInfo "ohaskell.guide" 4
```

Что такое первая строка? Что такое второе число? Неясно, нужно глядеть в определение, ведь даже объявление не расскажет нам правду:

```haskell
getBuildsInfo :: String  -> Int    -> BuildsInfo

                 что за     что за
                 строка?    число?
```

Вот тут нам и помогают наши типы, ведь стандартные `String` и `Int` сами по себе не несут никакой полезной информации о своём содержимом. Конечно, мы могли бы обойтись и без типов, просто введя промежуточные выражения:

```haskell
  let project = "ohaskell.guide"
      limit   = 4
      info    = getBuildsInfo project limit
```

Однако программист может этого и не сделать, и тогда мы получим «магические значения», смысл которых нам неизвестен. Куда лучше ввести собственные типы:

```haskell
newtype Project = Project String
newtype Limit = Limit Int

getBuildsInfo :: Project -> Limit  -> BuildsInfo

                 уже не     уже не
                 просто     просто
                 строка     число
```

Это заставит нас писать явно:

```haskell
  let info = getBuildsInfo (Project "ohaskell.guide")
                           (Limit 4)
```

Теперь, даже без промежуточных выражений, смысл строки и числа вполне очевиден. Это важный принцип в Haskell: безликие типы наподобие `String` или `Int` заменять на типы, имеющие конкретный смысл для нас.

Кроме того, `newtype`-типы помогают нам не допускать глупых ошибок. Например, есть другая функция:

```haskell
getArtifacts :: String -> Int -> Int -> [Project]
getArtifacts projectName limit offset = ...
```

Мало того, что перед нами вновь безликие `Int`, так их ещё и два. И вот какая нелепая ошибка может нас поджидать:

```haskell
  let project = "ohaskell.guide"
      limit   = 4
      offset  = 1
      info    = getArtifacts project offset limit
```

Заметили? Мы случайно перепутали аргументы местами, поставив `offset` на место `limit`. Работа функции при этом нарушится, однако компилятор останется нем как рыба, ведь с точки зрения системы типов ошибки не произошло: и там `Int`, и тут `Int`. Синонимы для `Int` также не помогли бы. Однако если у нас будут `newtype`-типы:

```haskell
newtype Limit = Limit Int
newtype Offset = Offset Int
```

тогда подобная ошибка не пройдёт незамеченной:

```haskell
  let project = "ohaskell.guide"
      limit   = Limit 4
      offset  = Offset 1
      info    = getArtifacts offset limit
```

Типы аргументов теперь разные, а значит, путаница между ними гарантированно прервёт компиляцию.

Вот такие они, `newtype`-типы. В последующих главах мы увидим ещё большую мощь системы типов Haskell.

#### Конструктор типа

В предыдущих главах мы познакомились с АТД, которые сами по себе уже весьма полезны. И всё же есть в них одно ограничение: они напрочь лишены гибкости. Вот тебе конкретные поля, а вот тебе конкретные типы, будь счастлив. Но существует способ наделить наши тип куда большей силой. Эта глава станет для нас переломной, ведь с неё начнётся наш путь в мир действительно мощных типов.

##### Опциональный тип

Допустим, у нас есть список пар следующего вида:

```haskell
type Chapters = [(FilePath, String)]

chapters :: Chapters
chapters = [ ("/list.html",  "Список")
           , ("/tuple.html", "Кортеж")
           , ("/hof.html",   "ФВП")
           ]
```

Тип `FilePath` есть не более чем стандартный синоним для типа `String`, но он более информативен. Итак, этот список содержит названия трёх глав данной книги и пути к ним. И вот понадобилась нам функция, которая извлекает название главы по её пути:

```haskell
lookupChapterNameBy :: FilePath -> Chapters -> String
lookupChapterNameBy _ [] = ""  -- Так ничего и не нашли...
lookupChapterNameBy path ((realPath, name) : others)
  | path == realPath = name -- Пути совпадают, вот вам имя.
  | otherwise        = lookupChapterNameBy path others
```

Всё предельно просто: рекурсивно бежим по списку пар `chapters`, на каждом шаге извлекая через паттерн матчинг путь ко главе и её имя. Сравниваем пути и, ежели совпадают — на выходе получается имя, соответствующее заданному пути. Если же, пройдя весь список, мы так и не нашли соответствующего пути, на выходе будет пустая строка.

Используем так:

```haskell
main :: IO ()
main = putStrLn $
  if | null name -> "No such chapter, sorry..."
     | otherwise -> "This is chapter name: " ++ name
  where
    name = lookupChapterNameBy "/tuple.html" chapters
```

Если на выходе функции `lookupChapterNameBy` пустая строка, значит мы ничего не нашли, в противном же случае показываем найденное имя.

Ну и как вам такое решение? Вроде бы красивое, но почему, собственно, пустая строка? Я вполне мог написать заготовку для очередной главы и ещё не дать ей имя:

```haskell
chapters :: Chapters
chapters = [ ("/list.html",  "Список")
           , ("/tuple.html", "Кортеж")
           , ("/hof.html",   "ФВП")
           , ("/monad.html", "")  -- Заготовка
           ]
```

В этом случае наше решение ломается: пустая строка на выходе функции `lookupChapterNameBy` может означать теперь как то, что мы не нашли главы с таким путём, так и то, что глава-то существует, просто её имя пока не задано. Следовательно, нам нужен другой механизм проверки результата поиска, более однозначный.

Определим опциональный тип. Опциональным (англ. optional) называют такой тип, внутри которого либо есть нечто полезное, либо нет. Выглядеть он будет так:

```haskell
data Optional = NoSuchChapter
              | Chapter String
```

Если значение типа `Optional` создано с помощью нульарного конструктора `NoSuchChapter`, это означает, что внутри ничего нет, перед нами значение-пустышка. Это и будет соответствовать тому случаю, когда нужную главу мы не нашли. А вот если значение было создано с помощью унарного конструктора `Chapter`, это несомненно будет означать то, что мы нашли интересующую нас главу. Перепишем функцию `lookupChapterNameBy`:

```haskell
lookupChapterNameBy :: FilePath -> Chapters -> Optional
lookupChapterNameBy _ [] = NoSuchChapter -- Пустышка
lookupChapterNameBy path ((realPath, name) : others)
  | path == realPath = Chapter name      -- Реальное имя
  | otherwise        = lookupChapterNameBy path others
```

Код стал более понятным. И вот как мы будем работать с этой функцией:

```haskell
main :: IO ()
main = putStrLn $
  case result of
    NoSuchChapter -> "No such chapter, sorry..."
    Chapter name  -> "This is chapter name: " ++ name
  where
    result = lookupChapterNameBy "/tuple.html" chapters
```

Отныне функция `lookupChapterNameBy` сигнализирует о неудачном поиске не посредством пустой строки, а посредством нульарного конструктора. Это и надёжнее, и читабельнее.

Красиво, но в этом элегантном решении всё-таки остаётся один изъян: оно намертво привязано к типу `String`:

```haskell
data Optional = NoSuchChapter
              | Chapter String

                        Почему
                        именно
                        String?
```

В самом деле, почему? Например, в Haskell широкое применение получил тип `Text` из одноимённого пакета. Этот тип, кстати, значительно мощнее и эффективнее стандартной `String`. Значит, если мы захотим определить опциональный тип и для `Text`, придётся дублировать:

```haskell
data Optional = NoSuchChapter | Chapter String

data Optional = NoSuchChapter | Chapter Text
```

Однако компилятор наотрез откажется принимать такой код:

```haskell
Multiple declarations of ‘Optional’
```

Имена-то типов одинаковые! Хорошо, уточним:

```haskell
data OptionalString = NoSuchChapter | Chapter String

data OptionalText   = NoSuchChapter | Chapter Text
```

Но и в этом случае компиляция не пройдёт:

```haskell
Multiple declarations of ‘NoSuchChapter’

...

Multiple declarations of ‘Chapter’
```

Конструкторы значений тоже одноимённые, опять уточняем:

```haskell
data OptionalString = NoSuchChapterString
                    | ChapterString String

data OptionalText   = NoSuchChapterText
                    | ChapterText Text
```

Вот теперь это работает, но код стал избыточным. А вдруг мы пожелаем добавить к двум строковым типам ещё и третий? Или четвёртый? Что ж нам, для каждого типа вот так вот уточнять? Нет, умный в гору не пойдёт — есть лучший путь.

##### Может быть

В стандартной библиотеке живёт тип по имени `Maybe`:

```haskell
data Maybe a = Nothing | Just a
```

Тип `Maybe` (от англ. maybe, «может быть») нужен для создания тех самых опциональных значений. Впрочем, я выразился неточно, ведь, несмотря на ключевое слово `data`, `Maybe` — это не совсем тип, это конструктор типа (англ. type constructor). Данная концепция используется в Haskell чрезвычайно часто, и, как и большинство концепций в этом языке, она столь полезна потому, что очень проста.

Конструктор типа — это то, что создаёт новый тип (потенциально, бесконечное множество типов). Когда мы явно определяем тип, он прямолинеен и однозначен:

```haskell
data Optional = NoSuchChapter | Chapter      String

     имя типа   нульарный       унарный      поле
                конструктор     конструктор  типа
                значения        значения     String
```

Когда же мы определяем конструктор типа, мы создаём концептуальный скелет для будущих типов. Взглянем ещё раз (к-тор — это конструктор, для краткости):

```haskell
              ______________________________
             /                              `v

data Maybe  a        = Nothing   | Just      a

     к-тор  типовая    нульарный   унарный   поле
     типа   заглушка   к-тор       к-тор     типа
                       значения    значения  a
```

Здесь присутствует уже знакомая нам типовая заглушка `a`, она-то и делает `Maybe` конструктором типа. Как мы помним, на место типовой заглушки всегда встаёт какой-то тип. Перепишем функцию `lookupChapterNameBy` для работы с `Maybe`:

```haskell
lookupChapterNameBy :: FilePath -> Chapters -> Maybe String
lookupChapterNameBy _ [] = Nothing  -- Пустышка
lookupChapterNameBy path ((realPath, name) : others)
  | path == realPath = Just name    -- Реальное имя
  | otherwise        = lookupChapterNameBy path others
```

Рассмотрим обновлённое объявление:

```haskell
lookupChapterNameBy :: FilePath
                    -> Chapters -> Maybe String

                                   это тип такой,
                                   называется
                                   Maybe String
```

На выходе видим значение типа `Maybe String`. Этот тип был порождён конструктором `Maybe`, применённым к типу `String`. Стоп, я сказал «применённым»? Да, именно так: вы можете воспринимать конструктор типа как особую «функцию», назовём её «типовая функция». Нет, это не официальный термин из Haskell, это просто аналогия: обычная функция работает с данными, а типовая функция работает с типами. Сравните это:

```haskell
length   [1, 2, 3] = 3

функция  данное    = другое данное
```

и это:

```haskell
Maybe    String    = Maybe String

типовая  тип       = другой тип
функция
```

Применение конструктора типа к существующему типу порождает некий новый тип, и это очень мощная техника, используемая в Haskell почти на каждом шагу. Например, если нам нужно завернуть в опциональное значение уже не `String`, а ранее упомянутый `Text`, мы ничего не должны менять в конструкторе `Maybe`:

```haskell
Maybe    Text = Maybe Text

типовая  тип  = другой тип
функция
```

Какой тип подставляем на место `a`, такой тип и станет опциональным. В этом и заключается красота конструкторов типов, ведь они дают нам колоссальный простор для творчества.

А теперь мы подошли к очень важной теме.

##### Этажи

Что такое тип `Maybe String`? Да, мы уже знаем, это АТД. Но что это такое по сути? Зачем мы конструируем сложные типы из простых? Я предлагаю вам аналогию, которая поможет нам взглянуть на этот вопрос несколько иначе. Эта аналогия отнюдь не аксиома, просто я нашёл её полезной для себя самого. Думаю, вам она тоже будет полезна. Конечно, предлагать аналогии — дело неблагодарное, ведь любая из них несовершенна и может быть так или иначе подвергнута критике. Поэтому не воспринимайте мою аналогию как единственно верную.

С точки зрения типов любую Haskell-программу можно сравнить с многоэтажным домом. И вот представьте, мы смотрим на этот дом со стороны.

На самом нижнем этаже расположены простейшие стандартные типы, такие как `Int`, `Double`, `Char` или список. Возьмём, например, тип `Int`. Что это такое? Целое число. Оно не несёт в себе никакого смысла, это всего лишь число в вакууме. Или вот строка — что она такое? Это просто набор каких-то символов в том же вакууме, и ничего более. И если бы мы были ограничены лишь этими типами, наша программистская жизнь была бы весьма грустной.

А вот на втором и последующих этажах живут типы куда более интересные. Например, на одном из этажей живёт тип `Maybe String`. При создании типа `Maybe String` происходит важное событие: мы поднимаемся с первого на более высокий этаж. Считайте эти этажи уровнями абстракции. Если тип `String` — это всего лишь безликая строка, то тип `Maybe String` — это уже не просто строка, это опциональная строка, или, если хотите, строка, наделённая опциональностью. Подняться на тот или иной этаж в нашем типовом небоскрёбе — это значит взять более простой тип и наделить его новым смыслом, новыми возможностями.

Или вот вспомним тип `IPAddress`:

```haskell
data IPAddress = IPAddress String
```

Мы опять-таки взяли ничего не значащую строку и подняли её на этаж под названием `IPAddress`, и теперь это уже не просто какая-то строка, это IP-адрес. Новый тип наделил бессмысленную строку вполне определённым смыслом. А когда мы вытаскиваем внутреннюю строку из `IPAddress` с помощью паттерн матчинга, мы вновь оказываемся на первом этаже.

А вот ещё наш тип, `EndPoint`:

```haskell
data EndPoint = EndPoint IPAddress Int
```

Тут мы поднялись ещё чуток: сначала подняли строку на этаж IP-адреса, а затем взяли его и тип `Int` и подняли их на следующий этаж под названием `EndPoint`, и на этом этаже перед нами уже не просто какой-то IP-адрес и какое-то число, перед нами уже связанные друг с другом адрес и порт.

А вот ещё один пример, знакомство с которым я откладывал до сих пор. Вспомним определение главной функции `main`:

```haskell
main :: IO ()
```

Я обещал рассказать о том, что такое `IO`, и вот теперь рассказываю: `IO` — это тоже конструктор типа. Правда, конструктор особенный, непохожий на наши `IPAddress` или `EndPoint`, но об этом подробнее в следующих главах. Так вот поднявшись на этаж под названием `IO`, мы получаем очень важную способность — способность взаимодействовать с внешним миром: файл прочесть, на консоль текст вывести, и в том же духе. И потому тип `IO String` — это уже не просто невесть откуда взявшаяся строка, но строка, полученная из внешнего мира (например, из файла). И единственная возможность наделить наши функции способностью взаимодействовать с внешним миром — поднять (ну или опустить) их на `IO`-этаж. Вот так и получается: в процессе работы программы мы постоянно прыгаем в лифт и переезжаем с одного типового этажа на другой.

Но запомните: не все этажи одинаковы! Не со всякого этажа можно напрямую попасть на любой другой. Более того, есть такие этажи, оказавшись на котором, мы в конечном итоге обязаны на него и вернуться. Понимаю, сейчас это порождает больше вопросов, нежели ответов, но не беспокойтесь: ответы ждут нас в последующих главах.

Итого:

```haskell
type Chapters = [(FilePath, String)]

chapters :: Chapters
chapters = [ ("/list.html",  "Список")
           , ("/tuple.html", "Кортеж")
           , ("/hof.html",   "ФВП")
           , ("/monad.html", "")  -- Заготовка
           ]

lookupChapterNameBy :: FilePath -> Chapters -> Maybe String
lookupChapterNameBy _ [] = Nothing  -- Пустышка
lookupChapterNameBy path ((realPath, name) : others)
  | path == realPath = Just name    -- Реальное имя
  | otherwise        = lookupChapterNameBy path others


main :: IO ()
main = putStrLn $
  case result of
    Nothing   -> "No such chapter, sorry..."
    Just name -> "This is chapter name: " ++ name
  where
    result = lookupChapterNameBy "/tuple.html" chapters

```

---
## 2023.06.09

### Краткий отчет

### Подробный отчет

---
## 2023.06.12

### Краткий отчет

### Подробный отчет

---
## 2023.06.13

### Краткий отчет

### Подробный отчет

---
## 2023.06.14

### Краткий отчет

### Подробный отчет

---
## 2023.06.15

### Краткий отчет

### Подробный отчет

---
## 2023.06.16

### Краткий отчет

### Подробный отчет

---
## 2023.06.19

### Краткий отчет

### Подробный отчет

---
## 2023.06.20

### Краткий отчет

### Подробный отчет

---
## 2023.06.21

### Краткий отчет

### Подробный отчет

---
## 2023.06.22

### Краткий отчет

### Подробный отчет

---
## 2023.06.23

### Краткий отчет

### Подробный отчет


# Полезные ссылки

## Книги, курсы и иные обучающие ресурсы

1. [О Haskell по-человечески](https://www.ohaskell.guide/)
2. 
3. 
4. 
5. 
6. 
7. 
8. 
9. 

## Онлайн компиляторы

1. [Haskell Playground](https://play.haskell.org/)
2. [Онлайн компилятор Haskell - haskell](https://www-tutorialspoint-com.translate.goog/compile_haskell_online.php?_x_tr_sl=en&_x_tr_tl=ru&_x_tr_hl=ru&_x_tr_pto=sc)
3. [Online Haskell Compiler - Online Haskell Editor - Run Haskell Online - Online Haskell Runner](https://www.jdoodle.com/execute-haskell-online/)
4. [Online Haskell Compiler - online editor](https://www.onlinegdb.com/online_haskell_compiler)
5. [Haskell - OneCompiler - Write, run and share Haskell code online](https://onecompiler.com/haskell)
6. [compile haskell online](https://rextester.com/l/haskell_online_compiler)

# Остальные ссылки

1. [официальное описание стандарта Haskell 2010](https://www.haskell.org/onlinereport/haskell2010/)
2. [Stack Overflow по тегу Haskell](http://stackoverflow.com/questions/tagged/haskell).
3. 
4. 
5. 
6. 
7. 
8. 
9. 
10. 
11. 
12. 
13. 

