Ссылка на оригинал: https://www.codewars.com/kata/reviews/57a3972b78e098928c00008d/groups/597fb4725f9111271a000529

На codewars была задача - спарсить float

человек решило очень интересно

```haskell
module ParseFloat (parseFloat) where

import Data.Maybe (fromMaybe)
import Data.Char (ord)

-- A regular grammar for float representations might look like this:
--   float    ::= mantissa exponent?
--   mantissa ::= sign? decimal
--   decimal  ::= digit+ ('.' digit*)?
--              | '.' digit+
--   exponent ::= [eE] sign? digit+
--   sign     ::= [+-]
--   digit    ::= [0123456789]
floatP    = mantissaP <++> optional exponentP
mantissaP = optional signP <++> decimalP
decimalP  = atLeastOnce digitP <++> optional (oneOf "." <++> repeated digitP) 
        <|> oneOf "." <++> atLeastOnce digitP
exponentP = oneOf "eE" <++> optional signP <++> atLeastOnce digitP
signP     = oneOf "+-"
digitP    = oneOf "0123456789"      

-- A float representation, featuring all the optional parts, can be
-- labelled as such:
--   +----------- mantissa sign
--   |+---------- mantissa value, integer part
--   ||   +------ mantissa value, real part
--   ||   |   +-- exponent sign
--   ||   |   |+- exponent value
--   ||__ |__ ||
--   -123.456e+7
type FloatExpr = (Char, String, String, Char, String)

-- Iff there is exactly one parse result that consumes the entire input,
-- we use it and normalize to the following defaults:
-- a) mantissa sign, unless present, is positive: '+'
-- b) exponent, unless present, is zero: "e+0"
-- c) exponent sign, unless present, is positive: '+'
parseFloatExpr :: String -> Maybe FloatExpr
parseFloatExpr s = case filter (null . snd) $ floatP s of
  [((m, e), "")] -> Just (mSig, iPart, rPart, eSig, ePart)
    where (mSigOpt, mDecAlt) = m
          mSig = fromMaybe '+' mSigOpt
          (iPart, rPart) = case mDecAlt of
            Left (iPart, Just (_, rPart)) -> (iPart, rPart)
            Left (iPart, Nothing)         -> (iPart, "")
            Right (_, rPart)              -> ("", rPart)
          ((_, eSigOpt), ePart) = fromMaybe (('e', Just '+'), "0") e
          eSig = fromMaybe '+' eSigOpt
  _ -> Nothing

-- Interpret a String of digit Chars as positional notation, with the given base.
fromDigitsWithBase :: Float -> String -> Float
fromDigitsWithBase b d = let magnitudes = iterate (* b) 1
                             values = map fromChar $ reverse d
                          in sum $ zipWith (*) magnitudes values
                         where fromChar c = fromIntegral $ ord c - ord '0'

fromSig :: Char -> Float
fromSig '+' =  1
fromSig '-' = -1

-- Finally, we can parse a string representation of a float into a FloatExpr structure.
-- The digit strings (i-part, r-part, e-part) are evaluated in base 10, where
-- the decimal dot specifies the ones' place.
parseFloat :: String -> Maybe Float
parseFloat x = do (mSig, iPart, rPart, eSig, ePart) <- parseFloatExpr x
                  let ms = fromSig mSig
                      i  = fromDigitsWithBase 10 iPart
                      r  = fromDigitsWithBase 0.1 $ reverse $ '0':rPart
                      es = fromSig eSig
                      e  = fromDigitsWithBase 10 ePart
                   in return $ (ms * (i + r)) * (10 ** (es * e))

-- A parser builder for regular grammars along the lines of:
-- <http://dev.stephendiehl.com/fun/002_parsers.html>

-- A Parser turns the prefix of a given String into another thing.
-- It produces pairs of things and the respecive rests of the string.
type Parser a = String -> [(a, String)]

-- Apply a function to the results of a parser.
pmap :: (a -> b) -> Parser a -> Parser b
pmap f p s = [(f a, s') | (a, s') <- p s]

-- Ignore results that don't match a predicate.
pfilter :: (a -> Bool) -> Parser a -> Parser a
pfilter f p s = [(a, s') | (a, s') <- p s, f a]

-- Apply the Parser zero or more times.
-- Corresponds to the regex operator star: 
--   pattern* :== ""
--              | pattern pattern*
repeated :: Parser a -> Parser [a]
repeated p s = ([], s) 
             : [(a:as, s'') | (a, s') <- p s, (as, s'') <- repeated p s']

-- Apply the parser one or more times.
-- Corresponds to the regex operator plus:
--   pattern+ :== pattern pattern*
atLeastOnce :: Parser a -> Parser [a]
atLeastOnce p = pfilter (not . null) (repeated p)

-- Apply the parser zero or one times.
-- Corresponds to the regex operator question mark:
--   pattern? :== ""
--              | pattern
optional :: Parser a -> Parser (Maybe a)
optional p s = (Nothing, s) 
             : pmap Just p s

-- Consume one of the specified Chars.
-- Corresponds to character classes in regular expressions.
oneOf :: String -> Parser Char
oneOf c s = case s of
  x:s' | x `elem` c -> [(x, s')]
  _ -> []

-- Apply two parsers in sequence, one after the other.
-- Corresponds to appending two regular expressions.
infixl 2 <++>
(<++>) :: Parser a -> Parser b -> Parser (a, b)
p <++> q = \s -> 
  [((a, b), s'') | (a, s')  <- p s, (b, s'') <- q s']

-- Apply two parsers in parralel, to the same string.
-- Corresponds to the regex operator pipe '|'.
infixl 1 <|>
(<|>) :: Parser a -> Parser b -> Parser (Either a b)
p <|> q = \s ->
  pmap Left p s ++ pmap Right q s

```